// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/networking/v1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
/// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
/// not be included within this rule.
struct K8s_Io_Api_Networking_V1_IPBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CIDR is a string representing the IP Block
  /// Valid examples are "192.168.1.1/24"
  var cidr: String {
    get {return _cidr ?? String()}
    set {_cidr = newValue}
  }
  /// Returns true if `cidr` has been explicitly set.
  var hasCidr: Bool {return self._cidr != nil}
  /// Clears the value of `cidr`. Subsequent reads from it will return its default value.
  mutating func clearCidr() {self._cidr = nil}

  /// Except is a slice of CIDRs that should not be included within an IP Block
  /// Valid examples are "192.168.1.1/24"
  /// Except values will be rejected if they are outside the CIDR range
  /// +optional
  var except: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cidr: String? = nil
}

/// NetworkPolicy describes what network traffic is allowed for a set of Pods
struct K8s_Io_Api_Networking_V1_NetworkPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior for this NetworkPolicy.
  /// +optional
  var spec: K8s_Io_Api_Networking_V1_NetworkPolicySpec {
    get {return _storage._spec ?? K8s_Io_Api_Networking_V1_NetworkPolicySpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
/// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
/// This type is beta-level in 1.8
struct K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of destination ports for outgoing traffic.
  /// Each item in this list is combined using a logical OR. If this field is
  /// empty or missing, this rule matches all ports (traffic not restricted by port).
  /// If this field is present and contains at least one item, then this rule allows
  /// traffic only if the traffic matches at least one port in the list.
  /// +optional
  var ports: [K8s_Io_Api_Networking_V1_NetworkPolicyPort] = []

  /// List of destinations for outgoing traffic of pods selected for this rule.
  /// Items in this list are combined using a logical OR operation. If this field is
  /// empty or missing, this rule matches all destinations (traffic not restricted by
  /// destination). If this field is present and contains at least one item, this rule
  /// allows traffic only if the traffic matches at least one item in the to list.
  /// +optional
  var to: [K8s_Io_Api_Networking_V1_NetworkPolicyPeer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
/// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
struct K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of ports which should be made accessible on the pods selected for this
  /// rule. Each item in this list is combined using a logical OR. If this field is
  /// empty or missing, this rule matches all ports (traffic not restricted by port).
  /// If this field is present and contains at least one item, then this rule allows
  /// traffic only if the traffic matches at least one port in the list.
  /// +optional
  var ports: [K8s_Io_Api_Networking_V1_NetworkPolicyPort] = []

  /// List of sources which should be able to access the pods selected for this rule.
  /// Items in this list are combined using a logical OR operation. If this field is
  /// empty or missing, this rule matches all sources (traffic not restricted by
  /// source). If this field is present and contains at least one item, this rule
  /// allows traffic only if the traffic matches at least one item in the from list.
  /// +optional
  var from: [K8s_Io_Api_Networking_V1_NetworkPolicyPeer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NetworkPolicyList is a list of NetworkPolicy objects.
struct K8s_Io_Api_Networking_V1_NetworkPolicyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of schema objects.
  var items: [K8s_Io_Api_Networking_V1_NetworkPolicy] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkPolicyPeer describes a peer to allow traffic from. Only certain combinations of
/// fields are allowed
struct K8s_Io_Api_Networking_V1_NetworkPolicyPeer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a label selector which selects Pods. This field follows standard label
  /// selector semantics; if present but empty, it selects all pods.
  ///
  /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
  /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  /// Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
  /// +optional
  var podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._podSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._podSelector = newValue}
  }
  /// Returns true if `podSelector` has been explicitly set.
  var hasPodSelector: Bool {return _storage._podSelector != nil}
  /// Clears the value of `podSelector`. Subsequent reads from it will return its default value.
  mutating func clearPodSelector() {_uniqueStorage()._podSelector = nil}

  /// Selects Namespaces using cluster-scoped labels. This field follows standard label
  /// selector semantics; if present but empty, it selects all namespaces.
  ///
  /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
  /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  /// Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
  /// +optional
  var namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._namespaceSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._namespaceSelector = newValue}
  }
  /// Returns true if `namespaceSelector` has been explicitly set.
  var hasNamespaceSelector: Bool {return _storage._namespaceSelector != nil}
  /// Clears the value of `namespaceSelector`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceSelector() {_uniqueStorage()._namespaceSelector = nil}

  /// IPBlock defines policy on a particular IPBlock. If this field is set then
  /// neither of the other fields can be.
  /// +optional
  var ipBlock: K8s_Io_Api_Networking_V1_IPBlock {
    get {return _storage._ipBlock ?? K8s_Io_Api_Networking_V1_IPBlock()}
    set {_uniqueStorage()._ipBlock = newValue}
  }
  /// Returns true if `ipBlock` has been explicitly set.
  var hasIpBlock: Bool {return _storage._ipBlock != nil}
  /// Clears the value of `ipBlock`. Subsequent reads from it will return its default value.
  mutating func clearIpBlock() {_uniqueStorage()._ipBlock = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkPolicyPort describes a port to allow traffic on
struct K8s_Io_Api_Networking_V1_NetworkPolicyPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
  /// field defaults to TCP.
  /// +optional
  var `protocol`: String {
    get {return _storage._protocol ?? String()}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return _storage._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {_uniqueStorage()._protocol = nil}

  /// The port on the given protocol. This can either be a numerical or named port on
  /// a pod. If this field is not provided, this matches all port names and numbers.
  /// +optional
  var port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._port ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return _storage._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {_uniqueStorage()._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NetworkPolicySpec provides the specification of a NetworkPolicy
struct K8s_Io_Api_Networking_V1_NetworkPolicySpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Selects the pods to which this NetworkPolicy object applies. The array of
  /// ingress rules is applied to any pods selected by this field. Multiple network
  /// policies can select the same set of pods. In this case, the ingress rules for
  /// each are combined additively. This field is NOT optional and follows standard
  /// label selector semantics. An empty podSelector matches all pods in this
  /// namespace.
  var podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._podSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._podSelector = newValue}
  }
  /// Returns true if `podSelector` has been explicitly set.
  var hasPodSelector: Bool {return _storage._podSelector != nil}
  /// Clears the value of `podSelector`. Subsequent reads from it will return its default value.
  mutating func clearPodSelector() {_uniqueStorage()._podSelector = nil}

  /// List of ingress rules to be applied to the selected pods. Traffic is allowed to
  /// a pod if there are no NetworkPolicies selecting the pod
  /// (and cluster policy otherwise allows the traffic), OR if the traffic source is
  /// the pod's local node, OR if the traffic matches at least one ingress rule
  /// across all of the NetworkPolicy objects whose podSelector matches the pod. If
  /// this field is empty then this NetworkPolicy does not allow any traffic (and serves
  /// solely to ensure that the pods it selects are isolated by default)
  /// +optional
  var ingress: [K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule] {
    get {return _storage._ingress}
    set {_uniqueStorage()._ingress = newValue}
  }

  /// List of egress rules to be applied to the selected pods. Outgoing traffic is
  /// allowed if there are no NetworkPolicies selecting the pod (and cluster policy
  /// otherwise allows the traffic), OR if the traffic matches at least one egress rule
  /// across all of the NetworkPolicy objects whose podSelector matches the pod. If
  /// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
  /// solely to ensure that the pods it selects are isolated by default).
  /// This field is beta-level in 1.8
  /// +optional
  var egress: [K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule] {
    get {return _storage._egress}
    set {_uniqueStorage()._egress = newValue}
  }

  /// List of rule types that the NetworkPolicy relates to.
  /// Valid options are "Ingress", "Egress", or "Ingress,Egress".
  /// If this field is not specified, it will default based on the existence of Ingress or Egress rules;
  /// policies that contain an Egress section are assumed to affect Egress, and all policies
  /// (whether or not they contain an Ingress section) are assumed to affect Ingress.
  /// If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
  /// Likewise, if you want to write a policy that specifies that no egress is allowed,
  /// you must specify a policyTypes value that include "Egress" (since such a policy would not include
  /// an Egress section and would otherwise default to just [ "Ingress" ]).
  /// This field is beta-level in 1.8
  /// +optional
  var policyTypes: [String] {
    get {return _storage._policyTypes}
    set {_uniqueStorage()._policyTypes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.networking.v1"

extension K8s_Io_Api_Networking_V1_IPBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IPBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cidr"),
    2: .same(proto: "except"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cidr)
      case 2: try decoder.decodeRepeatedStringField(value: &self.except)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cidr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.except.isEmpty {
      try visitor.visitRepeatedStringField(value: self.except, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_IPBlock, rhs: K8s_Io_Api_Networking_V1_IPBlock) -> Bool {
    if lhs._cidr != rhs._cidr {return false}
    if lhs.except != rhs.except {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Networking_V1_NetworkPolicySpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicy, rhs: K8s_Io_Api_Networking_V1_NetworkPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyEgressRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
    2: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ports)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.to)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule, rhs: K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyIngressRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
    2: .same(proto: "from"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ports)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.from)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.from, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule, rhs: K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.from != rhs.from {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Networking_V1_NetworkPolicy] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicyList, rhs: K8s_Io_Api_Networking_V1_NetworkPolicyList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicyPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podSelector"),
    2: .same(proto: "namespaceSelector"),
    3: .same(proto: "ipBlock"),
  ]

  fileprivate class _StorageClass {
    var _podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _ipBlock: K8s_Io_Api_Networking_V1_IPBlock? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podSelector = source._podSelector
      _namespaceSelector = source._namespaceSelector
      _ipBlock = source._ipBlock
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podSelector)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._namespaceSelector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._ipBlock)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._namespaceSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._ipBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicyPeer, rhs: K8s_Io_Api_Networking_V1_NetworkPolicyPeer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podSelector != rhs_storage._podSelector {return false}
        if _storage._namespaceSelector != rhs_storage._namespaceSelector {return false}
        if _storage._ipBlock != rhs_storage._ipBlock {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicyPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyPort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
    2: .same(proto: "port"),
  ]

  fileprivate class _StorageClass {
    var _protocol: String? = nil
    var _port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _protocol = source._protocol
      _port = source._port
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._protocol)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._port)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._protocol {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._port {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicyPort, rhs: K8s_Io_Api_Networking_V1_NetworkPolicyPort) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._port != rhs_storage._port {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Networking_V1_NetworkPolicySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicySpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podSelector"),
    2: .same(proto: "ingress"),
    3: .same(proto: "egress"),
    4: .same(proto: "policyTypes"),
  ]

  fileprivate class _StorageClass {
    var _podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _ingress: [K8s_Io_Api_Networking_V1_NetworkPolicyIngressRule] = []
    var _egress: [K8s_Io_Api_Networking_V1_NetworkPolicyEgressRule] = []
    var _policyTypes: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podSelector = source._podSelector
      _ingress = source._ingress
      _egress = source._egress
      _policyTypes = source._policyTypes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podSelector)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._ingress)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._egress)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._policyTypes)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ingress.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ingress, fieldNumber: 2)
      }
      if !_storage._egress.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._egress, fieldNumber: 3)
      }
      if !_storage._policyTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._policyTypes, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Networking_V1_NetworkPolicySpec, rhs: K8s_Io_Api_Networking_V1_NetworkPolicySpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podSelector != rhs_storage._podSelector {return false}
        if _storage._ingress != rhs_storage._ingress {return false}
        if _storage._egress != rhs_storage._egress {return false}
        if _storage._policyTypes != rhs_storage._policyTypes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
