// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// APIGroup contains the name, the supported versions, and the preferred version
/// of a group.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the group.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// versions are the versions supported in this group.
  var versions: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery] {
    get {return _storage._versions}
    set {_uniqueStorage()._versions = newValue}
  }

  /// preferredVersion is the version preferred by the API server, which
  /// probably is the storage version.
  /// +optional
  var preferredVersion: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery {
    get {return _storage._preferredVersion ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery()}
    set {_uniqueStorage()._preferredVersion = newValue}
  }
  /// Returns true if `preferredVersion` has been explicitly set.
  var hasPreferredVersion: Bool {return _storage._preferredVersion != nil}
  /// Clears the value of `preferredVersion`. Subsequent reads from it will return its default value.
  mutating func clearPreferredVersion() {_uniqueStorage()._preferredVersion = nil}

  /// a map of client CIDR to server address that is serving this group.
  /// This is to help clients reach servers in the most network-efficient way possible.
  /// Clients can use the appropriate server address as per the CIDR that they match.
  /// In case of multiple matches, clients should use the longest matching CIDR.
  /// The server returns only those CIDRs that it thinks that the client can match.
  /// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
  /// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
  /// +optional
  var serverAddressByClientCidrs: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR] {
    get {return _storage._serverAddressByClientCidrs}
    set {_uniqueStorage()._serverAddressByClientCidrs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// APIGroupList is a list of APIGroup, to allow clients to discover the API at
/// /apis.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroupList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// groups is a list of APIGroup.
  var groups: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// APIResource specifies the name of a resource and whether it is namespaced.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the plural name of the resource.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
  /// The singularName is more correct for reporting status on a single item and both singular and plural are allowed
  /// from the kubectl CLI interface.
  var singularName: String {
    get {return _storage._singularName ?? String()}
    set {_uniqueStorage()._singularName = newValue}
  }
  /// Returns true if `singularName` has been explicitly set.
  var hasSingularName: Bool {return _storage._singularName != nil}
  /// Clears the value of `singularName`. Subsequent reads from it will return its default value.
  mutating func clearSingularName() {_uniqueStorage()._singularName = nil}

  /// namespaced indicates if a resource is namespaced or not.
  var namespaced: Bool {
    get {return _storage._namespaced ?? false}
    set {_uniqueStorage()._namespaced = newValue}
  }
  /// Returns true if `namespaced` has been explicitly set.
  var hasNamespaced: Bool {return _storage._namespaced != nil}
  /// Clears the value of `namespaced`. Subsequent reads from it will return its default value.
  mutating func clearNamespaced() {_uniqueStorage()._namespaced = nil}

  /// group is the preferred group of the resource.  Empty implies the group of the containing resource list.
  /// For subresources, this may have a different value, for example: Scale".
  var group: String {
    get {return _storage._group ?? String()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  /// version is the preferred version of the resource.  Empty implies the version of the containing resource list
  /// For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
  var version: String {
    get {return _storage._version ?? String()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {_uniqueStorage()._version = nil}

  /// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
  var kind: String {
    get {return _storage._kind ?? String()}
    set {_uniqueStorage()._kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return _storage._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {_uniqueStorage()._kind = nil}

  /// verbs is a list of supported kube verbs (this includes get, list, watch, create,
  /// update, patch, delete, deletecollection, and proxy)
  var verbs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs {
    get {return _storage._verbs ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs()}
    set {_uniqueStorage()._verbs = newValue}
  }
  /// Returns true if `verbs` has been explicitly set.
  var hasVerbs: Bool {return _storage._verbs != nil}
  /// Clears the value of `verbs`. Subsequent reads from it will return its default value.
  mutating func clearVerbs() {_uniqueStorage()._verbs = nil}

  /// shortNames is a list of suggested short names of the resource.
  var shortNames: [String] {
    get {return _storage._shortNames}
    set {_uniqueStorage()._shortNames = newValue}
  }

  /// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
  var categories: [String] {
    get {return _storage._categories}
    set {_uniqueStorage()._categories = newValue}
  }

  /// The hash value of the storage version, the version this resource is
  /// converted to when written to the data store. Value must be treated
  /// as opaque by clients. Only equality comparison on the value is valid.
  /// This is an alpha feature and may change or be removed in the future.
  /// The field is populated by the apiserver only if the
  /// StorageVersionHash feature gate is enabled.
  /// This field will remain optional even if it graduates.
  /// +optional
  var storageVersionHash: String {
    get {return _storage._storageVersionHash ?? String()}
    set {_uniqueStorage()._storageVersionHash = newValue}
  }
  /// Returns true if `storageVersionHash` has been explicitly set.
  var hasStorageVersionHash: Bool {return _storage._storageVersionHash != nil}
  /// Clears the value of `storageVersionHash`. Subsequent reads from it will return its default value.
  mutating func clearStorageVersionHash() {_uniqueStorage()._storageVersionHash = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// APIResourceList is a list of APIResource, it is used to expose the name of the
/// resources supported in a specific group and version, and if the resource
/// is namespaced.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResourceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// groupVersion is the group and version this APIResourceList is for.
  var groupVersion: String {
    get {return _groupVersion ?? String()}
    set {_groupVersion = newValue}
  }
  /// Returns true if `groupVersion` has been explicitly set.
  var hasGroupVersion: Bool {return self._groupVersion != nil}
  /// Clears the value of `groupVersion`. Subsequent reads from it will return its default value.
  mutating func clearGroupVersion() {self._groupVersion = nil}

  /// resources contains the name of the resources and if they are namespaced.
  var resources: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupVersion: String? = nil
}

/// APIVersions lists the versions that are available, to allow clients to
/// discover the API at /api, which is the root path of the legacy v1 API.
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIVersions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// versions are the api versions that are available.
  var versions: [String] = []

  /// a map of client CIDR to server address that is serving this group.
  /// This is to help clients reach servers in the most network-efficient way possible.
  /// Clients can use the appropriate server address as per the CIDR that they match.
  /// In case of multiple matches, clients should use the longest matching CIDR.
  /// The server returns only those CIDRs that it thinks that the client can match.
  /// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
  /// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
  var serverAddressByClientCidrs: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateOptions may be provided when creating an API object.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_CreateOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When present, indicates that modifications should not be
  /// persisted. An invalid or unrecognized dryRun directive will
  /// result in an error response and no further processing of the
  /// request. Valid values are:
  /// - All: all dry run stages will be processed
  /// +optional
  var dryRun: [String] = []

  /// fieldManager is a name associated with the actor or entity
  /// that is making these changes. The value must be less than or
  /// 128 characters long, and only contain printable characters,
  /// as defined by https://golang.org/pkg/unicode/#IsPrint.
  /// +optional
  var fieldManager: String {
    get {return _fieldManager ?? String()}
    set {_fieldManager = newValue}
  }
  /// Returns true if `fieldManager` has been explicitly set.
  var hasFieldManager: Bool {return self._fieldManager != nil}
  /// Clears the value of `fieldManager`. Subsequent reads from it will return its default value.
  mutating func clearFieldManager() {self._fieldManager = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fieldManager: String? = nil
}

/// DeleteOptions may be provided when deleting an API object.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The duration in seconds before the object should be deleted. Value must be non-negative integer.
  /// The value zero indicates delete immediately. If this value is nil, the default grace period for the
  /// specified type will be used.
  /// Defaults to a per object value if not specified. zero means delete immediately.
  /// +optional
  var gracePeriodSeconds: Int64 {
    get {return _storage._gracePeriodSeconds ?? 0}
    set {_uniqueStorage()._gracePeriodSeconds = newValue}
  }
  /// Returns true if `gracePeriodSeconds` has been explicitly set.
  var hasGracePeriodSeconds: Bool {return _storage._gracePeriodSeconds != nil}
  /// Clears the value of `gracePeriodSeconds`. Subsequent reads from it will return its default value.
  mutating func clearGracePeriodSeconds() {_uniqueStorage()._gracePeriodSeconds = nil}

  /// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
  /// returned.
  /// +optional
  var preconditions: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions {
    get {return _storage._preconditions ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions()}
    set {_uniqueStorage()._preconditions = newValue}
  }
  /// Returns true if `preconditions` has been explicitly set.
  var hasPreconditions: Bool {return _storage._preconditions != nil}
  /// Clears the value of `preconditions`. Subsequent reads from it will return its default value.
  mutating func clearPreconditions() {_uniqueStorage()._preconditions = nil}

  /// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
  /// Should the dependent objects be orphaned. If true/false, the "orphan"
  /// finalizer will be added to/removed from the object's finalizers list.
  /// Either this field or PropagationPolicy may be set, but not both.
  /// +optional
  var orphanDependents: Bool {
    get {return _storage._orphanDependents ?? false}
    set {_uniqueStorage()._orphanDependents = newValue}
  }
  /// Returns true if `orphanDependents` has been explicitly set.
  var hasOrphanDependents: Bool {return _storage._orphanDependents != nil}
  /// Clears the value of `orphanDependents`. Subsequent reads from it will return its default value.
  mutating func clearOrphanDependents() {_uniqueStorage()._orphanDependents = nil}

  /// Whether and how garbage collection will be performed.
  /// Either this field or OrphanDependents may be set, but not both.
  /// The default policy is decided by the existing finalizer set in the
  /// metadata.finalizers and the resource-specific default policy.
  /// Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
  /// allow the garbage collector to delete the dependents in the background;
  /// 'Foreground' - a cascading policy that deletes all dependents in the
  /// foreground.
  /// +optional
  var propagationPolicy: String {
    get {return _storage._propagationPolicy ?? String()}
    set {_uniqueStorage()._propagationPolicy = newValue}
  }
  /// Returns true if `propagationPolicy` has been explicitly set.
  var hasPropagationPolicy: Bool {return _storage._propagationPolicy != nil}
  /// Clears the value of `propagationPolicy`. Subsequent reads from it will return its default value.
  mutating func clearPropagationPolicy() {_uniqueStorage()._propagationPolicy = nil}

  /// When present, indicates that modifications should not be
  /// persisted. An invalid or unrecognized dryRun directive will
  /// result in an error response and no further processing of the
  /// request. Valid values are:
  /// - All: all dry run stages will be processed
  /// +optional
  var dryRun: [String] {
    get {return _storage._dryRun}
    set {_uniqueStorage()._dryRun = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Duration is a wrapper around time.Duration which supports correct
/// marshaling to YAML and JSON. In particular, it marshals into strings, which
/// can be used as map keys in json.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Duration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Int64 {
    get {return _duration ?? 0}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: Int64? = nil
}

/// ExportOptions is the query options to the standard REST get call.
/// Deprecated. Planned for removal in 1.18.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ExportOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Should this value be exported.  Export strips fields that a user can not specify.
  /// Deprecated. Planned for removal in 1.18.
  var export: Bool {
    get {return _export ?? false}
    set {_export = newValue}
  }
  /// Returns true if `export` has been explicitly set.
  var hasExport: Bool {return self._export != nil}
  /// Clears the value of `export`. Subsequent reads from it will return its default value.
  mutating func clearExport() {self._export = nil}

  /// Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
  /// Deprecated. Planned for removal in 1.18.
  var exact: Bool {
    get {return _exact ?? false}
    set {_exact = newValue}
  }
  /// Returns true if `exact` has been explicitly set.
  var hasExact: Bool {return self._exact != nil}
  /// Clears the value of `exact`. Subsequent reads from it will return its default value.
  mutating func clearExact() {self._exact = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _export: Bool? = nil
  fileprivate var _exact: Bool? = nil
}

/// FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
///
/// Each key is either a '.' representing the field itself, and will always map to an empty set,
/// or a string representing a sub-field or item. The string will follow one of these four formats:
/// 'f:<name>', where <name> is the name of a field in a struct, or key in a map
/// 'v:<value>', where <value> is the exact json formatted value of a list item
/// 'i:<index>', where <index> is position of a item in a list
/// 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
/// If a key maps to an empty Fields value, the field that key represents is part of the set.
///
/// The exact format is defined in sigs.k8s.io/structured-merge-diff
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw is the underlying serialization of this object.
  var raw: Data {
    get {return _raw ?? SwiftProtobuf.Internal.emptyData}
    set {_raw = newValue}
  }
  /// Returns true if `raw` has been explicitly set.
  var hasRaw: Bool {return self._raw != nil}
  /// Clears the value of `raw`. Subsequent reads from it will return its default value.
  mutating func clearRaw() {self._raw = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _raw: Data? = nil
}

/// GetOptions is the standard query options to the standard REST get call.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GetOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When specified:
  /// - if unset, then the result is returned from remote storage based on quorum-read flag;
  /// - if it's 0, then we simply return what we currently have in cache, no guarantee;
  /// - if set to non zero, then the result is at least as fresh as given rv.
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resourceVersion: String? = nil
}

/// GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
/// concepts during lookup stages without having partially valid types
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupKind {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: String? = nil
  fileprivate var _kind: String? = nil
}

/// GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
/// concepts during lookup stages without having partially valid types
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var resource: String {
    get {return _resource ?? String()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: String? = nil
  fileprivate var _resource: String? = nil
}

/// GroupVersion contains the "group" and the "version", which uniquely identifies the API.
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: String? = nil
  fileprivate var _version: String? = nil
}

/// GroupVersion contains the "group/version" and "version" string of a version.
/// It is made a struct to keep extensibility.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// groupVersion specifies the API group and version in the form "group/version"
  var groupVersion: String {
    get {return _groupVersion ?? String()}
    set {_groupVersion = newValue}
  }
  /// Returns true if `groupVersion` has been explicitly set.
  var hasGroupVersion: Bool {return self._groupVersion != nil}
  /// Clears the value of `groupVersion`. Subsequent reads from it will return its default value.
  mutating func clearGroupVersion() {self._groupVersion = nil}

  /// version specifies the version in the form of "version". This is to save
  /// the clients the trouble of splitting the GroupVersion.
  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupVersion: String? = nil
  fileprivate var _version: String? = nil
}

/// GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
/// to avoid automatic coersion.  It doesn't use a GroupVersion to avoid custom marshalling
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionKind {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _kind: String? = nil
}

/// GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
/// to avoid automatic coersion.  It doesn't use a GroupVersion to avoid custom marshalling
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var resource: String {
    get {return _resource ?? String()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _group: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _resource: String? = nil
}

/// A label selector is a label query over a set of resources. The result of matchLabels and
/// matchExpressions are ANDed. An empty label selector matches all objects. A null
/// label selector matches no objects.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
  /// map is equivalent to an element of matchExpressions, whose key field is "key", the
  /// operator is "In", and the values array contains only "value". The requirements are ANDed.
  /// +optional
  var matchLabels: Dictionary<String,String> = [:]

  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  /// +optional
  var matchExpressions: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key is the label key that the selector applies to.
  /// +patchMergeKey=key
  /// +patchStrategy=merge
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// operator represents a key's relationship to a set of values.
  /// Valid operators are In, NotIn, Exists and DoesNotExist.
  var `operator`: String {
    get {return _operator ?? String()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  /// values is an array of string values. If the operator is In or NotIn,
  /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
  /// the values array must be empty. This array is replaced during a strategic
  /// merge patch.
  /// +optional
  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _operator: String? = nil
}

/// List holds a list of objects, which may not be known by the server.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of objects
  var items: [K8s_Io_Apimachinery_Pkg_Runtime_RawExtension] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ListMeta describes metadata that synthetic resources must have, including lists and
/// various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// selfLink is a URL representing this object.
  /// Populated by the system.
  /// Read-only.
  ///
  /// DEPRECATED
  /// Kubernetes will stop propagating this field in 1.20 release and the field is planned
  /// to be removed in 1.21 release.
  /// +optional
  var selfLink: String {
    get {return _selfLink ?? String()}
    set {_selfLink = newValue}
  }
  /// Returns true if `selfLink` has been explicitly set.
  var hasSelfLink: Bool {return self._selfLink != nil}
  /// Clears the value of `selfLink`. Subsequent reads from it will return its default value.
  mutating func clearSelfLink() {self._selfLink = nil}

  /// String that identifies the server's internal version of this object that
  /// can be used by clients to determine when objects have changed.
  /// Value must be treated as opaque by clients and passed unmodified back to the server.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  /// +optional
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  /// continue may be set if the user set a limit on the number of items returned, and indicates that
  /// the server has more data available. The value is opaque and may be used to issue another request
  /// to the endpoint that served this list to retrieve the next set of available objects. Continuing a
  /// consistent list may not be possible if the server configuration has changed or more than a few
  /// minutes have passed. The resourceVersion field returned when using this continue value will be
  /// identical to the value in the first response, unless you have received this token from an error
  /// message.
  var `continue`: String {
    get {return _continue ?? String()}
    set {_continue = newValue}
  }
  /// Returns true if ``continue`` has been explicitly set.
  var hasContinue: Bool {return self._continue != nil}
  /// Clears the value of ``continue``. Subsequent reads from it will return its default value.
  mutating func clearContinue() {self._continue = nil}

  /// remainingItemCount is the number of subsequent items in the list which are not included in this
  /// list response. If the list request contained label or field selectors, then the number of
  /// remaining items is unknown and the field will be left unset and omitted during serialization.
  /// If the list is complete (either because it is not chunking or because this is the last chunk),
  /// then there are no more remaining items and this field will be left unset and omitted during
  /// serialization.
  /// Servers older than v1.15 do not set this field.
  /// The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
  /// should not rely on the remainingItemCount to be set or to be exact.
  /// +optional
  var remainingItemCount: Int64 {
    get {return _remainingItemCount ?? 0}
    set {_remainingItemCount = newValue}
  }
  /// Returns true if `remainingItemCount` has been explicitly set.
  var hasRemainingItemCount: Bool {return self._remainingItemCount != nil}
  /// Clears the value of `remainingItemCount`. Subsequent reads from it will return its default value.
  mutating func clearRemainingItemCount() {self._remainingItemCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selfLink: String? = nil
  fileprivate var _resourceVersion: String? = nil
  fileprivate var _continue: String? = nil
  fileprivate var _remainingItemCount: Int64? = nil
}

/// ListOptions is the query options to a standard REST list call.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A selector to restrict the list of returned objects by their labels.
  /// Defaults to everything.
  /// +optional
  var labelSelector: String {
    get {return _labelSelector ?? String()}
    set {_labelSelector = newValue}
  }
  /// Returns true if `labelSelector` has been explicitly set.
  var hasLabelSelector: Bool {return self._labelSelector != nil}
  /// Clears the value of `labelSelector`. Subsequent reads from it will return its default value.
  mutating func clearLabelSelector() {self._labelSelector = nil}

  /// A selector to restrict the list of returned objects by their fields.
  /// Defaults to everything.
  /// +optional
  var fieldSelector: String {
    get {return _fieldSelector ?? String()}
    set {_fieldSelector = newValue}
  }
  /// Returns true if `fieldSelector` has been explicitly set.
  var hasFieldSelector: Bool {return self._fieldSelector != nil}
  /// Clears the value of `fieldSelector`. Subsequent reads from it will return its default value.
  mutating func clearFieldSelector() {self._fieldSelector = nil}

  /// Watch for changes to the described resources and return them as a stream of
  /// add, update, and remove notifications. Specify resourceVersion.
  /// +optional
  var watch: Bool {
    get {return _watch ?? false}
    set {_watch = newValue}
  }
  /// Returns true if `watch` has been explicitly set.
  var hasWatch: Bool {return self._watch != nil}
  /// Clears the value of `watch`. Subsequent reads from it will return its default value.
  mutating func clearWatch() {self._watch = nil}

  /// allowWatchBookmarks requests watch events with type "BOOKMARK".
  /// Servers that do not implement bookmarks may ignore this flag and
  /// bookmarks are sent at the server's discretion. Clients should not
  /// assume bookmarks are returned at any specific interval, nor may they
  /// assume the server will send any BOOKMARK event during a session.
  /// If this is not a watch, this field is ignored.
  /// If the feature gate WatchBookmarks is not enabled in apiserver,
  /// this field is ignored.
  /// +optional
  var allowWatchBookmarks: Bool {
    get {return _allowWatchBookmarks ?? false}
    set {_allowWatchBookmarks = newValue}
  }
  /// Returns true if `allowWatchBookmarks` has been explicitly set.
  var hasAllowWatchBookmarks: Bool {return self._allowWatchBookmarks != nil}
  /// Clears the value of `allowWatchBookmarks`. Subsequent reads from it will return its default value.
  mutating func clearAllowWatchBookmarks() {self._allowWatchBookmarks = nil}

  /// When specified with a watch call, shows changes that occur after that particular version of a resource.
  /// Defaults to changes from the beginning of history.
  /// When specified for list:
  /// - if unset, then the result is returned from remote storage based on quorum-read flag;
  /// - if it's 0, then we simply return what we currently have in cache, no guarantee;
  /// - if set to non zero, then the result is at least as fresh as given rv.
  /// +optional
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  /// Timeout for the list/watch call.
  /// This limits the duration of the call, regardless of any activity or inactivity.
  /// +optional
  var timeoutSeconds: Int64 {
    get {return _timeoutSeconds ?? 0}
    set {_timeoutSeconds = newValue}
  }
  /// Returns true if `timeoutSeconds` has been explicitly set.
  var hasTimeoutSeconds: Bool {return self._timeoutSeconds != nil}
  /// Clears the value of `timeoutSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutSeconds() {self._timeoutSeconds = nil}

  /// limit is a maximum number of responses to return for a list call. If more items exist, the
  /// server will set the `continue` field on the list metadata to a value that can be used with the
  /// same initial query to retrieve the next set of results. Setting a limit may return fewer than
  /// the requested amount of items (up to zero items) in the event all requested objects are
  /// filtered out and clients should only use the presence of the continue field to determine whether
  /// more results are available. Servers may choose not to support the limit argument and will return
  /// all of the available results. If limit is specified and the continue field is empty, clients may
  /// assume that no more results are available. This field is not supported if watch is true.
  ///
  /// The server guarantees that the objects returned when using continue will be identical to issuing
  /// a single list call without a limit - that is, no objects created, modified, or deleted after the
  /// first request is issued will be included in any subsequent continued requests. This is sometimes
  /// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
  /// smaller chunks of a very large result can ensure they see all possible objects. If objects are
  /// updated during a chunked list the version of the object that was present at the time the first list
  /// result was calculated is returned.
  var limit: Int64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  /// The continue option should be set when retrieving more results from the server. Since this value is
  /// server defined, clients may only use the continue value from a previous query result with identical
  /// query parameters (except for the value of continue) and the server may reject a continue value it
  /// does not recognize. If the specified continue value is no longer valid whether due to expiration
  /// (generally five to fifteen minutes) or a configuration change on the server, the server will
  /// respond with a 410 ResourceExpired error together with a continue token. If the client needs a
  /// consistent list, it must restart their list without the continue field. Otherwise, the client may
  /// send another list request with the token received with the 410 error, the server will respond with
  /// a list starting from the next key, but from the latest snapshot, which is inconsistent from the
  /// previous list results - objects that are created, modified, or deleted after the first list request
  /// will be included in the response, as long as their keys are after the "next key".
  ///
  /// This field is not supported when watch is true. Clients may start a watch from the last
  /// resourceVersion value returned by the server and not miss any modifications.
  var `continue`: String {
    get {return _continue ?? String()}
    set {_continue = newValue}
  }
  /// Returns true if ``continue`` has been explicitly set.
  var hasContinue: Bool {return self._continue != nil}
  /// Clears the value of ``continue``. Subsequent reads from it will return its default value.
  mutating func clearContinue() {self._continue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _labelSelector: String? = nil
  fileprivate var _fieldSelector: String? = nil
  fileprivate var _watch: Bool? = nil
  fileprivate var _allowWatchBookmarks: Bool? = nil
  fileprivate var _resourceVersion: String? = nil
  fileprivate var _timeoutSeconds: Int64? = nil
  fileprivate var _limit: Int64? = nil
  fileprivate var _continue: String? = nil
}

/// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
/// that the fieldset applies to.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Manager is an identifier of the workflow managing these fields.
  var manager: String {
    get {return _storage._manager ?? String()}
    set {_uniqueStorage()._manager = newValue}
  }
  /// Returns true if `manager` has been explicitly set.
  var hasManager: Bool {return _storage._manager != nil}
  /// Clears the value of `manager`. Subsequent reads from it will return its default value.
  mutating func clearManager() {_uniqueStorage()._manager = nil}

  /// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
  /// The only valid values for this field are 'Apply' and 'Update'.
  var operation: String {
    get {return _storage._operation ?? String()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  /// APIVersion defines the version of this resource that this field set
  /// applies to. The format is "group/version" just like the top-level
  /// APIVersion field. It is necessary to track the version of a field
  /// set because it cannot be automatically converted.
  var apiVersion: String {
    get {return _storage._apiVersion ?? String()}
    set {_uniqueStorage()._apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return _storage._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {_uniqueStorage()._apiVersion = nil}

  /// Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply'
  /// +optional
  var time: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._time ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {_uniqueStorage()._time = nil}

  /// FieldsType is the discriminator for the different fields format and version.
  /// There is currently only one possible value: "FieldsV1"
  var fieldsType: String {
    get {return _storage._fieldsType ?? String()}
    set {_uniqueStorage()._fieldsType = newValue}
  }
  /// Returns true if `fieldsType` has been explicitly set.
  var hasFieldsType: Bool {return _storage._fieldsType != nil}
  /// Clears the value of `fieldsType`. Subsequent reads from it will return its default value.
  mutating func clearFieldsType() {_uniqueStorage()._fieldsType = nil}

  /// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
  /// +optional
  var fieldsV1: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1 {
    get {return _storage._fieldsV1 ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1()}
    set {_uniqueStorage()._fieldsV1 = newValue}
  }
  /// Returns true if `fieldsV1` has been explicitly set.
  var hasFieldsV1: Bool {return _storage._fieldsV1 != nil}
  /// Clears the value of `fieldsV1`. Subsequent reads from it will return its default value.
  mutating func clearFieldsV1() {_uniqueStorage()._fieldsV1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MicroTime is version of Time with microsecond level precision.
///
/// +protobuf.options.marshal=false
/// +protobuf.as=Timestamp
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents seconds of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  /// 9999-12-31T23:59:59Z inclusive.
  var seconds: Int64 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  /// Non-negative fractions of a second at nanosecond resolution. Negative
  /// second values with fractions must still have non-negative nanos values
  /// that count forward in time. Must be from 0 to 999,999,999
  /// inclusive. This field may be limited in precision depending on context.
  var nanos: Int32 {
    get {return _nanos ?? 0}
    set {_nanos = newValue}
  }
  /// Returns true if `nanos` has been explicitly set.
  var hasNanos: Bool {return self._nanos != nil}
  /// Clears the value of `nanos`. Subsequent reads from it will return its default value.
  mutating func clearNanos() {self._nanos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: Int64? = nil
  fileprivate var _nanos: Int32? = nil
}

/// ObjectMeta is metadata that all persisted resources must have, which includes all objects
/// users must create.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name must be unique within a namespace. Is required when creating resources, although
  /// some resources may allow a client to request the generation of an appropriate name
  /// automatically. Name is primarily intended for creation idempotence and configuration
  /// definition.
  /// Cannot be updated.
  /// More info: http://kubernetes.io/docs/user-guide/identifiers#names
  /// +optional
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// GenerateName is an optional prefix, used by the server, to generate a unique
  /// name ONLY IF the Name field has not been provided.
  /// If this field is used, the name returned to the client will be different
  /// than the name passed. This value will also be combined with a unique suffix.
  /// The provided value has the same validation rules as the Name field,
  /// and may be truncated by the length of the suffix required to make the value
  /// unique on the server.
  ///
  /// If this field is specified and the generated name exists, the server will
  /// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
  /// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
  /// should retry (optionally after the time indicated in the Retry-After header).
  ///
  /// Applied only if Name is not specified.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
  /// +optional
  var generateName: String {
    get {return _storage._generateName ?? String()}
    set {_uniqueStorage()._generateName = newValue}
  }
  /// Returns true if `generateName` has been explicitly set.
  var hasGenerateName: Bool {return _storage._generateName != nil}
  /// Clears the value of `generateName`. Subsequent reads from it will return its default value.
  mutating func clearGenerateName() {_uniqueStorage()._generateName = nil}

  /// Namespace defines the space within each name must be unique. An empty namespace is
  /// equivalent to the "default" namespace, but "default" is the canonical representation.
  /// Not all objects are required to be scoped to a namespace - the value of this field for
  /// those objects will be empty.
  ///
  /// Must be a DNS_LABEL.
  /// Cannot be updated.
  /// More info: http://kubernetes.io/docs/user-guide/namespaces
  /// +optional
  var namespace: String {
    get {return _storage._namespace ?? String()}
    set {_uniqueStorage()._namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return _storage._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {_uniqueStorage()._namespace = nil}

  /// SelfLink is a URL representing this object.
  /// Populated by the system.
  /// Read-only.
  ///
  /// DEPRECATED
  /// Kubernetes will stop propagating this field in 1.20 release and the field is planned
  /// to be removed in 1.21 release.
  /// +optional
  var selfLink: String {
    get {return _storage._selfLink ?? String()}
    set {_uniqueStorage()._selfLink = newValue}
  }
  /// Returns true if `selfLink` has been explicitly set.
  var hasSelfLink: Bool {return _storage._selfLink != nil}
  /// Clears the value of `selfLink`. Subsequent reads from it will return its default value.
  mutating func clearSelfLink() {_uniqueStorage()._selfLink = nil}

  /// UID is the unique in time and space value for this object. It is typically generated by
  /// the server on successful creation of a resource and is not allowed to change on PUT
  /// operations.
  ///
  /// Populated by the system.
  /// Read-only.
  /// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
  /// +optional
  var uid: String {
    get {return _storage._uid ?? String()}
    set {_uniqueStorage()._uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return _storage._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {_uniqueStorage()._uid = nil}

  /// An opaque value that represents the internal version of this object that can
  /// be used by clients to determine when objects have changed. May be used for optimistic
  /// concurrency, change detection, and the watch operation on a resource or set of resources.
  /// Clients must treat these values as opaque and passed unmodified back to the server.
  /// They may only be valid for a particular resource or set of resources.
  ///
  /// Populated by the system.
  /// Read-only.
  /// Value must be treated as opaque by clients and .
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  /// +optional
  var resourceVersion: String {
    get {return _storage._resourceVersion ?? String()}
    set {_uniqueStorage()._resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return _storage._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {_uniqueStorage()._resourceVersion = nil}

  /// A sequence number representing a specific generation of the desired state.
  /// Populated by the system. Read-only.
  /// +optional
  var generation: Int64 {
    get {return _storage._generation ?? 0}
    set {_uniqueStorage()._generation = newValue}
  }
  /// Returns true if `generation` has been explicitly set.
  var hasGeneration: Bool {return _storage._generation != nil}
  /// Clears the value of `generation`. Subsequent reads from it will return its default value.
  mutating func clearGeneration() {_uniqueStorage()._generation = nil}

  /// CreationTimestamp is a timestamp representing the server time when this object was
  /// created. It is not guaranteed to be set in happens-before order across separate operations.
  /// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
  ///
  /// Populated by the system.
  /// Read-only.
  /// Null for lists.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var creationTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._creationTimestamp ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._creationTimestamp = newValue}
  }
  /// Returns true if `creationTimestamp` has been explicitly set.
  var hasCreationTimestamp: Bool {return _storage._creationTimestamp != nil}
  /// Clears the value of `creationTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearCreationTimestamp() {_uniqueStorage()._creationTimestamp = nil}

  /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
  /// field is set by the server when a graceful deletion is requested by the user, and is not
  /// directly settable by a client. The resource is expected to be deleted (no longer visible
  /// from resource lists, and not reachable by name) after the time in this field, once the
  /// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
  /// Once the deletionTimestamp is set, this value may not be unset or be set further into the
  /// future, although it may be shortened or the resource may be deleted prior to this time.
  /// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
  /// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
  /// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
  /// remove the pod from the API. In the presence of network partitions, this object may still
  /// exist after this timestamp, until an administrator or automated process can determine the
  /// resource is fully terminated.
  /// If not set, graceful deletion of the object has not been requested.
  ///
  /// Populated by the system when a graceful deletion is requested.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var deletionTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._deletionTimestamp ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._deletionTimestamp = newValue}
  }
  /// Returns true if `deletionTimestamp` has been explicitly set.
  var hasDeletionTimestamp: Bool {return _storage._deletionTimestamp != nil}
  /// Clears the value of `deletionTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearDeletionTimestamp() {_uniqueStorage()._deletionTimestamp = nil}

  /// Number of seconds allowed for this object to gracefully terminate before
  /// it will be removed from the system. Only set when deletionTimestamp is also set.
  /// May only be shortened.
  /// Read-only.
  /// +optional
  var deletionGracePeriodSeconds: Int64 {
    get {return _storage._deletionGracePeriodSeconds ?? 0}
    set {_uniqueStorage()._deletionGracePeriodSeconds = newValue}
  }
  /// Returns true if `deletionGracePeriodSeconds` has been explicitly set.
  var hasDeletionGracePeriodSeconds: Bool {return _storage._deletionGracePeriodSeconds != nil}
  /// Clears the value of `deletionGracePeriodSeconds`. Subsequent reads from it will return its default value.
  mutating func clearDeletionGracePeriodSeconds() {_uniqueStorage()._deletionGracePeriodSeconds = nil}

  /// Map of string keys and values that can be used to organize and categorize
  /// (scope and select) objects. May match selectors of replication controllers
  /// and services.
  /// More info: http://kubernetes.io/docs/user-guide/labels
  /// +optional
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Annotations is an unstructured key value map stored with a resource that may be
  /// set by external tools to store and retrieve arbitrary metadata. They are not
  /// queryable and should be preserved when modifying objects.
  /// More info: http://kubernetes.io/docs/user-guide/annotations
  /// +optional
  var annotations: Dictionary<String,String> {
    get {return _storage._annotations}
    set {_uniqueStorage()._annotations = newValue}
  }

  /// List of objects depended by this object. If ALL objects in the list have
  /// been deleted, this object will be garbage collected. If this object is managed by a controller,
  /// then an entry in this list will point to this controller, with the controller field set to true.
  /// There cannot be more than one managing controller.
  /// +optional
  /// +patchMergeKey=uid
  /// +patchStrategy=merge
  var ownerReferences: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference] {
    get {return _storage._ownerReferences}
    set {_uniqueStorage()._ownerReferences = newValue}
  }

  /// Must be empty before the object is deleted from the registry. Each entry
  /// is an identifier for the responsible component that will remove the entry
  /// from the list. If the deletionTimestamp of the object is non-nil, entries
  /// in this list can only be removed.
  /// Finalizers may be processed and removed in any order.  Order is NOT enforced
  /// because it introduces significant risk of stuck finalizers.
  /// finalizers is a shared field, any actor with permission can reorder it.
  /// If the finalizer list is processed in order, then this can lead to a situation
  /// in which the component responsible for the first finalizer in the list is
  /// waiting for a signal (field value, external system, or other) produced by a
  /// component responsible for a finalizer later in the list, resulting in a deadlock.
  /// Without enforced ordering finalizers are free to order amongst themselves and
  /// are not vulnerable to ordering changes in the list.
  /// +optional
  /// +patchStrategy=merge
  var finalizers: [String] {
    get {return _storage._finalizers}
    set {_uniqueStorage()._finalizers = newValue}
  }

  /// The name of the cluster which the object belongs to.
  /// This is used to distinguish resources with same name and namespace in different clusters.
  /// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
  /// +optional
  var clusterName: String {
    get {return _storage._clusterName ?? String()}
    set {_uniqueStorage()._clusterName = newValue}
  }
  /// Returns true if `clusterName` has been explicitly set.
  var hasClusterName: Bool {return _storage._clusterName != nil}
  /// Clears the value of `clusterName`. Subsequent reads from it will return its default value.
  mutating func clearClusterName() {_uniqueStorage()._clusterName = nil}

  /// ManagedFields maps workflow-id and version to the set of fields
  /// that are managed by that workflow. This is mostly for internal
  /// housekeeping, and users typically shouldn't need to set or
  /// understand this field. A workflow can be the user's name, a
  /// controller's name, or the name of a specific apply path like
  /// "ci-cd". The set of fields is always in the version that the
  /// workflow used when modifying the object.
  ///
  /// +optional
  var managedFields: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry] {
    get {return _storage._managedFields}
    set {_uniqueStorage()._managedFields = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OwnerReference contains enough information to let you identify an owning
/// object. An owning object must be in the same namespace as the dependent, or
/// be cluster-scoped, so there is no namespace field.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// API version of the referent.
  var apiVersion: String {
    get {return _apiVersion ?? String()}
    set {_apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return self._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {self._apiVersion = nil}

  /// Kind of the referent.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// Name of the referent.
  /// More info: http://kubernetes.io/docs/user-guide/identifiers#names
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// UID of the referent.
  /// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// If true, this reference points to the managing controller.
  /// +optional
  var controller: Bool {
    get {return _controller ?? false}
    set {_controller = newValue}
  }
  /// Returns true if `controller` has been explicitly set.
  var hasController: Bool {return self._controller != nil}
  /// Clears the value of `controller`. Subsequent reads from it will return its default value.
  mutating func clearController() {self._controller = nil}

  /// If true, AND if the owner has the "foregroundDeletion" finalizer, then
  /// the owner cannot be deleted from the key-value store until this
  /// reference is removed.
  /// Defaults to false.
  /// To set this field, a user needs "delete" permission of the owner,
  /// otherwise 422 (Unprocessable Entity) will be returned.
  /// +optional
  var blockOwnerDeletion: Bool {
    get {return _blockOwnerDeletion ?? false}
    set {_blockOwnerDeletion = newValue}
  }
  /// Returns true if `blockOwnerDeletion` has been explicitly set.
  var hasBlockOwnerDeletion: Bool {return self._blockOwnerDeletion != nil}
  /// Clears the value of `blockOwnerDeletion`. Subsequent reads from it will return its default value.
  mutating func clearBlockOwnerDeletion() {self._blockOwnerDeletion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _apiVersion: String? = nil
  fileprivate var _kind: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _uid: String? = nil
  fileprivate var _controller: Bool? = nil
  fileprivate var _blockOwnerDeletion: Bool? = nil
}

/// PartialObjectMetadata is a generic representation of any object with ObjectMeta. It allows clients
/// to get access to a particular ObjectMeta schema without knowing the details of the version.
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PartialObjectMetadataList contains a list of objects containing only their metadata
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadataList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// items contains each of the included items.
  var items: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Patch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PatchOptions may be provided when patching an API object.
/// PatchOptions is meant to be a superset of UpdateOptions.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PatchOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When present, indicates that modifications should not be
  /// persisted. An invalid or unrecognized dryRun directive will
  /// result in an error response and no further processing of the
  /// request. Valid values are:
  /// - All: all dry run stages will be processed
  /// +optional
  var dryRun: [String] = []

  /// Force is going to "force" Apply requests. It means user will
  /// re-acquire conflicting fields owned by other people. Force
  /// flag must be unset for non-apply patch requests.
  /// +optional
  var force: Bool {
    get {return _force ?? false}
    set {_force = newValue}
  }
  /// Returns true if `force` has been explicitly set.
  var hasForce: Bool {return self._force != nil}
  /// Clears the value of `force`. Subsequent reads from it will return its default value.
  mutating func clearForce() {self._force = nil}

  /// fieldManager is a name associated with the actor or entity
  /// that is making these changes. The value must be less than or
  /// 128 characters long, and only contain printable characters,
  /// as defined by https://golang.org/pkg/unicode/#IsPrint. This
  /// field is required for apply requests
  /// (application/apply-patch) but optional for non-apply patch
  /// types (JsonPatch, MergePatch, StrategicMergePatch).
  /// +optional
  var fieldManager: String {
    get {return _fieldManager ?? String()}
    set {_fieldManager = newValue}
  }
  /// Returns true if `fieldManager` has been explicitly set.
  var hasFieldManager: Bool {return self._fieldManager != nil}
  /// Clears the value of `fieldManager`. Subsequent reads from it will return its default value.
  mutating func clearFieldManager() {self._fieldManager = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _force: Bool? = nil
  fileprivate var _fieldManager: String? = nil
}

/// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the target UID.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// Specifies the target ResourceVersion
  /// +optional
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uid: String? = nil
  fileprivate var _resourceVersion: String? = nil
}

/// RootPaths lists the paths available at root.
/// For example: "/healthz", "/apis".
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_RootPaths {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// paths are the paths available at root.
  var paths: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The CIDR with which clients can match their IP to figure out the server address that they should use.
  var clientCidr: String {
    get {return _clientCidr ?? String()}
    set {_clientCidr = newValue}
  }
  /// Returns true if `clientCidr` has been explicitly set.
  var hasClientCidr: Bool {return self._clientCidr != nil}
  /// Clears the value of `clientCidr`. Subsequent reads from it will return its default value.
  mutating func clearClientCidr() {self._clientCidr = nil}

  /// Address of this server, suitable for a client that matches the above CIDR.
  /// This can be a hostname, hostname:port, IP or IP:port.
  var serverAddress: String {
    get {return _serverAddress ?? String()}
    set {_serverAddress = newValue}
  }
  /// Returns true if `serverAddress` has been explicitly set.
  var hasServerAddress: Bool {return self._serverAddress != nil}
  /// Clears the value of `serverAddress`. Subsequent reads from it will return its default value.
  mutating func clearServerAddress() {self._serverAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientCidr: String? = nil
  fileprivate var _serverAddress: String? = nil
}

/// Status is a return value for calls that don't return other objects.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Status of the operation.
  /// One of: "Success" or "Failure".
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// A human-readable description of the status of this operation.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// A machine-readable description of why this operation is in the
  /// "Failure" status. If this value is empty there
  /// is no information available. A Reason clarifies an HTTP status
  /// code but does not override it.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Extended data associated with the reason.  Each reason may define its
  /// own extended details. This field is optional and the data returned
  /// is not guaranteed to conform to any schema except that defined by
  /// the reason type.
  /// +optional
  var details: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails {
    get {return _storage._details ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails()}
    set {_uniqueStorage()._details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return _storage._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {_uniqueStorage()._details = nil}

  /// Suggested HTTP return code for this status, 0 if not set.
  /// +optional
  var code: Int32 {
    get {return _storage._code ?? 0}
    set {_uniqueStorage()._code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return _storage._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {_uniqueStorage()._code = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StatusCause provides more information about an api.Status failure, including
/// cases when multiple errors are encountered.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusCause {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A machine-readable description of the cause of the error. If this value is
  /// empty there is no information available.
  /// +optional
  var reason: String {
    get {return _reason ?? String()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  /// A human-readable description of the cause of the error.  This field may be
  /// presented as-is to a reader.
  /// +optional
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// The field of the resource that has caused this error, as named by its JSON
  /// serialization. May include dot and postfix notation for nested attributes.
  /// Arrays are zero-indexed.  Fields may appear more than once in an array of
  /// causes due to fields having multiple errors.
  /// Optional.
  ///
  /// Examples:
  ///   "name" - the field "name" on the current resource
  ///   "items[0].name" - the field "name" on the first array entry in "items"
  /// +optional
  var field: String {
    get {return _field ?? String()}
    set {_field = newValue}
  }
  /// Returns true if `field` has been explicitly set.
  var hasField: Bool {return self._field != nil}
  /// Clears the value of `field`. Subsequent reads from it will return its default value.
  mutating func clearField() {self._field = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reason: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _field: String? = nil
}

/// StatusDetails is a set of additional properties that MAY be set by the
/// server to provide additional information about a response. The Reason
/// field of a Status object defines what attributes will be set. Clients
/// must ignore fields that do not match the defined type of each attribute,
/// and should assume that any attribute may be empty, invalid, or under
/// defined.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name attribute of the resource associated with the status StatusReason
  /// (when there is a single name which can be described).
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The group attribute of the resource associated with the status StatusReason.
  /// +optional
  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  /// The kind attribute of the resource associated with the status StatusReason.
  /// On some operations may differ from the requested resource Kind.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// UID of the resource.
  /// (when there is a single resource which can be described).
  /// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// The Causes array includes more details associated with the StatusReason
  /// failure. Not all StatusReasons may provide detailed causes.
  /// +optional
  var causes: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusCause] = []

  /// If specified, the time in seconds before the operation should be retried. Some errors may indicate
  /// the client must take an alternate action - for those errors this field may indicate how long to wait
  /// before taking the alternate action.
  /// +optional
  var retryAfterSeconds: Int32 {
    get {return _retryAfterSeconds ?? 0}
    set {_retryAfterSeconds = newValue}
  }
  /// Returns true if `retryAfterSeconds` has been explicitly set.
  var hasRetryAfterSeconds: Bool {return self._retryAfterSeconds != nil}
  /// Clears the value of `retryAfterSeconds`. Subsequent reads from it will return its default value.
  mutating func clearRetryAfterSeconds() {self._retryAfterSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _group: String? = nil
  fileprivate var _kind: String? = nil
  fileprivate var _uid: String? = nil
  fileprivate var _retryAfterSeconds: Int32? = nil
}

/// TableOptions are used when a Table is requested by the caller.
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TableOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// includeObject decides whether to include each object along with its columnar information.
  /// Specifying "None" will return no object, specifying "Object" will return the full object contents, and
  /// specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
  /// in version v1beta1 of the meta.k8s.io API group.
  var includeObject: String {
    get {return _includeObject ?? String()}
    set {_includeObject = newValue}
  }
  /// Returns true if `includeObject` has been explicitly set.
  var hasIncludeObject: Bool {return self._includeObject != nil}
  /// Clears the value of `includeObject`. Subsequent reads from it will return its default value.
  mutating func clearIncludeObject() {self._includeObject = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _includeObject: String? = nil
}

/// Time is a wrapper around time.Time which supports correct
/// marshaling to YAML and JSON.  Wrappers are provided for many
/// of the factory methods that the time package offers.
///
/// +protobuf.options.marshal=false
/// +protobuf.as=Timestamp
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents seconds of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  /// 9999-12-31T23:59:59Z inclusive.
  var seconds: Int64 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  /// Non-negative fractions of a second at nanosecond resolution. Negative
  /// second values with fractions must still have non-negative nanos values
  /// that count forward in time. Must be from 0 to 999,999,999
  /// inclusive. This field may be limited in precision depending on context.
  var nanos: Int32 {
    get {return _nanos ?? 0}
    set {_nanos = newValue}
  }
  /// Returns true if `nanos` has been explicitly set.
  var hasNanos: Bool {return self._nanos != nil}
  /// Clears the value of `nanos`. Subsequent reads from it will return its default value.
  mutating func clearNanos() {self._nanos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: Int64? = nil
  fileprivate var _nanos: Int32? = nil
}

/// Timestamp is a struct that is equivalent to Time, but intended for
/// protobuf marshalling/unmarshalling. It is generated into a serialization
/// that matches Time. Do not use in Go structs.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Timestamp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents seconds of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  /// 9999-12-31T23:59:59Z inclusive.
  var seconds: Int64 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  /// Non-negative fractions of a second at nanosecond resolution. Negative
  /// second values with fractions must still have non-negative nanos values
  /// that count forward in time. Must be from 0 to 999,999,999
  /// inclusive. This field may be limited in precision depending on context.
  var nanos: Int32 {
    get {return _nanos ?? 0}
    set {_nanos = newValue}
  }
  /// Returns true if `nanos` has been explicitly set.
  var hasNanos: Bool {return self._nanos != nil}
  /// Clears the value of `nanos`. Subsequent reads from it will return its default value.
  mutating func clearNanos() {self._nanos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: Int64? = nil
  fileprivate var _nanos: Int32? = nil
}

/// TypeMeta describes an individual object in an API response or request
/// with strings representing the type of the object and its API schema version.
/// Structures that are versioned or persisted should inline TypeMeta.
///
/// +k8s:deepcopy-gen=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TypeMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a string value representing the REST resource this object represents.
  /// Servers may infer this from the endpoint the client submits requests to.
  /// Cannot be updated.
  /// In CamelCase.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// APIVersion defines the versioned schema of this representation of an object.
  /// Servers should convert recognized schemas to the latest internal value, and
  /// may reject unrecognized values.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
  /// +optional
  var apiVersion: String {
    get {return _apiVersion ?? String()}
    set {_apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return self._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {self._apiVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _kind: String? = nil
  fileprivate var _apiVersion: String? = nil
}

/// UpdateOptions may be provided when updating an API object.
/// All fields in UpdateOptions should also be present in PatchOptions.
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_UpdateOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When present, indicates that modifications should not be
  /// persisted. An invalid or unrecognized dryRun directive will
  /// result in an error response and no further processing of the
  /// request. Valid values are:
  /// - All: all dry run stages will be processed
  /// +optional
  var dryRun: [String] = []

  /// fieldManager is a name associated with the actor or entity
  /// that is making these changes. The value must be less than or
  /// 128 characters long, and only contain printable characters,
  /// as defined by https://golang.org/pkg/unicode/#IsPrint.
  /// +optional
  var fieldManager: String {
    get {return _fieldManager ?? String()}
    set {_fieldManager = newValue}
  }
  /// Returns true if `fieldManager` has been explicitly set.
  var hasFieldManager: Bool {return self._fieldManager != nil}
  /// Clears the value of `fieldManager`. Subsequent reads from it will return its default value.
  mutating func clearFieldManager() {self._fieldManager = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fieldManager: String? = nil
}

/// Verbs masks the value so protobuf can generate
///
/// +protobuf.nullable=true
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event represents a single event to a watched resource.
///
/// +protobuf=true
/// +k8s:deepcopy-gen=true
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Object is:
  ///  * If Type is Added or Modified: the new state of the object.
  ///  * If Type is Deleted: the state of the object immediately before deletion.
  ///  * If Type is Error: *Status is recommended; other types may make sense
  ///    depending on context.
  var object: K8s_Io_Apimachinery_Pkg_Runtime_RawExtension {
    get {return _storage._object ?? K8s_Io_Apimachinery_Pkg_Runtime_RawExtension()}
    set {_uniqueStorage()._object = newValue}
  }
  /// Returns true if `object` has been explicitly set.
  var hasObject: Bool {return _storage._object != nil}
  /// Clears the value of `object`. Subsequent reads from it will return its default value.
  mutating func clearObject() {_uniqueStorage()._object = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.apimachinery.pkg.apis.meta.v1"

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".APIGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "versions"),
    3: .same(proto: "preferredVersion"),
    4: .same(proto: "serverAddressByClientCIDRs"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _versions: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery] = []
    var _preferredVersion: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery? = nil
    var _serverAddressByClientCidrs: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _versions = source._versions
      _preferredVersion = source._preferredVersion
      _serverAddressByClientCidrs = source._serverAddressByClientCidrs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._versions)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._preferredVersion)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._serverAddressByClientCidrs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._versions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versions, fieldNumber: 2)
      }
      if let v = _storage._preferredVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._serverAddressByClientCidrs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._serverAddressByClientCidrs, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroup, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._versions != rhs_storage._versions {return false}
        if _storage._preferredVersion != rhs_storage._preferredVersion {return false}
        if _storage._serverAddressByClientCidrs != rhs_storage._serverAddressByClientCidrs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroupList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".APIGroupList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroupList, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIGroupList) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".APIResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    6: .same(proto: "singularName"),
    2: .same(proto: "namespaced"),
    8: .same(proto: "group"),
    9: .same(proto: "version"),
    3: .same(proto: "kind"),
    4: .same(proto: "verbs"),
    5: .same(proto: "shortNames"),
    7: .same(proto: "categories"),
    10: .same(proto: "storageVersionHash"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _singularName: String? = nil
    var _namespaced: Bool? = nil
    var _group: String? = nil
    var _version: String? = nil
    var _kind: String? = nil
    var _verbs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs? = nil
    var _shortNames: [String] = []
    var _categories: [String] = []
    var _storageVersionHash: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _singularName = source._singularName
      _namespaced = source._namespaced
      _group = source._group
      _version = source._version
      _kind = source._kind
      _verbs = source._verbs
      _shortNames = source._shortNames
      _categories = source._categories
      _storageVersionHash = source._storageVersionHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._namespaced)
        case 3: try decoder.decodeSingularStringField(value: &_storage._kind)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._verbs)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._shortNames)
        case 6: try decoder.decodeSingularStringField(value: &_storage._singularName)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._categories)
        case 8: try decoder.decodeSingularStringField(value: &_storage._group)
        case 9: try decoder.decodeSingularStringField(value: &_storage._version)
        case 10: try decoder.decodeSingularStringField(value: &_storage._storageVersionHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._namespaced {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._kind {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._verbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._shortNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._shortNames, fieldNumber: 5)
      }
      if let v = _storage._singularName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if !_storage._categories.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._categories, fieldNumber: 7)
      }
      if let v = _storage._group {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._version {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._storageVersionHash {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResource, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._singularName != rhs_storage._singularName {return false}
        if _storage._namespaced != rhs_storage._namespaced {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._verbs != rhs_storage._verbs {return false}
        if _storage._shortNames != rhs_storage._shortNames {return false}
        if _storage._categories != rhs_storage._categories {return false}
        if _storage._storageVersionHash != rhs_storage._storageVersionHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResourceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".APIResourceList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupVersion"),
    2: .same(proto: "resources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._groupVersion)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.resources)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResourceList, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIResourceList) -> Bool {
    if lhs._groupVersion != rhs._groupVersion {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIVersions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".APIVersions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versions"),
    2: .same(proto: "serverAddressByClientCIDRs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.versions)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.serverAddressByClientCidrs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.versions, fieldNumber: 1)
    }
    if !self.serverAddressByClientCidrs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverAddressByClientCidrs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIVersions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_APIVersions) -> Bool {
    if lhs.versions != rhs.versions {return false}
    if lhs.serverAddressByClientCidrs != rhs.serverAddressByClientCidrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_CreateOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dryRun"),
    3: .same(proto: "fieldManager"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.dryRun)
      case 3: try decoder.decodeSingularStringField(value: &self._fieldManager)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dryRun.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRun, fieldNumber: 1)
    }
    if let v = self._fieldManager {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_CreateOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_CreateOptions) -> Bool {
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs._fieldManager != rhs._fieldManager {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gracePeriodSeconds"),
    2: .same(proto: "preconditions"),
    3: .same(proto: "orphanDependents"),
    4: .same(proto: "propagationPolicy"),
    5: .same(proto: "dryRun"),
  ]

  fileprivate class _StorageClass {
    var _gracePeriodSeconds: Int64? = nil
    var _preconditions: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions? = nil
    var _orphanDependents: Bool? = nil
    var _propagationPolicy: String? = nil
    var _dryRun: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gracePeriodSeconds = source._gracePeriodSeconds
      _preconditions = source._preconditions
      _orphanDependents = source._orphanDependents
      _propagationPolicy = source._propagationPolicy
      _dryRun = source._dryRun
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._gracePeriodSeconds)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._preconditions)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._orphanDependents)
        case 4: try decoder.decodeSingularStringField(value: &_storage._propagationPolicy)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._dryRun)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gracePeriodSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._preconditions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._orphanDependents {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._propagationPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._dryRun.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._dryRun, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gracePeriodSeconds != rhs_storage._gracePeriodSeconds {return false}
        if _storage._preconditions != rhs_storage._preconditions {return false}
        if _storage._orphanDependents != rhs_storage._orphanDependents {return false}
        if _storage._propagationPolicy != rhs_storage._propagationPolicy {return false}
        if _storage._dryRun != rhs_storage._dryRun {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Duration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._duration)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._duration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Duration, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Duration) -> Bool {
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ExportOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExportOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "export"),
    2: .same(proto: "exact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._export)
      case 2: try decoder.decodeSingularBoolField(value: &self._exact)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._export {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._exact {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ExportOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ExportOptions) -> Bool {
    if lhs._export != rhs._export {return false}
    if lhs._exact != rhs._exact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Raw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._raw)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._raw {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1) -> Bool {
    if lhs._raw != rhs._raw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GetOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GetOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GetOptions) -> Bool {
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupKind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupKind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._group)
      case 2: try decoder.decodeSingularStringField(value: &self._kind)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupKind, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupKind) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._group)
      case 2: try decoder.decodeSingularStringField(value: &self._resource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._resource {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupResource, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupResource) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._group)
      case 2: try decoder.decodeSingularStringField(value: &self._version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersion, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersion) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupVersionForDiscovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupVersion"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._groupVersion)
      case 2: try decoder.decodeSingularStringField(value: &self._version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionForDiscovery) -> Bool {
    if lhs._groupVersion != rhs._groupVersion {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionKind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupVersionKind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "version"),
    3: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._group)
      case 2: try decoder.decodeSingularStringField(value: &self._version)
      case 3: try decoder.decodeSingularStringField(value: &self._kind)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionKind, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionKind) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._version != rhs._version {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupVersionResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "version"),
    3: .same(proto: "resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._group)
      case 2: try decoder.decodeSingularStringField(value: &self._version)
      case 3: try decoder.decodeSingularStringField(value: &self._resource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._resource {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionResource, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_GroupVersionResource) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._version != rhs._version {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matchLabels"),
    2: .same(proto: "matchExpressions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.matchLabels)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.matchExpressions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.matchLabels, fieldNumber: 1)
    }
    if !self.matchExpressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchExpressions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector) -> Bool {
    if lhs.matchLabels != rhs.matchLabels {return false}
    if lhs.matchExpressions != rhs.matchExpressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelSelectorRequirement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "operator"),
    3: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeSingularStringField(value: &self._operator)
      case 3: try decoder.decodeRepeatedStringField(value: &self.values)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._operator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelectorRequirement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Apimachinery_Pkg_Runtime_RawExtension] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_List, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_List) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selfLink"),
    2: .same(proto: "resourceVersion"),
    3: .same(proto: "continue"),
    4: .same(proto: "remainingItemCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._selfLink)
      case 2: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      case 3: try decoder.decodeSingularStringField(value: &self._continue)
      case 4: try decoder.decodeSingularInt64Field(value: &self._remainingItemCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selfLink {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._continue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._remainingItemCount {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta) -> Bool {
    if lhs._selfLink != rhs._selfLink {return false}
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs._continue != rhs._continue {return false}
    if lhs._remainingItemCount != rhs._remainingItemCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labelSelector"),
    2: .same(proto: "fieldSelector"),
    3: .same(proto: "watch"),
    9: .same(proto: "allowWatchBookmarks"),
    4: .same(proto: "resourceVersion"),
    5: .same(proto: "timeoutSeconds"),
    7: .same(proto: "limit"),
    8: .same(proto: "continue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._labelSelector)
      case 2: try decoder.decodeSingularStringField(value: &self._fieldSelector)
      case 3: try decoder.decodeSingularBoolField(value: &self._watch)
      case 4: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      case 5: try decoder.decodeSingularInt64Field(value: &self._timeoutSeconds)
      case 7: try decoder.decodeSingularInt64Field(value: &self._limit)
      case 8: try decoder.decodeSingularStringField(value: &self._continue)
      case 9: try decoder.decodeSingularBoolField(value: &self._allowWatchBookmarks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._labelSelector {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fieldSelector {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._watch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._timeoutSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._limit {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._continue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._allowWatchBookmarks {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListOptions) -> Bool {
    if lhs._labelSelector != rhs._labelSelector {return false}
    if lhs._fieldSelector != rhs._fieldSelector {return false}
    if lhs._watch != rhs._watch {return false}
    if lhs._allowWatchBookmarks != rhs._allowWatchBookmarks {return false}
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs._timeoutSeconds != rhs._timeoutSeconds {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._continue != rhs._continue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManagedFieldsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manager"),
    2: .same(proto: "operation"),
    3: .same(proto: "apiVersion"),
    4: .same(proto: "time"),
    6: .same(proto: "fieldsType"),
    7: .same(proto: "fieldsV1"),
  ]

  fileprivate class _StorageClass {
    var _manager: String? = nil
    var _operation: String? = nil
    var _apiVersion: String? = nil
    var _time: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _fieldsType: String? = nil
    var _fieldsV1: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_FieldsV1? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manager = source._manager
      _operation = source._operation
      _apiVersion = source._apiVersion
      _time = source._time
      _fieldsType = source._fieldsType
      _fieldsV1 = source._fieldsV1
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._manager)
        case 2: try decoder.decodeSingularStringField(value: &_storage._operation)
        case 3: try decoder.decodeSingularStringField(value: &_storage._apiVersion)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 6: try decoder.decodeSingularStringField(value: &_storage._fieldsType)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._fieldsV1)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manager {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._operation {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._apiVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._fieldsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._fieldsV1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manager != rhs_storage._manager {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._fieldsType != rhs_storage._fieldsType {return false}
        if _storage._fieldsV1 != rhs_storage._fieldsV1 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MicroTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
    2: .same(proto: "nanos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._seconds)
      case 2: try decoder.decodeSingularInt32Field(value: &self._nanos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._seconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nanos {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs._nanos != rhs._nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "generateName"),
    3: .same(proto: "namespace"),
    4: .same(proto: "selfLink"),
    5: .same(proto: "uid"),
    6: .same(proto: "resourceVersion"),
    7: .same(proto: "generation"),
    8: .same(proto: "creationTimestamp"),
    9: .same(proto: "deletionTimestamp"),
    10: .same(proto: "deletionGracePeriodSeconds"),
    11: .same(proto: "labels"),
    12: .same(proto: "annotations"),
    13: .same(proto: "ownerReferences"),
    14: .same(proto: "finalizers"),
    15: .same(proto: "clusterName"),
    17: .same(proto: "managedFields"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _generateName: String? = nil
    var _namespace: String? = nil
    var _selfLink: String? = nil
    var _uid: String? = nil
    var _resourceVersion: String? = nil
    var _generation: Int64? = nil
    var _creationTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _deletionTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _deletionGracePeriodSeconds: Int64? = nil
    var _labels: Dictionary<String,String> = [:]
    var _annotations: Dictionary<String,String> = [:]
    var _ownerReferences: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference] = []
    var _finalizers: [String] = []
    var _clusterName: String? = nil
    var _managedFields: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ManagedFieldsEntry] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _generateName = source._generateName
      _namespace = source._namespace
      _selfLink = source._selfLink
      _uid = source._uid
      _resourceVersion = source._resourceVersion
      _generation = source._generation
      _creationTimestamp = source._creationTimestamp
      _deletionTimestamp = source._deletionTimestamp
      _deletionGracePeriodSeconds = source._deletionGracePeriodSeconds
      _labels = source._labels
      _annotations = source._annotations
      _ownerReferences = source._ownerReferences
      _finalizers = source._finalizers
      _clusterName = source._clusterName
      _managedFields = source._managedFields
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._generateName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._namespace)
        case 4: try decoder.decodeSingularStringField(value: &_storage._selfLink)
        case 5: try decoder.decodeSingularStringField(value: &_storage._uid)
        case 6: try decoder.decodeSingularStringField(value: &_storage._resourceVersion)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._generation)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._creationTimestamp)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._deletionTimestamp)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._deletionGracePeriodSeconds)
        case 11: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels)
        case 12: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._annotations)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._ownerReferences)
        case 14: try decoder.decodeRepeatedStringField(value: &_storage._finalizers)
        case 15: try decoder.decodeSingularStringField(value: &_storage._clusterName)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._managedFields)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._generateName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._namespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._selfLink {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._uid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._resourceVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._generation {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._creationTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._deletionTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._deletionGracePeriodSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 11)
      }
      if !_storage._annotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._annotations, fieldNumber: 12)
      }
      if !_storage._ownerReferences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ownerReferences, fieldNumber: 13)
      }
      if !_storage._finalizers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._finalizers, fieldNumber: 14)
      }
      if let v = _storage._clusterName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if !_storage._managedFields.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._managedFields, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._generateName != rhs_storage._generateName {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._selfLink != rhs_storage._selfLink {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._creationTimestamp != rhs_storage._creationTimestamp {return false}
        if _storage._deletionTimestamp != rhs_storage._deletionTimestamp {return false}
        if _storage._deletionGracePeriodSeconds != rhs_storage._deletionGracePeriodSeconds {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._ownerReferences != rhs_storage._ownerReferences {return false}
        if _storage._finalizers != rhs_storage._finalizers {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._managedFields != rhs_storage._managedFields {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OwnerReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "apiVersion"),
    1: .same(proto: "kind"),
    3: .same(proto: "name"),
    4: .same(proto: "uid"),
    6: .same(proto: "controller"),
    7: .same(proto: "blockOwnerDeletion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._kind)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularStringField(value: &self._uid)
      case 5: try decoder.decodeSingularStringField(value: &self._apiVersion)
      case 6: try decoder.decodeSingularBoolField(value: &self._controller)
      case 7: try decoder.decodeSingularBoolField(value: &self._blockOwnerDeletion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._apiVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._controller {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._blockOwnerDeletion {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference) -> Bool {
    if lhs._apiVersion != rhs._apiVersion {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._controller != rhs._controller {return false}
    if lhs._blockOwnerDeletion != rhs._blockOwnerDeletion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PartialObjectMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadataList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PartialObjectMetadataList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadata] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadataList, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PartialObjectMetadataList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Patch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Patch"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Patch, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Patch) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PatchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PatchOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dryRun"),
    2: .same(proto: "force"),
    3: .same(proto: "fieldManager"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.dryRun)
      case 2: try decoder.decodeSingularBoolField(value: &self._force)
      case 3: try decoder.decodeSingularStringField(value: &self._fieldManager)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dryRun.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRun, fieldNumber: 1)
    }
    if let v = self._force {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._fieldManager {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PatchOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_PatchOptions) -> Bool {
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs._force != rhs._force {return false}
    if lhs._fieldManager != rhs._fieldManager {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preconditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "resourceVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._uid)
      case 2: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Preconditions) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_RootPaths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RootPaths"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.paths)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_RootPaths, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_RootPaths) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerAddressByClientCIDR"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientCIDR"),
    2: .same(proto: "serverAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._clientCidr)
      case 2: try decoder.decodeSingularStringField(value: &self._serverAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._clientCidr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._serverAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ServerAddressByClientCIDR) -> Bool {
    if lhs._clientCidr != rhs._clientCidr {return false}
    if lhs._serverAddress != rhs._serverAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "status"),
    3: .same(proto: "message"),
    4: .same(proto: "reason"),
    5: .same(proto: "details"),
    6: .same(proto: "code"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _status: String? = nil
    var _message: String? = nil
    var _reason: String? = nil
    var _details: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails? = nil
    var _code: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _status = source._status
      _message = source._message
      _reason = source._reason
      _details = source._details
      _code = source._code
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularStringField(value: &_storage._message)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._details)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._code)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._details {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._code {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Status, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Status) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._code != rhs_storage._code {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusCause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusCause"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "message"),
    3: .same(proto: "field"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._reason)
      case 2: try decoder.decodeSingularStringField(value: &self._message)
      case 3: try decoder.decodeSingularStringField(value: &self._field)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._field {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusCause, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusCause) -> Bool {
    if lhs._reason != rhs._reason {return false}
    if lhs._message != rhs._message {return false}
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "group"),
    3: .same(proto: "kind"),
    6: .same(proto: "uid"),
    4: .same(proto: "causes"),
    5: .same(proto: "retryAfterSeconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._group)
      case 3: try decoder.decodeSingularStringField(value: &self._kind)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.causes)
      case 5: try decoder.decodeSingularInt32Field(value: &self._retryAfterSeconds)
      case 6: try decoder.decodeSingularStringField(value: &self._uid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.causes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.causes, fieldNumber: 4)
    }
    if let v = self._retryAfterSeconds {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_StatusDetails) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._group != rhs._group {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs.causes != rhs.causes {return false}
    if lhs._retryAfterSeconds != rhs._retryAfterSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TableOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "includeObject"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._includeObject)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._includeObject {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TableOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TableOptions) -> Bool {
    if lhs._includeObject != rhs._includeObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Time"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
    2: .same(proto: "nanos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._seconds)
      case 2: try decoder.decodeSingularInt32Field(value: &self._nanos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._seconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nanos {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs._nanos != rhs._nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Timestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
    2: .same(proto: "nanos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._seconds)
      case 2: try decoder.decodeSingularInt32Field(value: &self._nanos)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._seconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nanos {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Timestamp, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Timestamp) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs._nanos != rhs._nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TypeMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "apiVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._kind)
      case 2: try decoder.decodeSingularStringField(value: &self._apiVersion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._apiVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TypeMeta, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_TypeMeta) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._apiVersion != rhs._apiVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_UpdateOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dryRun"),
    2: .same(proto: "fieldManager"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.dryRun)
      case 2: try decoder.decodeSingularStringField(value: &self._fieldManager)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dryRun.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRun, fieldNumber: 1)
    }
    if let v = self._fieldManager {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_UpdateOptions, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_UpdateOptions) -> Bool {
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs._fieldManager != rhs._fieldManager {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Verbs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedStringField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Verbs) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "object"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _object: K8s_Io_Apimachinery_Pkg_Runtime_RawExtension? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _object = source._object
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._object)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._object {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent, rhs: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_WatchEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._object != rhs_storage._object {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
