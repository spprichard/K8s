// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/authentication/v1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// BoundObjectReference is a reference to an object that a token is bound to.
struct K8s_Io_Api_Authentication_V1_BoundObjectReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind of the referent. Valid kinds are 'Pod' and 'Secret'.
  /// +optional
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// API version of the referent.
  /// +optional
  var aPiversion: String {
    get {return _aPiversion ?? String()}
    set {_aPiversion = newValue}
  }
  /// Returns true if `aPiversion` has been explicitly set.
  var hasAPiversion: Bool {return self._aPiversion != nil}
  /// Clears the value of `aPiversion`. Subsequent reads from it will return its default value.
  mutating func clearAPiversion() {self._aPiversion = nil}

  /// Name of the referent.
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// UID of the referent.
  /// +optional
  var uID: String {
    get {return _uID ?? String()}
    set {_uID = newValue}
  }
  /// Returns true if `uID` has been explicitly set.
  var hasUID: Bool {return self._uID != nil}
  /// Clears the value of `uID`. Subsequent reads from it will return its default value.
  mutating func clearUID() {self._uID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _kind: String? = nil
  fileprivate var _aPiversion: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _uID: String? = nil
}

/// ExtraValue masks the value so protobuf can generate
/// +protobuf.nullable=true
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Api_Authentication_V1_ExtraValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TokenRequest requests a token for a given service account.
struct K8s_Io_Api_Authentication_V1_TokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var spec: K8s_Io_Api_Authentication_V1_TokenRequestSpec {
    get {return _storage._spec ?? K8s_Io_Api_Authentication_V1_TokenRequestSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// +optional
  var status: K8s_Io_Api_Authentication_V1_TokenRequestStatus {
    get {return _storage._status ?? K8s_Io_Api_Authentication_V1_TokenRequestStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TokenRequestSpec contains client provided parameters of a token request.
struct K8s_Io_Api_Authentication_V1_TokenRequestSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Audiences are the intendend audiences of the token. A recipient of a
  /// token must identitfy themself with an identifier in the list of
  /// audiences of the token, and otherwise should reject the token. A
  /// token issued for multiple audiences may be used to authenticate
  /// against any of the audiences listed but implies a high degree of
  /// trust between the target audiences.
  var audiences: [String] {
    get {return _storage._audiences}
    set {_uniqueStorage()._audiences = newValue}
  }

  /// ExpirationSeconds is the requested duration of validity of the request. The
  /// token issuer may return a token with a different validity duration so a
  /// client needs to check the 'expiration' field in a response.
  /// +optional
  var expirationSeconds: Int64 {
    get {return _storage._expirationSeconds ?? 0}
    set {_uniqueStorage()._expirationSeconds = newValue}
  }
  /// Returns true if `expirationSeconds` has been explicitly set.
  var hasExpirationSeconds: Bool {return _storage._expirationSeconds != nil}
  /// Clears the value of `expirationSeconds`. Subsequent reads from it will return its default value.
  mutating func clearExpirationSeconds() {_uniqueStorage()._expirationSeconds = nil}

  /// BoundObjectRef is a reference to an object that the token will be bound to.
  /// The token will only be valid for as long as the bound object exists.
  /// NOTE: The API server's TokenReview endpoint will validate the
  /// BoundObjectRef, but other audiences may not. Keep ExpirationSeconds
  /// small if you want prompt revocation.
  /// +optional
  var boundObjectRef: K8s_Io_Api_Authentication_V1_BoundObjectReference {
    get {return _storage._boundObjectRef ?? K8s_Io_Api_Authentication_V1_BoundObjectReference()}
    set {_uniqueStorage()._boundObjectRef = newValue}
  }
  /// Returns true if `boundObjectRef` has been explicitly set.
  var hasBoundObjectRef: Bool {return _storage._boundObjectRef != nil}
  /// Clears the value of `boundObjectRef`. Subsequent reads from it will return its default value.
  mutating func clearBoundObjectRef() {_uniqueStorage()._boundObjectRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TokenRequestStatus is the result of a token request.
struct K8s_Io_Api_Authentication_V1_TokenRequestStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is the opaque bearer token.
  var token: String {
    get {return _storage._token ?? String()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {_uniqueStorage()._token = nil}

  /// ExpirationTimestamp is the time of expiration of the returned token.
  var expirationTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._expirationTimestamp ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._expirationTimestamp = newValue}
  }
  /// Returns true if `expirationTimestamp` has been explicitly set.
  var hasExpirationTimestamp: Bool {return _storage._expirationTimestamp != nil}
  /// Clears the value of `expirationTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTimestamp() {_uniqueStorage()._expirationTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TokenReview attempts to authenticate a token to a known user.
/// Note: TokenReview requests may be cached by the webhook token authenticator
/// plugin in the kube-apiserver.
struct K8s_Io_Api_Authentication_V1_TokenReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec holds information about the request being evaluated
  var spec: K8s_Io_Api_Authentication_V1_TokenReviewSpec {
    get {return _storage._spec ?? K8s_Io_Api_Authentication_V1_TokenReviewSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is filled in by the server and indicates whether the request can be authenticated.
  /// +optional
  var status: K8s_Io_Api_Authentication_V1_TokenReviewStatus {
    get {return _storage._status ?? K8s_Io_Api_Authentication_V1_TokenReviewStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TokenReviewSpec is a description of the token authentication request.
struct K8s_Io_Api_Authentication_V1_TokenReviewSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is the opaque bearer token.
  /// +optional
  var token: String {
    get {return _token ?? String()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  /// Audiences is a list of the identifiers that the resource server presented
  /// with the token identifies as. Audience-aware token authenticators will
  /// verify that the token was intended for at least one of the audiences in
  /// this list. If no audiences are provided, the audience will default to the
  /// audience of the Kubernetes apiserver.
  /// +optional
  var audiences: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: String? = nil
}

/// TokenReviewStatus is the result of the token authentication request.
struct K8s_Io_Api_Authentication_V1_TokenReviewStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authenticated indicates that the token was associated with a known user.
  /// +optional
  var authenticated: Bool {
    get {return _storage._authenticated ?? false}
    set {_uniqueStorage()._authenticated = newValue}
  }
  /// Returns true if `authenticated` has been explicitly set.
  var hasAuthenticated: Bool {return _storage._authenticated != nil}
  /// Clears the value of `authenticated`. Subsequent reads from it will return its default value.
  mutating func clearAuthenticated() {_uniqueStorage()._authenticated = nil}

  /// User is the UserInfo associated with the provided token.
  /// +optional
  var user: K8s_Io_Api_Authentication_V1_UserInfo {
    get {return _storage._user ?? K8s_Io_Api_Authentication_V1_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Audiences are audience identifiers chosen by the authenticator that are
  /// compatible with both the TokenReview and token. An identifier is any
  /// identifier in the intersection of the TokenReviewSpec audiences and the
  /// token's audiences. A client of the TokenReview API that sets the
  /// spec.audiences field should validate that a compatible audience identifier
  /// is returned in the status.audiences field to ensure that the TokenReview
  /// server is audience aware. If a TokenReview returns an empty
  /// status.audience field where status.authenticated is "true", the token is
  /// valid against the audience of the Kubernetes API server.
  /// +optional
  var audiences: [String] {
    get {return _storage._audiences}
    set {_uniqueStorage()._audiences = newValue}
  }

  /// Error indicates that the token couldn't be checked
  /// +optional
  var error: String {
    get {return _storage._error ?? String()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserInfo holds the information about the user needed to implement the
/// user.Info interface.
struct K8s_Io_Api_Authentication_V1_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name that uniquely identifies this user among all active users.
  /// +optional
  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// A unique value that identifies this user across time. If this user is
  /// deleted and another user by the same name is added, they will have
  /// different UIDs.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// The names of groups this user is a part of.
  /// +optional
  var groups: [String] = []

  /// Any additional information provided by the authenticator.
  /// +optional
  var extra: Dictionary<String,K8s_Io_Api_Authentication_V1_ExtraValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _username: String? = nil
  fileprivate var _uid: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.authentication.v1"

extension K8s_Io_Api_Authentication_V1_BoundObjectReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoundObjectReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "aPIVersion"),
    3: .same(proto: "name"),
    4: .same(proto: "uID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._kind)
      case 2: try decoder.decodeSingularStringField(value: &self._aPiversion)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularStringField(value: &self._uID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._aPiversion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._uID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_BoundObjectReference, rhs: K8s_Io_Api_Authentication_V1_BoundObjectReference) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._aPiversion != rhs._aPiversion {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uID != rhs._uID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_ExtraValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtraValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedStringField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_ExtraValue, rhs: K8s_Io_Api_Authentication_V1_ExtraValue) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Authentication_V1_TokenRequestSpec? = nil
    var _status: K8s_Io_Api_Authentication_V1_TokenRequestStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenRequest, rhs: K8s_Io_Api_Authentication_V1_TokenRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenRequestSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenRequestSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audiences"),
    4: .same(proto: "expirationSeconds"),
    3: .same(proto: "boundObjectRef"),
  ]

  fileprivate class _StorageClass {
    var _audiences: [String] = []
    var _expirationSeconds: Int64? = nil
    var _boundObjectRef: K8s_Io_Api_Authentication_V1_BoundObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _audiences = source._audiences
      _expirationSeconds = source._expirationSeconds
      _boundObjectRef = source._boundObjectRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._audiences)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._boundObjectRef)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._expirationSeconds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._audiences.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._audiences, fieldNumber: 1)
      }
      if let v = _storage._boundObjectRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._expirationSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenRequestSpec, rhs: K8s_Io_Api_Authentication_V1_TokenRequestSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._audiences != rhs_storage._audiences {return false}
        if _storage._expirationSeconds != rhs_storage._expirationSeconds {return false}
        if _storage._boundObjectRef != rhs_storage._boundObjectRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenRequestStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenRequestStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "expirationTimestamp"),
  ]

  fileprivate class _StorageClass {
    var _token: String? = nil
    var _expirationTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _expirationTimestamp = source._expirationTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._token)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._expirationTimestamp)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._token {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._expirationTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenRequestStatus, rhs: K8s_Io_Api_Authentication_V1_TokenRequestStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._expirationTimestamp != rhs_storage._expirationTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Authentication_V1_TokenReviewSpec? = nil
    var _status: K8s_Io_Api_Authentication_V1_TokenReviewStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenReview, rhs: K8s_Io_Api_Authentication_V1_TokenReview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenReviewSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReviewSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "audiences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._token)
      case 2: try decoder.decodeRepeatedStringField(value: &self.audiences)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.audiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.audiences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenReviewSpec, rhs: K8s_Io_Api_Authentication_V1_TokenReviewSpec) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.audiences != rhs.audiences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_TokenReviewStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReviewStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticated"),
    2: .same(proto: "user"),
    4: .same(proto: "audiences"),
    3: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _authenticated: Bool? = nil
    var _user: K8s_Io_Api_Authentication_V1_UserInfo? = nil
    var _audiences: [String] = []
    var _error: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _authenticated = source._authenticated
      _user = source._user
      _audiences = source._audiences
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._authenticated)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 3: try decoder.decodeSingularStringField(value: &_storage._error)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._audiences)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._authenticated {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._audiences.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._audiences, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_TokenReviewStatus, rhs: K8s_Io_Api_Authentication_V1_TokenReviewStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authenticated != rhs_storage._authenticated {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._audiences != rhs_storage._audiences {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "uid"),
    3: .same(proto: "groups"),
    4: .same(proto: "extra"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._username)
      case 2: try decoder.decodeSingularStringField(value: &self._uid)
      case 3: try decoder.decodeRepeatedStringField(value: &self.groups)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Authentication_V1_ExtraValue>.self, value: &self.extra)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groups, fieldNumber: 3)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Authentication_V1_ExtraValue>.self, value: self.extra, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1_UserInfo, rhs: K8s_Io_Api_Authentication_V1_UserInfo) -> Bool {
    if lhs._username != rhs._username {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
