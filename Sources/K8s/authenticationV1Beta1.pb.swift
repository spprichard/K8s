// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/authentication/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ExtraValue masks the value so protobuf can generate
/// +protobuf.nullable=true
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Api_Authentication_V1beta1_ExtraValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TokenReview attempts to authenticate a token to a known user.
/// Note: TokenReview requests may be cached by the webhook token authenticator
/// plugin in the kube-apiserver.
struct K8s_Io_Api_Authentication_V1beta1_TokenReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec holds information about the request being evaluated
  var spec: K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec {
    get {return _storage._spec ?? K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is filled in by the server and indicates whether the request can be authenticated.
  /// +optional
  var status: K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus {
    get {return _storage._status ?? K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TokenReviewSpec is a description of the token authentication request.
struct K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is the opaque bearer token.
  /// +optional
  var token: String {
    get {return _token ?? String()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  /// Audiences is a list of the identifiers that the resource server presented
  /// with the token identifies as. Audience-aware token authenticators will
  /// verify that the token was intended for at least one of the audiences in
  /// this list. If no audiences are provided, the audience will default to the
  /// audience of the Kubernetes apiserver.
  /// +optional
  var audiences: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: String? = nil
}

/// TokenReviewStatus is the result of the token authentication request.
struct K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authenticated indicates that the token was associated with a known user.
  /// +optional
  var authenticated: Bool {
    get {return _storage._authenticated ?? false}
    set {_uniqueStorage()._authenticated = newValue}
  }
  /// Returns true if `authenticated` has been explicitly set.
  var hasAuthenticated: Bool {return _storage._authenticated != nil}
  /// Clears the value of `authenticated`. Subsequent reads from it will return its default value.
  mutating func clearAuthenticated() {_uniqueStorage()._authenticated = nil}

  /// User is the UserInfo associated with the provided token.
  /// +optional
  var user: K8s_Io_Api_Authentication_V1beta1_UserInfo {
    get {return _storage._user ?? K8s_Io_Api_Authentication_V1beta1_UserInfo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Audiences are audience identifiers chosen by the authenticator that are
  /// compatible with both the TokenReview and token. An identifier is any
  /// identifier in the intersection of the TokenReviewSpec audiences and the
  /// token's audiences. A client of the TokenReview API that sets the
  /// spec.audiences field should validate that a compatible audience identifier
  /// is returned in the status.audiences field to ensure that the TokenReview
  /// server is audience aware. If a TokenReview returns an empty
  /// status.audience field where status.authenticated is "true", the token is
  /// valid against the audience of the Kubernetes API server.
  /// +optional
  var audiences: [String] {
    get {return _storage._audiences}
    set {_uniqueStorage()._audiences = newValue}
  }

  /// Error indicates that the token couldn't be checked
  /// +optional
  var error: String {
    get {return _storage._error ?? String()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserInfo holds the information about the user needed to implement the
/// user.Info interface.
struct K8s_Io_Api_Authentication_V1beta1_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name that uniquely identifies this user among all active users.
  /// +optional
  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// A unique value that identifies this user across time. If this user is
  /// deleted and another user by the same name is added, they will have
  /// different UIDs.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// The names of groups this user is a part of.
  /// +optional
  var groups: [String] = []

  /// Any additional information provided by the authenticator.
  /// +optional
  var extra: Dictionary<String,K8s_Io_Api_Authentication_V1beta1_ExtraValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _username: String? = nil
  fileprivate var _uid: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.authentication.v1beta1"

extension K8s_Io_Api_Authentication_V1beta1_ExtraValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtraValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedStringField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1beta1_ExtraValue, rhs: K8s_Io_Api_Authentication_V1beta1_ExtraValue) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1beta1_TokenReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec? = nil
    var _status: K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1beta1_TokenReview, rhs: K8s_Io_Api_Authentication_V1beta1_TokenReview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReviewSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "audiences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._token)
      case 2: try decoder.decodeRepeatedStringField(value: &self.audiences)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.audiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.audiences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec, rhs: K8s_Io_Api_Authentication_V1beta1_TokenReviewSpec) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.audiences != rhs.audiences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenReviewStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticated"),
    2: .same(proto: "user"),
    4: .same(proto: "audiences"),
    3: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _authenticated: Bool? = nil
    var _user: K8s_Io_Api_Authentication_V1beta1_UserInfo? = nil
    var _audiences: [String] = []
    var _error: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _authenticated = source._authenticated
      _user = source._user
      _audiences = source._audiences
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._authenticated)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 3: try decoder.decodeSingularStringField(value: &_storage._error)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._audiences)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._authenticated {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._error {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._audiences.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._audiences, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus, rhs: K8s_Io_Api_Authentication_V1beta1_TokenReviewStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authenticated != rhs_storage._authenticated {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._audiences != rhs_storage._audiences {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Authentication_V1beta1_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "uid"),
    3: .same(proto: "groups"),
    4: .same(proto: "extra"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._username)
      case 2: try decoder.decodeSingularStringField(value: &self._uid)
      case 3: try decoder.decodeRepeatedStringField(value: &self.groups)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Authentication_V1beta1_ExtraValue>.self, value: &self.extra)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groups, fieldNumber: 3)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Authentication_V1beta1_ExtraValue>.self, value: self.extra, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Authentication_V1beta1_UserInfo, rhs: K8s_Io_Api_Authentication_V1beta1_UserInfo) -> Bool {
    if lhs._username != rhs._username {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
