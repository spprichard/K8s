// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/extensions/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
struct K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the registered name of the CSI driver
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
}

/// AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
/// Deprecated: use AllowedFlexVolume from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// driver is the name of the Flexvolume driver.
  var driver: String {
    get {return _driver ?? String()}
    set {_driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return self._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {self._driver = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _driver: String? = nil
}

/// AllowedHostPath defines the host volume conditions that will be enabled by a policy
/// for pods to use. It requires the path prefix to be defined.
/// Deprecated: use AllowedHostPath from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_AllowedHostPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pathPrefix is the path prefix that the host volume must match.
  /// It does not support `*`.
  /// Trailing slashes are trimmed when validating the path prefix with a host path.
  ///
  /// Examples:
  /// `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
  /// `/foo` would not allow `/food` or `/etc/foo`
  var pathPrefix: String {
    get {return _pathPrefix ?? String()}
    set {_pathPrefix = newValue}
  }
  /// Returns true if `pathPrefix` has been explicitly set.
  var hasPathPrefix: Bool {return self._pathPrefix != nil}
  /// Clears the value of `pathPrefix`. Subsequent reads from it will return its default value.
  mutating func clearPathPrefix() {self._pathPrefix = nil}

  /// when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pathPrefix: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for
/// more information.
/// DaemonSet represents the configuration of a daemon set.
struct K8s_Io_Api_Extensions_V1beta1_DaemonSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The desired behavior of this daemon set.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The current status of this daemon set. This data may be
  /// out of date by some window of time.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus {
    get {return _storage._status ?? K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DaemonSetCondition describes the state of a DaemonSet at a certain point.
struct K8s_Io_Api_Extensions_V1beta1_DaemonSetCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of DaemonSet condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DaemonSetList is a collection of daemon sets.
struct K8s_Io_Api_Extensions_V1beta1_DaemonSetList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// A list of daemon sets.
  var items: [K8s_Io_Api_Extensions_V1beta1_DaemonSet] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DaemonSetSpec is the specification of a daemon set.
struct K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A label query over pods that are managed by the daemon set.
  /// Must match in order to be controlled.
  /// If empty, defaulted to labels on Pod template.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// An object that describes the pod that will be created.
  /// The DaemonSet will create exactly one copy of this pod on every node
  /// that matches the template's node selector (or on every node if no node
  /// selector is specified).
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  /// An update strategy to replace existing DaemonSet pods with new pods.
  /// +optional
  var updateStrategy: K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy {
    get {return _storage._updateStrategy ?? K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy()}
    set {_uniqueStorage()._updateStrategy = newValue}
  }
  /// Returns true if `updateStrategy` has been explicitly set.
  var hasUpdateStrategy: Bool {return _storage._updateStrategy != nil}
  /// Clears the value of `updateStrategy`. Subsequent reads from it will return its default value.
  mutating func clearUpdateStrategy() {_uniqueStorage()._updateStrategy = nil}

  /// The minimum number of seconds for which a newly created DaemonSet pod should
  /// be ready without any of its container crashing, for it to be considered
  /// available. Defaults to 0 (pod will be considered available as soon as it
  /// is ready).
  /// +optional
  var minReadySeconds: Int32 {
    get {return _storage._minReadySeconds ?? 0}
    set {_uniqueStorage()._minReadySeconds = newValue}
  }
  /// Returns true if `minReadySeconds` has been explicitly set.
  var hasMinReadySeconds: Bool {return _storage._minReadySeconds != nil}
  /// Clears the value of `minReadySeconds`. Subsequent reads from it will return its default value.
  mutating func clearMinReadySeconds() {_uniqueStorage()._minReadySeconds = nil}

  /// DEPRECATED.
  /// A sequence number representing a specific generation of the template.
  /// Populated by the system. It can be set only during the creation.
  /// +optional
  var templateGeneration: Int64 {
    get {return _storage._templateGeneration ?? 0}
    set {_uniqueStorage()._templateGeneration = newValue}
  }
  /// Returns true if `templateGeneration` has been explicitly set.
  var hasTemplateGeneration: Bool {return _storage._templateGeneration != nil}
  /// Clears the value of `templateGeneration`. Subsequent reads from it will return its default value.
  mutating func clearTemplateGeneration() {_uniqueStorage()._templateGeneration = nil}

  /// The number of old history to retain to allow rollback.
  /// This is a pointer to distinguish between explicit zero and not specified.
  /// Defaults to 10.
  /// +optional
  var revisionHistoryLimit: Int32 {
    get {return _storage._revisionHistoryLimit ?? 0}
    set {_uniqueStorage()._revisionHistoryLimit = newValue}
  }
  /// Returns true if `revisionHistoryLimit` has been explicitly set.
  var hasRevisionHistoryLimit: Bool {return _storage._revisionHistoryLimit != nil}
  /// Clears the value of `revisionHistoryLimit`. Subsequent reads from it will return its default value.
  mutating func clearRevisionHistoryLimit() {_uniqueStorage()._revisionHistoryLimit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DaemonSetStatus represents the current status of a daemon set.
struct K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of nodes that are running at least 1
  /// daemon pod and are supposed to run the daemon pod.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  var currentNumberScheduled: Int32 {
    get {return _currentNumberScheduled ?? 0}
    set {_currentNumberScheduled = newValue}
  }
  /// Returns true if `currentNumberScheduled` has been explicitly set.
  var hasCurrentNumberScheduled: Bool {return self._currentNumberScheduled != nil}
  /// Clears the value of `currentNumberScheduled`. Subsequent reads from it will return its default value.
  mutating func clearCurrentNumberScheduled() {self._currentNumberScheduled = nil}

  /// The number of nodes that are running the daemon pod, but are
  /// not supposed to run the daemon pod.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  var numberMisscheduled: Int32 {
    get {return _numberMisscheduled ?? 0}
    set {_numberMisscheduled = newValue}
  }
  /// Returns true if `numberMisscheduled` has been explicitly set.
  var hasNumberMisscheduled: Bool {return self._numberMisscheduled != nil}
  /// Clears the value of `numberMisscheduled`. Subsequent reads from it will return its default value.
  mutating func clearNumberMisscheduled() {self._numberMisscheduled = nil}

  /// The total number of nodes that should be running the daemon
  /// pod (including nodes correctly running the daemon pod).
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  var desiredNumberScheduled: Int32 {
    get {return _desiredNumberScheduled ?? 0}
    set {_desiredNumberScheduled = newValue}
  }
  /// Returns true if `desiredNumberScheduled` has been explicitly set.
  var hasDesiredNumberScheduled: Bool {return self._desiredNumberScheduled != nil}
  /// Clears the value of `desiredNumberScheduled`. Subsequent reads from it will return its default value.
  mutating func clearDesiredNumberScheduled() {self._desiredNumberScheduled = nil}

  /// The number of nodes that should be running the daemon pod and have one
  /// or more of the daemon pod running and ready.
  var numberReady: Int32 {
    get {return _numberReady ?? 0}
    set {_numberReady = newValue}
  }
  /// Returns true if `numberReady` has been explicitly set.
  var hasNumberReady: Bool {return self._numberReady != nil}
  /// Clears the value of `numberReady`. Subsequent reads from it will return its default value.
  mutating func clearNumberReady() {self._numberReady = nil}

  /// The most recent generation observed by the daemon set controller.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// The total number of nodes that are running updated daemon pod
  /// +optional
  var updatedNumberScheduled: Int32 {
    get {return _updatedNumberScheduled ?? 0}
    set {_updatedNumberScheduled = newValue}
  }
  /// Returns true if `updatedNumberScheduled` has been explicitly set.
  var hasUpdatedNumberScheduled: Bool {return self._updatedNumberScheduled != nil}
  /// Clears the value of `updatedNumberScheduled`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedNumberScheduled() {self._updatedNumberScheduled = nil}

  /// The number of nodes that should be running the
  /// daemon pod and have one or more of the daemon pod running and
  /// available (ready for at least spec.minReadySeconds)
  /// +optional
  var numberAvailable: Int32 {
    get {return _numberAvailable ?? 0}
    set {_numberAvailable = newValue}
  }
  /// Returns true if `numberAvailable` has been explicitly set.
  var hasNumberAvailable: Bool {return self._numberAvailable != nil}
  /// Clears the value of `numberAvailable`. Subsequent reads from it will return its default value.
  mutating func clearNumberAvailable() {self._numberAvailable = nil}

  /// The number of nodes that should be running the
  /// daemon pod and have none of the daemon pod running and available
  /// (ready for at least spec.minReadySeconds)
  /// +optional
  var numberUnavailable: Int32 {
    get {return _numberUnavailable ?? 0}
    set {_numberUnavailable = newValue}
  }
  /// Returns true if `numberUnavailable` has been explicitly set.
  var hasNumberUnavailable: Bool {return self._numberUnavailable != nil}
  /// Clears the value of `numberUnavailable`. Subsequent reads from it will return its default value.
  mutating func clearNumberUnavailable() {self._numberUnavailable = nil}

  /// Count of hash collisions for the DaemonSet. The DaemonSet controller
  /// uses this field as a collision avoidance mechanism when it needs to
  /// create the name for the newest ControllerRevision.
  /// +optional
  var collisionCount: Int32 {
    get {return _collisionCount ?? 0}
    set {_collisionCount = newValue}
  }
  /// Returns true if `collisionCount` has been explicitly set.
  var hasCollisionCount: Bool {return self._collisionCount != nil}
  /// Clears the value of `collisionCount`. Subsequent reads from it will return its default value.
  mutating func clearCollisionCount() {self._collisionCount = nil}

  /// Represents the latest available observations of a DaemonSet's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Extensions_V1beta1_DaemonSetCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentNumberScheduled: Int32? = nil
  fileprivate var _numberMisscheduled: Int32? = nil
  fileprivate var _desiredNumberScheduled: Int32? = nil
  fileprivate var _numberReady: Int32? = nil
  fileprivate var _observedGeneration: Int64? = nil
  fileprivate var _updatedNumberScheduled: Int32? = nil
  fileprivate var _numberAvailable: Int32? = nil
  fileprivate var _numberUnavailable: Int32? = nil
  fileprivate var _collisionCount: Int32? = nil
}

struct K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
  /// Default is OnDelete.
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Rolling update config params. Present only if type = "RollingUpdate".
  /// ---
  /// TODO: Update this to follow our convention for oneOf, whatever we decide it
  /// to be. Same as Deployment `strategy.rollingUpdate`.
  /// See https://github.com/kubernetes/kubernetes/issues/35345
  /// +optional
  var rollingUpdate: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet {
    get {return _storage._rollingUpdate ?? K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet()}
    set {_uniqueStorage()._rollingUpdate = newValue}
  }
  /// Returns true if `rollingUpdate` has been explicitly set.
  var hasRollingUpdate: Bool {return _storage._rollingUpdate != nil}
  /// Clears the value of `rollingUpdate`. Subsequent reads from it will return its default value.
  mutating func clearRollingUpdate() {_uniqueStorage()._rollingUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for
/// more information.
/// Deployment enables declarative updates for Pods and ReplicaSets.
struct K8s_Io_Api_Extensions_V1beta1_Deployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior of the Deployment.
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_DeploymentSpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_DeploymentSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the Deployment.
  /// +optional
  var status: K8s_Io_Api_Extensions_V1beta1_DeploymentStatus {
    get {return _storage._status ?? K8s_Io_Api_Extensions_V1beta1_DeploymentStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentCondition describes the state of a deployment at a certain point.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of deployment condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The last time this condition was updated.
  var lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastUpdateTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }
  /// Returns true if `lastUpdateTime` has been explicitly set.
  var hasLastUpdateTime: Bool {return _storage._lastUpdateTime != nil}
  /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdateTime() {_uniqueStorage()._lastUpdateTime = nil}

  /// Last time the condition transitioned from one status to another.
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentList is a list of Deployments.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of Deployments.
  var items: [K8s_Io_Api_Extensions_V1beta1_Deployment] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED.
/// DeploymentRollback stores the information required to rollback a deployment.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentRollback {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required: This must match the Name of a deployment.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// The annotations to be updated to a deployment
  /// +optional
  var updatedAnnotations: Dictionary<String,String> {
    get {return _storage._updatedAnnotations}
    set {_uniqueStorage()._updatedAnnotations = newValue}
  }

  /// The config of this deployment rollback.
  var rollbackTo: K8s_Io_Api_Extensions_V1beta1_RollbackConfig {
    get {return _storage._rollbackTo ?? K8s_Io_Api_Extensions_V1beta1_RollbackConfig()}
    set {_uniqueStorage()._rollbackTo = newValue}
  }
  /// Returns true if `rollbackTo` has been explicitly set.
  var hasRollbackTo: Bool {return _storage._rollbackTo != nil}
  /// Clears the value of `rollbackTo`. Subsequent reads from it will return its default value.
  mutating func clearRollbackTo() {_uniqueStorage()._rollbackTo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentSpec is the specification of the desired behavior of the Deployment.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of desired pods. This is a pointer to distinguish between explicit
  /// zero and not specified. Defaults to 1.
  /// +optional
  var replicas: Int32 {
    get {return _storage._replicas ?? 0}
    set {_uniqueStorage()._replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return _storage._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {_uniqueStorage()._replicas = nil}

  /// Label selector for pods. Existing ReplicaSets whose pods are
  /// selected by this will be the ones affected by this deployment.
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// Template describes the pods that will be created.
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  /// The deployment strategy to use to replace existing pods with new ones.
  /// +optional
  /// +patchStrategy=retainKeys
  var strategy: K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy {
    get {return _storage._strategy ?? K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy()}
    set {_uniqueStorage()._strategy = newValue}
  }
  /// Returns true if `strategy` has been explicitly set.
  var hasStrategy: Bool {return _storage._strategy != nil}
  /// Clears the value of `strategy`. Subsequent reads from it will return its default value.
  mutating func clearStrategy() {_uniqueStorage()._strategy = nil}

  /// Minimum number of seconds for which a newly created pod should be ready
  /// without any of its container crashing, for it to be considered available.
  /// Defaults to 0 (pod will be considered available as soon as it is ready)
  /// +optional
  var minReadySeconds: Int32 {
    get {return _storage._minReadySeconds ?? 0}
    set {_uniqueStorage()._minReadySeconds = newValue}
  }
  /// Returns true if `minReadySeconds` has been explicitly set.
  var hasMinReadySeconds: Bool {return _storage._minReadySeconds != nil}
  /// Clears the value of `minReadySeconds`. Subsequent reads from it will return its default value.
  mutating func clearMinReadySeconds() {_uniqueStorage()._minReadySeconds = nil}

  /// The number of old ReplicaSets to retain to allow rollback.
  /// This is a pointer to distinguish between explicit zero and not specified.
  /// This is set to the max value of int32 (i.e. 2147483647) by default, which
  /// means "retaining all old RelicaSets".
  /// +optional
  var revisionHistoryLimit: Int32 {
    get {return _storage._revisionHistoryLimit ?? 0}
    set {_uniqueStorage()._revisionHistoryLimit = newValue}
  }
  /// Returns true if `revisionHistoryLimit` has been explicitly set.
  var hasRevisionHistoryLimit: Bool {return _storage._revisionHistoryLimit != nil}
  /// Clears the value of `revisionHistoryLimit`. Subsequent reads from it will return its default value.
  mutating func clearRevisionHistoryLimit() {_uniqueStorage()._revisionHistoryLimit = nil}

  /// Indicates that the deployment is paused and will not be processed by the
  /// deployment controller.
  /// +optional
  var paused: Bool {
    get {return _storage._paused ?? false}
    set {_uniqueStorage()._paused = newValue}
  }
  /// Returns true if `paused` has been explicitly set.
  var hasPaused: Bool {return _storage._paused != nil}
  /// Clears the value of `paused`. Subsequent reads from it will return its default value.
  mutating func clearPaused() {_uniqueStorage()._paused = nil}

  /// DEPRECATED.
  /// The config this deployment is rolling back to. Will be cleared after rollback is done.
  /// +optional
  var rollbackTo: K8s_Io_Api_Extensions_V1beta1_RollbackConfig {
    get {return _storage._rollbackTo ?? K8s_Io_Api_Extensions_V1beta1_RollbackConfig()}
    set {_uniqueStorage()._rollbackTo = newValue}
  }
  /// Returns true if `rollbackTo` has been explicitly set.
  var hasRollbackTo: Bool {return _storage._rollbackTo != nil}
  /// Clears the value of `rollbackTo`. Subsequent reads from it will return its default value.
  mutating func clearRollbackTo() {_uniqueStorage()._rollbackTo = nil}

  /// The maximum time in seconds for a deployment to make progress before it
  /// is considered to be failed. The deployment controller will continue to
  /// process failed deployments and a condition with a ProgressDeadlineExceeded
  /// reason will be surfaced in the deployment status. Note that progress will
  /// not be estimated during the time a deployment is paused. This is set to
  /// the max value of int32 (i.e. 2147483647) by default, which means "no deadline".
  /// +optional
  var progressDeadlineSeconds: Int32 {
    get {return _storage._progressDeadlineSeconds ?? 0}
    set {_uniqueStorage()._progressDeadlineSeconds = newValue}
  }
  /// Returns true if `progressDeadlineSeconds` has been explicitly set.
  var hasProgressDeadlineSeconds: Bool {return _storage._progressDeadlineSeconds != nil}
  /// Clears the value of `progressDeadlineSeconds`. Subsequent reads from it will return its default value.
  mutating func clearProgressDeadlineSeconds() {_uniqueStorage()._progressDeadlineSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentStatus is the most recently observed status of the Deployment.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The generation observed by the deployment controller.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
  /// +optional
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
  /// +optional
  var updatedReplicas: Int32 {
    get {return _updatedReplicas ?? 0}
    set {_updatedReplicas = newValue}
  }
  /// Returns true if `updatedReplicas` has been explicitly set.
  var hasUpdatedReplicas: Bool {return self._updatedReplicas != nil}
  /// Clears the value of `updatedReplicas`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedReplicas() {self._updatedReplicas = nil}

  /// Total number of ready pods targeted by this deployment.
  /// +optional
  var readyReplicas: Int32 {
    get {return _readyReplicas ?? 0}
    set {_readyReplicas = newValue}
  }
  /// Returns true if `readyReplicas` has been explicitly set.
  var hasReadyReplicas: Bool {return self._readyReplicas != nil}
  /// Clears the value of `readyReplicas`. Subsequent reads from it will return its default value.
  mutating func clearReadyReplicas() {self._readyReplicas = nil}

  /// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
  /// +optional
  var availableReplicas: Int32 {
    get {return _availableReplicas ?? 0}
    set {_availableReplicas = newValue}
  }
  /// Returns true if `availableReplicas` has been explicitly set.
  var hasAvailableReplicas: Bool {return self._availableReplicas != nil}
  /// Clears the value of `availableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearAvailableReplicas() {self._availableReplicas = nil}

  /// Total number of unavailable pods targeted by this deployment. This is the total number of
  /// pods that are still required for the deployment to have 100% available capacity. They may
  /// either be pods that are running but not yet available or pods that still have not been created.
  /// +optional
  var unavailableReplicas: Int32 {
    get {return _unavailableReplicas ?? 0}
    set {_unavailableReplicas = newValue}
  }
  /// Returns true if `unavailableReplicas` has been explicitly set.
  var hasUnavailableReplicas: Bool {return self._unavailableReplicas != nil}
  /// Clears the value of `unavailableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearUnavailableReplicas() {self._unavailableReplicas = nil}

  /// Represents the latest available observations of a deployment's current state.
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Extensions_V1beta1_DeploymentCondition] = []

  /// Count of hash collisions for the Deployment. The Deployment controller uses this
  /// field as a collision avoidance mechanism when it needs to create the name for the
  /// newest ReplicaSet.
  /// +optional
  var collisionCount: Int32 {
    get {return _collisionCount ?? 0}
    set {_collisionCount = newValue}
  }
  /// Returns true if `collisionCount` has been explicitly set.
  var hasCollisionCount: Bool {return self._collisionCount != nil}
  /// Clears the value of `collisionCount`. Subsequent reads from it will return its default value.
  mutating func clearCollisionCount() {self._collisionCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _observedGeneration: Int64? = nil
  fileprivate var _replicas: Int32? = nil
  fileprivate var _updatedReplicas: Int32? = nil
  fileprivate var _readyReplicas: Int32? = nil
  fileprivate var _availableReplicas: Int32? = nil
  fileprivate var _unavailableReplicas: Int32? = nil
  fileprivate var _collisionCount: Int32? = nil
}

/// DeploymentStrategy describes how to replace existing pods with new ones.
struct K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Rolling update config params. Present only if DeploymentStrategyType =
  /// RollingUpdate.
  /// ---
  /// TODO: Update this to follow our convention for oneOf, whatever we decide it
  /// to be.
  /// +optional
  var rollingUpdate: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment {
    get {return _storage._rollingUpdate ?? K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment()}
    set {_uniqueStorage()._rollingUpdate = newValue}
  }
  /// Returns true if `rollingUpdate` has been explicitly set.
  var hasRollingUpdate: Bool {return _storage._rollingUpdate != nil}
  /// Clears the value of `rollingUpdate`. Subsequent reads from it will return its default value.
  mutating func clearRollingUpdate() {_uniqueStorage()._rollingUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
/// Deprecated: use FSGroupStrategyOptions from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
  /// +optional
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of fs groups.  If you would like to force a single
  /// fs group then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Extensions_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// HTTPIngressPath associates a path regex with a backend. Incoming urls matching
/// the path are forwarded to the backend.
struct K8s_Io_Api_Extensions_V1beta1_HTTPIngressPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path is an extended POSIX regex as defined by IEEE Std 1003.1,
  /// (i.e this follows the egrep/unix syntax, not the perl syntax)
  /// matched against the path of an incoming request. Currently it can
  /// contain characters disallowed from the conventional "path"
  /// part of a URL as defined by RFC 3986. Paths must begin with
  /// a '/'. If unspecified, the path defaults to a catch all sending
  /// traffic to the backend.
  /// +optional
  var path: String {
    get {return _storage._path ?? String()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Backend defines the referenced service endpoint to which the traffic
  /// will be forwarded to.
  var backend: K8s_Io_Api_Extensions_V1beta1_IngressBackend {
    get {return _storage._backend ?? K8s_Io_Api_Extensions_V1beta1_IngressBackend()}
    set {_uniqueStorage()._backend = newValue}
  }
  /// Returns true if `backend` has been explicitly set.
  var hasBackend: Bool {return _storage._backend != nil}
  /// Clears the value of `backend`. Subsequent reads from it will return its default value.
  mutating func clearBackend() {_uniqueStorage()._backend = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HTTPIngressRuleValue is a list of http selectors pointing to backends.
/// In the example: http://<host>/<path>?<searchpart> -> backend where
/// where parts of the url correspond to RFC 3986, this resource will be used
/// to match against everything after the last '/' and before the first '?'
/// or '#'.
struct K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of paths that map requests to backends.
  var paths: [K8s_Io_Api_Extensions_V1beta1_HTTPIngressPath] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// HostPortRange defines a range of host ports that will be enabled by a policy
/// for pods to use.  It requires both the start and end to be defined.
/// Deprecated: use HostPortRange from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_HostPortRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// min is the start of the range, inclusive.
  var min: Int32 {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {self._min = nil}

  /// max is the end of the range, inclusive.
  var max: Int32 {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  mutating func clearMax() {self._max = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _min: Int32? = nil
  fileprivate var _max: Int32? = nil
}

/// IDRange provides a min/max of an allowed range of IDs.
/// Deprecated: use IDRange from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_IDRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// min is the start of the range, inclusive.
  var min: Int64 {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {self._min = nil}

  /// max is the end of the range, inclusive.
  var max: Int64 {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  mutating func clearMax() {self._max = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _min: Int64? = nil
  fileprivate var _max: Int64? = nil
}

/// DEPRECATED 1.9 - This group version of IPBlock is deprecated by networking/v1/IPBlock.
/// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24") that is allowed to the pods
/// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should
/// not be included within this rule.
struct K8s_Io_Api_Extensions_V1beta1_IPBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CIDR is a string representing the IP Block
  /// Valid examples are "192.168.1.1/24"
  var cidr: String {
    get {return _cidr ?? String()}
    set {_cidr = newValue}
  }
  /// Returns true if `cidr` has been explicitly set.
  var hasCidr: Bool {return self._cidr != nil}
  /// Clears the value of `cidr`. Subsequent reads from it will return its default value.
  mutating func clearCidr() {self._cidr = nil}

  /// Except is a slice of CIDRs that should not be included within an IP Block
  /// Valid examples are "192.168.1.1/24"
  /// Except values will be rejected if they are outside the CIDR range
  /// +optional
  var except: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cidr: String? = nil
}

/// Ingress is a collection of rules that allow inbound connections to reach the
/// endpoints defined by a backend. An Ingress can be configured to give services
/// externally-reachable urls, load balance traffic, terminate SSL, offer name
/// based virtual hosting etc.
/// DEPRECATED - This group version of Ingress is deprecated by networking.k8s.io/v1beta1 Ingress. See the release notes for more information.
struct K8s_Io_Api_Extensions_V1beta1_Ingress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is the desired state of the Ingress.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_IngressSpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_IngressSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is the current state of the Ingress.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Extensions_V1beta1_IngressStatus {
    get {return _storage._status ?? K8s_Io_Api_Extensions_V1beta1_IngressStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressBackend describes all endpoints for a given service and port.
struct K8s_Io_Api_Extensions_V1beta1_IngressBackend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the name of the referenced service.
  var serviceName: String {
    get {return _storage._serviceName ?? String()}
    set {_uniqueStorage()._serviceName = newValue}
  }
  /// Returns true if `serviceName` has been explicitly set.
  var hasServiceName: Bool {return _storage._serviceName != nil}
  /// Clears the value of `serviceName`. Subsequent reads from it will return its default value.
  mutating func clearServiceName() {_uniqueStorage()._serviceName = nil}

  /// Specifies the port of the referenced service.
  var servicePort: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._servicePort ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._servicePort = newValue}
  }
  /// Returns true if `servicePort` has been explicitly set.
  var hasServicePort: Bool {return _storage._servicePort != nil}
  /// Clears the value of `servicePort`. Subsequent reads from it will return its default value.
  mutating func clearServicePort() {_uniqueStorage()._servicePort = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressList is a collection of Ingress.
struct K8s_Io_Api_Extensions_V1beta1_IngressList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of Ingress.
  var items: [K8s_Io_Api_Extensions_V1beta1_Ingress] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressRule represents the rules mapping the paths under a specified host to
/// the related backend services. Incoming requests are first evaluated for a host
/// match, then routed to the backend associated with the matching IngressRuleValue.
struct K8s_Io_Api_Extensions_V1beta1_IngressRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Host is the fully qualified domain name of a network host, as defined
  /// by RFC 3986. Note the following deviations from the "host" part of the
  /// URI as defined in the RFC:
  /// 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the
  /// 	  IP in the Spec of the parent Ingress.
  /// 2. The `:` delimiter is not respected because ports are not allowed.
  /// 	  Currently the port of an Ingress is implicitly :80 for http and
  /// 	  :443 for https.
  /// Both these may change in the future.
  /// Incoming requests are matched against the host before the IngressRuleValue.
  /// If the host is unspecified, the Ingress routes all traffic based on the
  /// specified IngressRuleValue.
  /// +optional
  var host: String {
    get {return _storage._host ?? String()}
    set {_uniqueStorage()._host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return _storage._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {_uniqueStorage()._host = nil}

  /// IngressRuleValue represents a rule to route requests for this IngressRule.
  /// If unspecified, the rule defaults to a http catch-all. Whether that sends
  /// just traffic matching the host to the default backend or all traffic to the
  /// default backend, is left to the controller fulfilling the Ingress. Http is
  /// currently the only supported IngressRuleValue.
  /// +optional
  var ingressRuleValue: K8s_Io_Api_Extensions_V1beta1_IngressRuleValue {
    get {return _storage._ingressRuleValue ?? K8s_Io_Api_Extensions_V1beta1_IngressRuleValue()}
    set {_uniqueStorage()._ingressRuleValue = newValue}
  }
  /// Returns true if `ingressRuleValue` has been explicitly set.
  var hasIngressRuleValue: Bool {return _storage._ingressRuleValue != nil}
  /// Clears the value of `ingressRuleValue`. Subsequent reads from it will return its default value.
  mutating func clearIngressRuleValue() {_uniqueStorage()._ingressRuleValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressRuleValue represents a rule to apply against incoming requests. If the
/// rule is satisfied, the request is routed to the specified backend. Currently
/// mixing different types of rules in a single Ingress is disallowed, so exactly
/// one of the following must be set.
struct K8s_Io_Api_Extensions_V1beta1_IngressRuleValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var http: K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue {
    get {return _storage._http ?? K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue()}
    set {_uniqueStorage()._http = newValue}
  }
  /// Returns true if `http` has been explicitly set.
  var hasHTTP: Bool {return _storage._http != nil}
  /// Clears the value of `http`. Subsequent reads from it will return its default value.
  mutating func clearHTTP() {_uniqueStorage()._http = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressSpec describes the Ingress the user wishes to exist.
struct K8s_Io_Api_Extensions_V1beta1_IngressSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A default backend capable of servicing requests that don't match any
  /// rule. At least one of 'backend' or 'rules' must be specified. This field
  /// is optional to allow the loadbalancer controller or defaulting logic to
  /// specify a global default.
  /// +optional
  var backend: K8s_Io_Api_Extensions_V1beta1_IngressBackend {
    get {return _storage._backend ?? K8s_Io_Api_Extensions_V1beta1_IngressBackend()}
    set {_uniqueStorage()._backend = newValue}
  }
  /// Returns true if `backend` has been explicitly set.
  var hasBackend: Bool {return _storage._backend != nil}
  /// Clears the value of `backend`. Subsequent reads from it will return its default value.
  mutating func clearBackend() {_uniqueStorage()._backend = nil}

  /// TLS configuration. Currently the Ingress only supports a single TLS
  /// port, 443. If multiple members of this list specify different hosts, they
  /// will be multiplexed on the same port according to the hostname specified
  /// through the SNI TLS extension, if the ingress controller fulfilling the
  /// ingress supports SNI.
  /// +optional
  var tls: [K8s_Io_Api_Extensions_V1beta1_IngressTLS] {
    get {return _storage._tls}
    set {_uniqueStorage()._tls = newValue}
  }

  /// A list of host rules used to configure the Ingress. If unspecified, or
  /// no rule matches, all traffic is sent to the default backend.
  /// +optional
  var rules: [K8s_Io_Api_Extensions_V1beta1_IngressRule] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressStatus describe the current state of the Ingress.
struct K8s_Io_Api_Extensions_V1beta1_IngressStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LoadBalancer contains the current status of the load-balancer.
  /// +optional
  var loadBalancer: K8s_Io_Api_Core_V1_LoadBalancerStatus {
    get {return _storage._loadBalancer ?? K8s_Io_Api_Core_V1_LoadBalancerStatus()}
    set {_uniqueStorage()._loadBalancer = newValue}
  }
  /// Returns true if `loadBalancer` has been explicitly set.
  var hasLoadBalancer: Bool {return _storage._loadBalancer != nil}
  /// Clears the value of `loadBalancer`. Subsequent reads from it will return its default value.
  mutating func clearLoadBalancer() {_uniqueStorage()._loadBalancer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// IngressTLS describes the transport layer security associated with an Ingress.
struct K8s_Io_Api_Extensions_V1beta1_IngressTLS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hosts are a list of hosts included in the TLS certificate. The values in
  /// this list must match the name/s used in the tlsSecret. Defaults to the
  /// wildcard host setting for the loadbalancer controller fulfilling this
  /// Ingress, if left unspecified.
  /// +optional
  var hosts: [String] = []

  /// SecretName is the name of the secret used to terminate SSL traffic on 443.
  /// Field is left optional to allow SSL routing based on SNI hostname alone.
  /// If the SNI host in a listener conflicts with the "Host" header field used
  /// by an IngressRule, the SNI host is used for termination and value of the
  /// Host header is used for routing.
  /// +optional
  var secretName: String {
    get {return _secretName ?? String()}
    set {_secretName = newValue}
  }
  /// Returns true if `secretName` has been explicitly set.
  var hasSecretName: Bool {return self._secretName != nil}
  /// Clears the value of `secretName`. Subsequent reads from it will return its default value.
  mutating func clearSecretName() {self._secretName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secretName: String? = nil
}

/// DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy.
/// NetworkPolicy describes what network traffic is allowed for a set of Pods
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior for this NetworkPolicy.
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED 1.9 - This group version of NetworkPolicyEgressRule is deprecated by networking/v1/NetworkPolicyEgressRule.
/// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
/// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
/// This type is beta-level in 1.8
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of destination ports for outgoing traffic.
  /// Each item in this list is combined using a logical OR. If this field is
  /// empty or missing, this rule matches all ports (traffic not restricted by port).
  /// If this field is present and contains at least one item, then this rule allows
  /// traffic only if the traffic matches at least one port in the list.
  /// +optional
  var ports: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort] = []

  /// List of destinations for outgoing traffic of pods selected for this rule.
  /// Items in this list are combined using a logical OR operation. If this field is
  /// empty or missing, this rule matches all destinations (traffic not restricted by
  /// destination). If this field is present and contains at least one item, this rule
  /// allows traffic only if the traffic matches at least one item in the to list.
  /// +optional
  var to: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DEPRECATED 1.9 - This group version of NetworkPolicyIngressRule is deprecated by networking/v1/NetworkPolicyIngressRule.
/// This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of ports which should be made accessible on the pods selected for this rule.
  /// Each item in this list is combined using a logical OR.
  /// If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
  /// If this field is present and contains at least one item, then this rule allows traffic
  /// only if the traffic matches at least one port in the list.
  /// +optional
  var ports: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort] = []

  /// List of sources which should be able to access the pods selected for this rule.
  /// Items in this list are combined using a logical OR operation.
  /// If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
  /// If this field is present and contains at least one item, this rule allows traffic only if the
  /// traffic matches at least one item in the from list.
  /// +optional
  var from: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList.
/// Network Policy List is a list of NetworkPolicy objects.
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of schema objects.
  var items: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicy] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED 1.9 - This group version of NetworkPolicyPeer is deprecated by networking/v1/NetworkPolicyPeer.
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is a label selector which selects Pods. This field follows standard label
  /// selector semantics; if present but empty, it selects all pods.
  ///
  /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
  /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  /// Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
  /// +optional
  var podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._podSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._podSelector = newValue}
  }
  /// Returns true if `podSelector` has been explicitly set.
  var hasPodSelector: Bool {return _storage._podSelector != nil}
  /// Clears the value of `podSelector`. Subsequent reads from it will return its default value.
  mutating func clearPodSelector() {_uniqueStorage()._podSelector = nil}

  /// Selects Namespaces using cluster-scoped labels. This field follows standard label
  /// selector semantics; if present but empty, it selects all namespaces.
  ///
  /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
  /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  /// Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
  /// +optional
  var namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._namespaceSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._namespaceSelector = newValue}
  }
  /// Returns true if `namespaceSelector` has been explicitly set.
  var hasNamespaceSelector: Bool {return _storage._namespaceSelector != nil}
  /// Clears the value of `namespaceSelector`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceSelector() {_uniqueStorage()._namespaceSelector = nil}

  /// IPBlock defines policy on a particular IPBlock. If this field is set then
  /// neither of the other fields can be.
  /// +optional
  var ipBlock: K8s_Io_Api_Extensions_V1beta1_IPBlock {
    get {return _storage._ipBlock ?? K8s_Io_Api_Extensions_V1beta1_IPBlock()}
    set {_uniqueStorage()._ipBlock = newValue}
  }
  /// Returns true if `ipBlock` has been explicitly set.
  var hasIpBlock: Bool {return _storage._ipBlock != nil}
  /// Clears the value of `ipBlock`. Subsequent reads from it will return its default value.
  mutating func clearIpBlock() {_uniqueStorage()._ipBlock = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED 1.9 - This group version of NetworkPolicyPort is deprecated by networking/v1/NetworkPolicyPort.
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  The protocol (TCP, UDP, or SCTP) which traffic must match.
  /// If not specified, this field defaults to TCP.
  /// +optional
  var `protocol`: String {
    get {return _storage._protocol ?? String()}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return _storage._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {_uniqueStorage()._protocol = nil}

  /// If specified, the port on the given protocol.  This can
  /// either be a numerical or named port on a pod.  If this field is not provided,
  /// this matches all port names and numbers.
  /// If present, only traffic on the specified protocol AND port
  /// will be matched.
  /// +optional
  var port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._port ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return _storage._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {_uniqueStorage()._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED 1.9 - This group version of NetworkPolicySpec is deprecated by networking/v1/NetworkPolicySpec.
struct K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
  /// is applied to any pods selected by this field. Multiple network policies can select the
  /// same set of pods.  In this case, the ingress rules for each are combined additively.
  /// This field is NOT optional and follows standard label selector semantics.
  /// An empty podSelector matches all pods in this namespace.
  var podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._podSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._podSelector = newValue}
  }
  /// Returns true if `podSelector` has been explicitly set.
  var hasPodSelector: Bool {return _storage._podSelector != nil}
  /// Clears the value of `podSelector`. Subsequent reads from it will return its default value.
  mutating func clearPodSelector() {_uniqueStorage()._podSelector = nil}

  /// List of ingress rules to be applied to the selected pods.
  /// Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
  /// OR if the traffic source is the pod's local node,
  /// OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
  /// objects whose podSelector matches the pod.
  /// If this field is empty then this NetworkPolicy does not allow any traffic
  /// (and serves solely to ensure that the pods it selects are isolated by default).
  /// +optional
  var ingress: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule] {
    get {return _storage._ingress}
    set {_uniqueStorage()._ingress = newValue}
  }

  /// List of egress rules to be applied to the selected pods. Outgoing traffic is
  /// allowed if there are no NetworkPolicies selecting the pod (and cluster policy
  /// otherwise allows the traffic), OR if the traffic matches at least one egress rule
  /// across all of the NetworkPolicy objects whose podSelector matches the pod. If
  /// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
  /// solely to ensure that the pods it selects are isolated by default).
  /// This field is beta-level in 1.8
  /// +optional
  var egress: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule] {
    get {return _storage._egress}
    set {_uniqueStorage()._egress = newValue}
  }

  /// List of rule types that the NetworkPolicy relates to.
  /// Valid options are "Ingress", "Egress", or "Ingress,Egress".
  /// If this field is not specified, it will default based on the existence of Ingress or Egress rules;
  /// policies that contain an Egress section are assumed to affect Egress, and all policies
  /// (whether or not they contain an Ingress section) are assumed to affect Ingress.
  /// If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
  /// Likewise, if you want to write a policy that specifies that no egress is allowed,
  /// you must specify a policyTypes value that include "Egress" (since such a policy would not include
  /// an Egress section and would otherwise default to just [ "Ingress" ]).
  /// This field is beta-level in 1.8
  /// +optional
  var policyTypes: [String] {
    get {return _storage._policyTypes}
    set {_uniqueStorage()._policyTypes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSecurityPolicy governs the ability to make requests that affect the Security Context
/// that will be applied to a pod and container.
/// Deprecated: use PodSecurityPolicy from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// spec defines the policy enforced.
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
/// Deprecated: use PodSecurityPolicyList from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// items is a list of schema objects.
  var items: [K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSecurityPolicySpec defines the policy enforced.
/// Deprecated: use PodSecurityPolicySpec from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// privileged determines if a pod can request to be run as privileged.
  /// +optional
  var privileged: Bool {
    get {return _storage._privileged ?? false}
    set {_uniqueStorage()._privileged = newValue}
  }
  /// Returns true if `privileged` has been explicitly set.
  var hasPrivileged: Bool {return _storage._privileged != nil}
  /// Clears the value of `privileged`. Subsequent reads from it will return its default value.
  mutating func clearPrivileged() {_uniqueStorage()._privileged = nil}

  /// defaultAddCapabilities is the default set of capabilities that will be added to the container
  /// unless the pod spec specifically drops the capability.  You may not list a capability in both
  /// defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
  /// allowed, and need not be included in the allowedCapabilities list.
  /// +optional
  var defaultAddCapabilities: [String] {
    get {return _storage._defaultAddCapabilities}
    set {_uniqueStorage()._defaultAddCapabilities = newValue}
  }

  /// requiredDropCapabilities are the capabilities that will be dropped from the container.  These
  /// are required to be dropped and cannot be added.
  /// +optional
  var requiredDropCapabilities: [String] {
    get {return _storage._requiredDropCapabilities}
    set {_uniqueStorage()._requiredDropCapabilities = newValue}
  }

  /// allowedCapabilities is a list of capabilities that can be requested to add to the container.
  /// Capabilities in this field may be added at the pod author's discretion.
  /// You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
  /// +optional
  var allowedCapabilities: [String] {
    get {return _storage._allowedCapabilities}
    set {_uniqueStorage()._allowedCapabilities = newValue}
  }

  /// volumes is a white list of allowed volume plugins. Empty indicates that
  /// no volumes may be used. To allow all volumes you may use '*'.
  /// +optional
  var volumes: [String] {
    get {return _storage._volumes}
    set {_uniqueStorage()._volumes = newValue}
  }

  /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
  /// +optional
  var hostNetwork: Bool {
    get {return _storage._hostNetwork ?? false}
    set {_uniqueStorage()._hostNetwork = newValue}
  }
  /// Returns true if `hostNetwork` has been explicitly set.
  var hasHostNetwork: Bool {return _storage._hostNetwork != nil}
  /// Clears the value of `hostNetwork`. Subsequent reads from it will return its default value.
  mutating func clearHostNetwork() {_uniqueStorage()._hostNetwork = nil}

  /// hostPorts determines which host port ranges are allowed to be exposed.
  /// +optional
  var hostPorts: [K8s_Io_Api_Extensions_V1beta1_HostPortRange] {
    get {return _storage._hostPorts}
    set {_uniqueStorage()._hostPorts = newValue}
  }

  /// hostPID determines if the policy allows the use of HostPID in the pod spec.
  /// +optional
  var hostPid: Bool {
    get {return _storage._hostPid ?? false}
    set {_uniqueStorage()._hostPid = newValue}
  }
  /// Returns true if `hostPid` has been explicitly set.
  var hasHostPid: Bool {return _storage._hostPid != nil}
  /// Clears the value of `hostPid`. Subsequent reads from it will return its default value.
  mutating func clearHostPid() {_uniqueStorage()._hostPid = nil}

  /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
  /// +optional
  var hostIpc: Bool {
    get {return _storage._hostIpc ?? false}
    set {_uniqueStorage()._hostIpc = newValue}
  }
  /// Returns true if `hostIpc` has been explicitly set.
  var hasHostIpc: Bool {return _storage._hostIpc != nil}
  /// Clears the value of `hostIpc`. Subsequent reads from it will return its default value.
  mutating func clearHostIpc() {_uniqueStorage()._hostIpc = nil}

  /// seLinux is the strategy that will dictate the allowable labels that may be set.
  var seLinux: K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions {
    get {return _storage._seLinux ?? K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions()}
    set {_uniqueStorage()._seLinux = newValue}
  }
  /// Returns true if `seLinux` has been explicitly set.
  var hasSeLinux: Bool {return _storage._seLinux != nil}
  /// Clears the value of `seLinux`. Subsequent reads from it will return its default value.
  mutating func clearSeLinux() {_uniqueStorage()._seLinux = nil}

  /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
  var runAsUser: K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions {
    get {return _storage._runAsUser ?? K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions()}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
  /// If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
  /// RunAsGroup feature gate to be enabled.
  /// +optional
  var runAsGroup: K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions {
    get {return _storage._runAsGroup ?? K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions()}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
  var supplementalGroups: K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions {
    get {return _storage._supplementalGroups ?? K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions()}
    set {_uniqueStorage()._supplementalGroups = newValue}
  }
  /// Returns true if `supplementalGroups` has been explicitly set.
  var hasSupplementalGroups: Bool {return _storage._supplementalGroups != nil}
  /// Clears the value of `supplementalGroups`. Subsequent reads from it will return its default value.
  mutating func clearSupplementalGroups() {_uniqueStorage()._supplementalGroups = nil}

  /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
  var fsGroup: K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions {
    get {return _storage._fsGroup ?? K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions()}
    set {_uniqueStorage()._fsGroup = newValue}
  }
  /// Returns true if `fsGroup` has been explicitly set.
  var hasFsGroup: Bool {return _storage._fsGroup != nil}
  /// Clears the value of `fsGroup`. Subsequent reads from it will return its default value.
  mutating func clearFsGroup() {_uniqueStorage()._fsGroup = nil}

  /// readOnlyRootFilesystem when set to true will force containers to run with a read only root file
  /// system.  If the container specifically requests to run with a non-read only root file system
  /// the PSP should deny the pod.
  /// If set to false the container may run with a read only root file system if it wishes but it
  /// will not be forced to.
  /// +optional
  var readOnlyRootFilesystem: Bool {
    get {return _storage._readOnlyRootFilesystem ?? false}
    set {_uniqueStorage()._readOnlyRootFilesystem = newValue}
  }
  /// Returns true if `readOnlyRootFilesystem` has been explicitly set.
  var hasReadOnlyRootFilesystem: Bool {return _storage._readOnlyRootFilesystem != nil}
  /// Clears the value of `readOnlyRootFilesystem`. Subsequent reads from it will return its default value.
  mutating func clearReadOnlyRootFilesystem() {_uniqueStorage()._readOnlyRootFilesystem = nil}

  /// defaultAllowPrivilegeEscalation controls the default setting for whether a
  /// process can gain more privileges than its parent process.
  /// +optional
  var defaultAllowPrivilegeEscalation: Bool {
    get {return _storage._defaultAllowPrivilegeEscalation ?? false}
    set {_uniqueStorage()._defaultAllowPrivilegeEscalation = newValue}
  }
  /// Returns true if `defaultAllowPrivilegeEscalation` has been explicitly set.
  var hasDefaultAllowPrivilegeEscalation: Bool {return _storage._defaultAllowPrivilegeEscalation != nil}
  /// Clears the value of `defaultAllowPrivilegeEscalation`. Subsequent reads from it will return its default value.
  mutating func clearDefaultAllowPrivilegeEscalation() {_uniqueStorage()._defaultAllowPrivilegeEscalation = nil}

  /// allowPrivilegeEscalation determines if a pod can request to allow
  /// privilege escalation. If unspecified, defaults to true.
  /// +optional
  var allowPrivilegeEscalation: Bool {
    get {return _storage._allowPrivilegeEscalation ?? false}
    set {_uniqueStorage()._allowPrivilegeEscalation = newValue}
  }
  /// Returns true if `allowPrivilegeEscalation` has been explicitly set.
  var hasAllowPrivilegeEscalation: Bool {return _storage._allowPrivilegeEscalation != nil}
  /// Clears the value of `allowPrivilegeEscalation`. Subsequent reads from it will return its default value.
  mutating func clearAllowPrivilegeEscalation() {_uniqueStorage()._allowPrivilegeEscalation = nil}

  /// allowedHostPaths is a white list of allowed host paths. Empty indicates
  /// that all host paths may be used.
  /// +optional
  var allowedHostPaths: [K8s_Io_Api_Extensions_V1beta1_AllowedHostPath] {
    get {return _storage._allowedHostPaths}
    set {_uniqueStorage()._allowedHostPaths = newValue}
  }

  /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all
  /// Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
  /// is allowed in the "volumes" field.
  /// +optional
  var allowedFlexVolumes: [K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume] {
    get {return _storage._allowedFlexVolumes}
    set {_uniqueStorage()._allowedFlexVolumes = newValue}
  }

  /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
  /// An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
  /// +optional
  var allowedCsidrivers: [K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver] {
    get {return _storage._allowedCsidrivers}
    set {_uniqueStorage()._allowedCsidrivers = newValue}
  }

  /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
  /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
  /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
  /// Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
  ///
  /// Examples:
  /// e.g. "foo/*" allows "foo/bar", "foo/baz", etc.
  /// e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
  /// +optional
  var allowedUnsafeSysctls: [String] {
    get {return _storage._allowedUnsafeSysctls}
    set {_uniqueStorage()._allowedUnsafeSysctls = newValue}
  }

  /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
  /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
  /// as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
  ///
  /// Examples:
  /// e.g. "foo/*" forbids "foo/bar", "foo/baz", etc.
  /// e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
  /// +optional
  var forbiddenSysctls: [String] {
    get {return _storage._forbiddenSysctls}
    set {_uniqueStorage()._forbiddenSysctls = newValue}
  }

  /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes.
  /// Empty or nil indicates that only the DefaultProcMountType may be used.
  /// This requires the ProcMountType feature flag to be enabled.
  /// +optional
  var allowedProcMountTypes: [String] {
    get {return _storage._allowedProcMountTypes}
    set {_uniqueStorage()._allowedProcMountTypes = newValue}
  }

  /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
  /// If this field is omitted, the pod's runtimeClassName field is unrestricted.
  /// Enforcement of this field depends on the RuntimeClass feature gate being enabled.
  /// +optional
  var runtimeClass: K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions {
    get {return _storage._runtimeClass ?? K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions()}
    set {_uniqueStorage()._runtimeClass = newValue}
  }
  /// Returns true if `runtimeClass` has been explicitly set.
  var hasRuntimeClass: Bool {return _storage._runtimeClass != nil}
  /// Clears the value of `runtimeClass`. Subsequent reads from it will return its default value.
  mutating func clearRuntimeClass() {_uniqueStorage()._runtimeClass = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for
/// more information.
/// ReplicaSet ensures that a specified number of pod replicas are running at any given time.
struct K8s_Io_Api_Extensions_V1beta1_ReplicaSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the Labels of a ReplicaSet are empty, they are defaulted to
  /// be the same as the Pod(s) that the ReplicaSet manages.
  /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the specification of the desired behavior of the ReplicaSet.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is the most recently observed status of the ReplicaSet.
  /// This data may be out of date by some window of time.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus {
    get {return _storage._status ?? K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicaSetCondition describes the state of a replica set at a certain point.
struct K8s_Io_Api_Extensions_V1beta1_ReplicaSetCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of replica set condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicaSetList is a collection of ReplicaSets.
struct K8s_Io_Api_Extensions_V1beta1_ReplicaSetList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of ReplicaSets.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
  var items: [K8s_Io_Api_Extensions_V1beta1_ReplicaSet] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicaSetSpec is the specification of a ReplicaSet.
struct K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Replicas is the number of desired replicas.
  /// This is a pointer to distinguish between explicit zero and unspecified.
  /// Defaults to 1.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
  /// +optional
  var replicas: Int32 {
    get {return _storage._replicas ?? 0}
    set {_uniqueStorage()._replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return _storage._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {_uniqueStorage()._replicas = nil}

  /// Minimum number of seconds for which a newly created pod should be ready
  /// without any of its container crashing, for it to be considered available.
  /// Defaults to 0 (pod will be considered available as soon as it is ready)
  /// +optional
  var minReadySeconds: Int32 {
    get {return _storage._minReadySeconds ?? 0}
    set {_uniqueStorage()._minReadySeconds = newValue}
  }
  /// Returns true if `minReadySeconds` has been explicitly set.
  var hasMinReadySeconds: Bool {return _storage._minReadySeconds != nil}
  /// Clears the value of `minReadySeconds`. Subsequent reads from it will return its default value.
  mutating func clearMinReadySeconds() {_uniqueStorage()._minReadySeconds = nil}

  /// Selector is a label query over pods that should match the replica count.
  /// If the selector is empty, it is defaulted to the labels present on the pod template.
  /// Label keys and values that must match in order to be controlled by this replica set.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// Template is the object that describes the pod that will be created if
  /// insufficient replicas are detected.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  /// +optional
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicaSetStatus represents the current status of a ReplicaSet.
struct K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Replicas is the most recently oberved number of replicas.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// The number of pods that have labels matching the labels of the pod template of the replicaset.
  /// +optional
  var fullyLabeledReplicas: Int32 {
    get {return _fullyLabeledReplicas ?? 0}
    set {_fullyLabeledReplicas = newValue}
  }
  /// Returns true if `fullyLabeledReplicas` has been explicitly set.
  var hasFullyLabeledReplicas: Bool {return self._fullyLabeledReplicas != nil}
  /// Clears the value of `fullyLabeledReplicas`. Subsequent reads from it will return its default value.
  mutating func clearFullyLabeledReplicas() {self._fullyLabeledReplicas = nil}

  /// The number of ready replicas for this replica set.
  /// +optional
  var readyReplicas: Int32 {
    get {return _readyReplicas ?? 0}
    set {_readyReplicas = newValue}
  }
  /// Returns true if `readyReplicas` has been explicitly set.
  var hasReadyReplicas: Bool {return self._readyReplicas != nil}
  /// Clears the value of `readyReplicas`. Subsequent reads from it will return its default value.
  mutating func clearReadyReplicas() {self._readyReplicas = nil}

  /// The number of available replicas (ready for at least minReadySeconds) for this replica set.
  /// +optional
  var availableReplicas: Int32 {
    get {return _availableReplicas ?? 0}
    set {_availableReplicas = newValue}
  }
  /// Returns true if `availableReplicas` has been explicitly set.
  var hasAvailableReplicas: Bool {return self._availableReplicas != nil}
  /// Clears the value of `availableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearAvailableReplicas() {self._availableReplicas = nil}

  /// ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// Represents the latest available observations of a replica set's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Extensions_V1beta1_ReplicaSetCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
  fileprivate var _fullyLabeledReplicas: Int32? = nil
  fileprivate var _readyReplicas: Int32? = nil
  fileprivate var _availableReplicas: Int32? = nil
  fileprivate var _observedGeneration: Int64? = nil
}

/// Dummy definition
struct K8s_Io_Api_Extensions_V1beta1_ReplicationControllerDummy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DEPRECATED.
struct K8s_Io_Api_Extensions_V1beta1_RollbackConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The revision to rollback to. If set to 0, rollback to the last revision.
  /// +optional
  var revision: Int64 {
    get {return _revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _revision: Int64? = nil
}

/// Spec to control the desired behavior of daemon set rolling update.
struct K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of DaemonSet pods that can be unavailable during the
  /// update. Value can be an absolute number (ex: 5) or a percentage of total
  /// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
  /// number is calculated from percentage by rounding up.
  /// This cannot be 0.
  /// Default value is 1.
  /// Example: when this is set to 30%, at most 30% of the total number of nodes
  /// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
  /// can have their pods stopped for an update at any given
  /// time. The update starts by stopping at most 30% of those DaemonSet pods
  /// and then brings up new DaemonSet pods in their place. Once the new pods
  /// are available, it then proceeds onto other DaemonSet pods, thus ensuring
  /// that at least 70% of original number of DaemonSet pods are available at
  /// all times during the update.
  /// +optional
  var maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxUnavailable ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxUnavailable = newValue}
  }
  /// Returns true if `maxUnavailable` has been explicitly set.
  var hasMaxUnavailable: Bool {return _storage._maxUnavailable != nil}
  /// Clears the value of `maxUnavailable`. Subsequent reads from it will return its default value.
  mutating func clearMaxUnavailable() {_uniqueStorage()._maxUnavailable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Spec to control the desired behavior of rolling update.
struct K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of pods that can be unavailable during the update.
  /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  /// Absolute number is calculated from percentage by rounding down.
  /// This can not be 0 if MaxSurge is 0.
  /// By default, a fixed value of 1 is used.
  /// Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
  /// immediately when the rolling update starts. Once new pods are ready, old RC
  /// can be scaled down further, followed by scaling up the new RC, ensuring
  /// that the total number of pods available at all times during the update is at
  /// least 70% of desired pods.
  /// +optional
  var maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxUnavailable ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxUnavailable = newValue}
  }
  /// Returns true if `maxUnavailable` has been explicitly set.
  var hasMaxUnavailable: Bool {return _storage._maxUnavailable != nil}
  /// Clears the value of `maxUnavailable`. Subsequent reads from it will return its default value.
  mutating func clearMaxUnavailable() {_uniqueStorage()._maxUnavailable = nil}

  /// The maximum number of pods that can be scheduled above the desired number of
  /// pods.
  /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  /// This can not be 0 if MaxUnavailable is 0.
  /// Absolute number is calculated from percentage by rounding up.
  /// By default, a value of 1 is used.
  /// Example: when this is set to 30%, the new RC can be scaled up immediately when
  /// the rolling update starts, such that the total number of old and new pods do not exceed
  /// 130% of desired pods. Once old pods have been killed,
  /// new RC can be scaled up further, ensuring that total number of pods running
  /// at any time during the update is at most 130% of desired pods.
  /// +optional
  var maxSurge: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxSurge ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxSurge = newValue}
  }
  /// Returns true if `maxSurge` has been explicitly set.
  var hasMaxSurge: Bool {return _storage._maxSurge != nil}
  /// Clears the value of `maxSurge`. Subsequent reads from it will return its default value.
  mutating func clearMaxSurge() {_uniqueStorage()._maxSurge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy.
/// Deprecated: use RunAsGroupStrategyOptions from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
  /// then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Extensions_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
/// Deprecated: use RunAsUserStrategyOptions from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
  /// then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Extensions_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses
/// for a pod.
struct K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a pod.
  /// A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
  /// list. An empty list requires the RuntimeClassName field to be unset.
  var allowedRuntimeClassNames: [String] = []

  /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
  /// The default MUST be allowed by the allowedRuntimeClassNames list.
  /// A value of nil does not mutate the Pod.
  /// +optional
  var defaultRuntimeClassName: String {
    get {return _defaultRuntimeClassName ?? String()}
    set {_defaultRuntimeClassName = newValue}
  }
  /// Returns true if `defaultRuntimeClassName` has been explicitly set.
  var hasDefaultRuntimeClassName: Bool {return self._defaultRuntimeClassName != nil}
  /// Clears the value of `defaultRuntimeClassName`. Subsequent reads from it will return its default value.
  mutating func clearDefaultRuntimeClassName() {self._defaultRuntimeClassName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultRuntimeClassName: String? = nil
}

/// SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
/// Deprecated: use SELinuxStrategyOptions from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable labels that may be set.
  var rule: String {
    get {return _storage._rule ?? String()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {_uniqueStorage()._rule = nil}

  /// seLinuxOptions required to run as; required for MustRunAs
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  /// +optional
  var seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions {
    get {return _storage._seLinuxOptions ?? K8s_Io_Api_Core_V1_SELinuxOptions()}
    set {_uniqueStorage()._seLinuxOptions = newValue}
  }
  /// Returns true if `seLinuxOptions` has been explicitly set.
  var hasSeLinuxOptions: Bool {return _storage._seLinuxOptions != nil}
  /// Clears the value of `seLinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSeLinuxOptions() {_uniqueStorage()._seLinuxOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// represents a scaling request for a resource.
struct K8s_Io_Api_Extensions_V1beta1_Scale {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
  /// +optional
  var spec: K8s_Io_Api_Extensions_V1beta1_ScaleSpec {
    get {return _storage._spec ?? K8s_Io_Api_Extensions_V1beta1_ScaleSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
  /// +optional
  var status: K8s_Io_Api_Extensions_V1beta1_ScaleStatus {
    get {return _storage._status ?? K8s_Io_Api_Extensions_V1beta1_ScaleStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// describes the attributes of a scale subresource
struct K8s_Io_Api_Extensions_V1beta1_ScaleSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// desired number of instances for the scaled object.
  /// +optional
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
}

/// represents the current status of a scale subresource.
struct K8s_Io_Api_Extensions_V1beta1_ScaleStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// actual number of observed instances of the scaled object.
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// label query over pods that should match the replicas count. More info: http://kubernetes.io/docs/user-guide/labels#label-selectors
  /// +optional
  var selector: Dictionary<String,String> = [:]

  /// label selector for pods that should match the replicas count. This is a serializated
  /// version of both map-based and more expressive set-based selectors. This is done to
  /// avoid introspection in the clients. The string will be in the same format as the
  /// query-param syntax. If the target type only supports map-based selectors, both this
  /// field and map-based selector field are populated.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var targetSelector: String {
    get {return _targetSelector ?? String()}
    set {_targetSelector = newValue}
  }
  /// Returns true if `targetSelector` has been explicitly set.
  var hasTargetSelector: Bool {return self._targetSelector != nil}
  /// Clears the value of `targetSelector`. Subsequent reads from it will return its default value.
  mutating func clearTargetSelector() {self._targetSelector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
  fileprivate var _targetSelector: String? = nil
}

/// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
/// Deprecated: use SupplementalGroupsStrategyOptions from policy API Group instead.
struct K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
  /// +optional
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of supplemental groups.  If you would like to force a single
  /// supplemental group then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Extensions_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.extensions.v1beta1"

extension K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedCSIDriver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver, rhs: K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedFlexVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._driver)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._driver {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume, rhs: K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume) -> Bool {
    if lhs._driver != rhs._driver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_AllowedHostPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedHostPath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pathPrefix"),
    2: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pathPrefix)
      case 2: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pathPrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_AllowedHostPath, rhs: K8s_Io_Api_Extensions_V1beta1_AllowedHostPath) -> Bool {
    if lhs._pathPrefix != rhs._pathPrefix {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec? = nil
    var _status: K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSet, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSetCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSetCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetCondition, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSetList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSetList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_DaemonSet] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetList, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSetSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
    2: .same(proto: "template"),
    3: .same(proto: "updateStrategy"),
    4: .same(proto: "minReadySeconds"),
    5: .same(proto: "templateGeneration"),
    6: .same(proto: "revisionHistoryLimit"),
  ]

  fileprivate class _StorageClass {
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil
    var _updateStrategy: K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy? = nil
    var _minReadySeconds: Int32? = nil
    var _templateGeneration: Int64? = nil
    var _revisionHistoryLimit: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _selector = source._selector
      _template = source._template
      _updateStrategy = source._updateStrategy
      _minReadySeconds = source._minReadySeconds
      _templateGeneration = source._templateGeneration
      _revisionHistoryLimit = source._revisionHistoryLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._updateStrategy)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._minReadySeconds)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._templateGeneration)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._revisionHistoryLimit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._updateStrategy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._minReadySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._templateGeneration {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._revisionHistoryLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        if _storage._updateStrategy != rhs_storage._updateStrategy {return false}
        if _storage._minReadySeconds != rhs_storage._minReadySeconds {return false}
        if _storage._templateGeneration != rhs_storage._templateGeneration {return false}
        if _storage._revisionHistoryLimit != rhs_storage._revisionHistoryLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSetStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentNumberScheduled"),
    2: .same(proto: "numberMisscheduled"),
    3: .same(proto: "desiredNumberScheduled"),
    4: .same(proto: "numberReady"),
    5: .same(proto: "observedGeneration"),
    6: .same(proto: "updatedNumberScheduled"),
    7: .same(proto: "numberAvailable"),
    8: .same(proto: "numberUnavailable"),
    9: .same(proto: "collisionCount"),
    10: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._currentNumberScheduled)
      case 2: try decoder.decodeSingularInt32Field(value: &self._numberMisscheduled)
      case 3: try decoder.decodeSingularInt32Field(value: &self._desiredNumberScheduled)
      case 4: try decoder.decodeSingularInt32Field(value: &self._numberReady)
      case 5: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 6: try decoder.decodeSingularInt32Field(value: &self._updatedNumberScheduled)
      case 7: try decoder.decodeSingularInt32Field(value: &self._numberAvailable)
      case 8: try decoder.decodeSingularInt32Field(value: &self._numberUnavailable)
      case 9: try decoder.decodeSingularInt32Field(value: &self._collisionCount)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._currentNumberScheduled {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._numberMisscheduled {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._desiredNumberScheduled {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._numberReady {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._updatedNumberScheduled {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._numberAvailable {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._numberUnavailable {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._collisionCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetStatus) -> Bool {
    if lhs._currentNumberScheduled != rhs._currentNumberScheduled {return false}
    if lhs._numberMisscheduled != rhs._numberMisscheduled {return false}
    if lhs._desiredNumberScheduled != rhs._desiredNumberScheduled {return false}
    if lhs._numberReady != rhs._numberReady {return false}
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs._updatedNumberScheduled != rhs._updatedNumberScheduled {return false}
    if lhs._numberAvailable != rhs._numberAvailable {return false}
    if lhs._numberUnavailable != rhs._numberUnavailable {return false}
    if lhs._collisionCount != rhs._collisionCount {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonSetUpdateStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rollingUpdate"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _rollingUpdate: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rollingUpdate = source._rollingUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rollingUpdate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rollingUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy, rhs: K8s_Io_Api_Extensions_V1beta1_DaemonSetUpdateStrategy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rollingUpdate != rhs_storage._rollingUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_Deployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deployment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_DeploymentSpec? = nil
    var _status: K8s_Io_Api_Extensions_V1beta1_DeploymentStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_Deployment, rhs: K8s_Io_Api_Extensions_V1beta1_Deployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    6: .same(proto: "lastUpdateTime"),
    7: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastUpdateTime = source._lastUpdateTime
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._lastUpdateTime)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._lastUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentCondition, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_Deployment] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentList, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentRollback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentRollback"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "updatedAnnotations"),
    3: .same(proto: "rollbackTo"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _updatedAnnotations: Dictionary<String,String> = [:]
    var _rollbackTo: K8s_Io_Api_Extensions_V1beta1_RollbackConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _updatedAnnotations = source._updatedAnnotations
      _rollbackTo = source._rollbackTo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._updatedAnnotations)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._rollbackTo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._updatedAnnotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._updatedAnnotations, fieldNumber: 2)
      }
      if let v = _storage._rollbackTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentRollback, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentRollback) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._updatedAnnotations != rhs_storage._updatedAnnotations {return false}
        if _storage._rollbackTo != rhs_storage._rollbackTo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "selector"),
    3: .same(proto: "template"),
    4: .same(proto: "strategy"),
    5: .same(proto: "minReadySeconds"),
    6: .same(proto: "revisionHistoryLimit"),
    7: .same(proto: "paused"),
    8: .same(proto: "rollbackTo"),
    9: .same(proto: "progressDeadlineSeconds"),
  ]

  fileprivate class _StorageClass {
    var _replicas: Int32? = nil
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil
    var _strategy: K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy? = nil
    var _minReadySeconds: Int32? = nil
    var _revisionHistoryLimit: Int32? = nil
    var _paused: Bool? = nil
    var _rollbackTo: K8s_Io_Api_Extensions_V1beta1_RollbackConfig? = nil
    var _progressDeadlineSeconds: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicas = source._replicas
      _selector = source._selector
      _template = source._template
      _strategy = source._strategy
      _minReadySeconds = source._minReadySeconds
      _revisionHistoryLimit = source._revisionHistoryLimit
      _paused = source._paused
      _rollbackTo = source._rollbackTo
      _progressDeadlineSeconds = source._progressDeadlineSeconds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._replicas)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._strategy)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._minReadySeconds)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._revisionHistoryLimit)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._paused)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._rollbackTo)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._progressDeadlineSeconds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._strategy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._minReadySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._revisionHistoryLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._paused {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._rollbackTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._progressDeadlineSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentSpec, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._minReadySeconds != rhs_storage._minReadySeconds {return false}
        if _storage._revisionHistoryLimit != rhs_storage._revisionHistoryLimit {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._rollbackTo != rhs_storage._rollbackTo {return false}
        if _storage._progressDeadlineSeconds != rhs_storage._progressDeadlineSeconds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observedGeneration"),
    2: .same(proto: "replicas"),
    3: .same(proto: "updatedReplicas"),
    7: .same(proto: "readyReplicas"),
    4: .same(proto: "availableReplicas"),
    5: .same(proto: "unavailableReplicas"),
    6: .same(proto: "conditions"),
    8: .same(proto: "collisionCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 2: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 3: try decoder.decodeSingularInt32Field(value: &self._updatedReplicas)
      case 4: try decoder.decodeSingularInt32Field(value: &self._availableReplicas)
      case 5: try decoder.decodeSingularInt32Field(value: &self._unavailableReplicas)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      case 7: try decoder.decodeSingularInt32Field(value: &self._readyReplicas)
      case 8: try decoder.decodeSingularInt32Field(value: &self._collisionCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._updatedReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._availableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._unavailableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 6)
    }
    if let v = self._readyReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._collisionCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentStatus, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentStatus) -> Bool {
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs._replicas != rhs._replicas {return false}
    if lhs._updatedReplicas != rhs._updatedReplicas {return false}
    if lhs._readyReplicas != rhs._readyReplicas {return false}
    if lhs._availableReplicas != rhs._availableReplicas {return false}
    if lhs._unavailableReplicas != rhs._unavailableReplicas {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs._collisionCount != rhs._collisionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rollingUpdate"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _rollingUpdate: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rollingUpdate = source._rollingUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rollingUpdate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rollingUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy, rhs: K8s_Io_Api_Extensions_V1beta1_DeploymentStrategy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rollingUpdate != rhs_storage._rollingUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FSGroupStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_HTTPIngressPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTTPIngressPath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "backend"),
  ]

  fileprivate class _StorageClass {
    var _path: String? = nil
    var _backend: K8s_Io_Api_Extensions_V1beta1_IngressBackend? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _backend = source._backend
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._backend)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._path {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._backend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_HTTPIngressPath, rhs: K8s_Io_Api_Extensions_V1beta1_HTTPIngressPath) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._backend != rhs_storage._backend {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTTPIngressRuleValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.paths)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.paths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue, rhs: K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_HostPortRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostPortRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._min)
      case 2: try decoder.decodeSingularInt32Field(value: &self._max)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._min {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._max {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_HostPortRange, rhs: K8s_Io_Api_Extensions_V1beta1_HostPortRange) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IDRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IDRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._min)
      case 2: try decoder.decodeSingularInt64Field(value: &self._max)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._min {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._max {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IDRange, rhs: K8s_Io_Api_Extensions_V1beta1_IDRange) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IPBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IPBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cidr"),
    2: .same(proto: "except"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cidr)
      case 2: try decoder.decodeRepeatedStringField(value: &self.except)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cidr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.except.isEmpty {
      try visitor.visitRepeatedStringField(value: self.except, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IPBlock, rhs: K8s_Io_Api_Extensions_V1beta1_IPBlock) -> Bool {
    if lhs._cidr != rhs._cidr {return false}
    if lhs.except != rhs.except {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_Ingress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ingress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_IngressSpec? = nil
    var _status: K8s_Io_Api_Extensions_V1beta1_IngressStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_Ingress, rhs: K8s_Io_Api_Extensions_V1beta1_Ingress) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressBackend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressBackend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceName"),
    2: .same(proto: "servicePort"),
  ]

  fileprivate class _StorageClass {
    var _serviceName: String? = nil
    var _servicePort: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serviceName = source._serviceName
      _servicePort = source._servicePort
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._serviceName)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._servicePort)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._serviceName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._servicePort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressBackend, rhs: K8s_Io_Api_Extensions_V1beta1_IngressBackend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serviceName != rhs_storage._serviceName {return false}
        if _storage._servicePort != rhs_storage._servicePort {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_Ingress] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressList, rhs: K8s_Io_Api_Extensions_V1beta1_IngressList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "ingressRuleValue"),
  ]

  fileprivate class _StorageClass {
    var _host: String? = nil
    var _ingressRuleValue: K8s_Io_Api_Extensions_V1beta1_IngressRuleValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _host = source._host
      _ingressRuleValue = source._ingressRuleValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._host)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._ingressRuleValue)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._host {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._ingressRuleValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressRule, rhs: K8s_Io_Api_Extensions_V1beta1_IngressRule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._host != rhs_storage._host {return false}
        if _storage._ingressRuleValue != rhs_storage._ingressRuleValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressRuleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressRuleValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "http"),
  ]

  fileprivate class _StorageClass {
    var _http: K8s_Io_Api_Extensions_V1beta1_HTTPIngressRuleValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _http = source._http
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._http)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._http {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressRuleValue, rhs: K8s_Io_Api_Extensions_V1beta1_IngressRuleValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._http != rhs_storage._http {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backend"),
    2: .same(proto: "tls"),
    3: .same(proto: "rules"),
  ]

  fileprivate class _StorageClass {
    var _backend: K8s_Io_Api_Extensions_V1beta1_IngressBackend? = nil
    var _tls: [K8s_Io_Api_Extensions_V1beta1_IngressTLS] = []
    var _rules: [K8s_Io_Api_Extensions_V1beta1_IngressRule] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _backend = source._backend
      _tls = source._tls
      _rules = source._rules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._backend)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._tls)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._rules)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._backend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tls.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tls, fieldNumber: 2)
      }
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressSpec, rhs: K8s_Io_Api_Extensions_V1beta1_IngressSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._backend != rhs_storage._backend {return false}
        if _storage._tls != rhs_storage._tls {return false}
        if _storage._rules != rhs_storage._rules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loadBalancer"),
  ]

  fileprivate class _StorageClass {
    var _loadBalancer: K8s_Io_Api_Core_V1_LoadBalancerStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _loadBalancer = source._loadBalancer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._loadBalancer)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._loadBalancer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressStatus, rhs: K8s_Io_Api_Extensions_V1beta1_IngressStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._loadBalancer != rhs_storage._loadBalancer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_IngressTLS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IngressTLS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hosts"),
    2: .same(proto: "secretName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.hosts)
      case 2: try decoder.decodeSingularStringField(value: &self._secretName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hosts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hosts, fieldNumber: 1)
    }
    if let v = self._secretName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_IngressTLS, rhs: K8s_Io_Api_Extensions_V1beta1_IngressTLS) -> Bool {
    if lhs.hosts != rhs.hosts {return false}
    if lhs._secretName != rhs._secretName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicy, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyEgressRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
    2: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ports)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.to)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyIngressRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
    2: .same(proto: "from"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ports)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.from)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.from, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.from != rhs.from {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicy] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyList, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podSelector"),
    2: .same(proto: "namespaceSelector"),
    3: .same(proto: "ipBlock"),
  ]

  fileprivate class _StorageClass {
    var _podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _ipBlock: K8s_Io_Api_Extensions_V1beta1_IPBlock? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podSelector = source._podSelector
      _namespaceSelector = source._namespaceSelector
      _ipBlock = source._ipBlock
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podSelector)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._namespaceSelector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._ipBlock)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._namespaceSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._ipBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPeer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podSelector != rhs_storage._podSelector {return false}
        if _storage._namespaceSelector != rhs_storage._namespaceSelector {return false}
        if _storage._ipBlock != rhs_storage._ipBlock {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicyPort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protocol"),
    2: .same(proto: "port"),
  ]

  fileprivate class _StorageClass {
    var _protocol: String? = nil
    var _port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _protocol = source._protocol
      _port = source._port
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._protocol)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._port)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._protocol {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._port {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicyPort) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._port != rhs_storage._port {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkPolicySpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podSelector"),
    2: .same(proto: "ingress"),
    3: .same(proto: "egress"),
    4: .same(proto: "policyTypes"),
  ]

  fileprivate class _StorageClass {
    var _podSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _ingress: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyIngressRule] = []
    var _egress: [K8s_Io_Api_Extensions_V1beta1_NetworkPolicyEgressRule] = []
    var _policyTypes: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podSelector = source._podSelector
      _ingress = source._ingress
      _egress = source._egress
      _policyTypes = source._policyTypes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podSelector)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._ingress)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._egress)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._policyTypes)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ingress.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ingress, fieldNumber: 2)
      }
      if !_storage._egress.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._egress, fieldNumber: 3)
      }
      if !_storage._policyTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._policyTypes, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec, rhs: K8s_Io_Api_Extensions_V1beta1_NetworkPolicySpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podSelector != rhs_storage._podSelector {return false}
        if _storage._ingress != rhs_storage._ingress {return false}
        if _storage._egress != rhs_storage._egress {return false}
        if _storage._policyTypes != rhs_storage._policyTypes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy, rhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicy] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicyList, rhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicyList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicySpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privileged"),
    2: .same(proto: "defaultAddCapabilities"),
    3: .same(proto: "requiredDropCapabilities"),
    4: .same(proto: "allowedCapabilities"),
    5: .same(proto: "volumes"),
    6: .same(proto: "hostNetwork"),
    7: .same(proto: "hostPorts"),
    8: .same(proto: "hostPID"),
    9: .same(proto: "hostIPC"),
    10: .same(proto: "seLinux"),
    11: .same(proto: "runAsUser"),
    22: .same(proto: "runAsGroup"),
    12: .same(proto: "supplementalGroups"),
    13: .same(proto: "fsGroup"),
    14: .same(proto: "readOnlyRootFilesystem"),
    15: .same(proto: "defaultAllowPrivilegeEscalation"),
    16: .same(proto: "allowPrivilegeEscalation"),
    17: .same(proto: "allowedHostPaths"),
    18: .same(proto: "allowedFlexVolumes"),
    23: .same(proto: "allowedCSIDrivers"),
    19: .same(proto: "allowedUnsafeSysctls"),
    20: .same(proto: "forbiddenSysctls"),
    21: .same(proto: "allowedProcMountTypes"),
    24: .same(proto: "runtimeClass"),
  ]

  fileprivate class _StorageClass {
    var _privileged: Bool? = nil
    var _defaultAddCapabilities: [String] = []
    var _requiredDropCapabilities: [String] = []
    var _allowedCapabilities: [String] = []
    var _volumes: [String] = []
    var _hostNetwork: Bool? = nil
    var _hostPorts: [K8s_Io_Api_Extensions_V1beta1_HostPortRange] = []
    var _hostPid: Bool? = nil
    var _hostIpc: Bool? = nil
    var _seLinux: K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions? = nil
    var _runAsUser: K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions? = nil
    var _runAsGroup: K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions? = nil
    var _supplementalGroups: K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions? = nil
    var _fsGroup: K8s_Io_Api_Extensions_V1beta1_FSGroupStrategyOptions? = nil
    var _readOnlyRootFilesystem: Bool? = nil
    var _defaultAllowPrivilegeEscalation: Bool? = nil
    var _allowPrivilegeEscalation: Bool? = nil
    var _allowedHostPaths: [K8s_Io_Api_Extensions_V1beta1_AllowedHostPath] = []
    var _allowedFlexVolumes: [K8s_Io_Api_Extensions_V1beta1_AllowedFlexVolume] = []
    var _allowedCsidrivers: [K8s_Io_Api_Extensions_V1beta1_AllowedCSIDriver] = []
    var _allowedUnsafeSysctls: [String] = []
    var _forbiddenSysctls: [String] = []
    var _allowedProcMountTypes: [String] = []
    var _runtimeClass: K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _privileged = source._privileged
      _defaultAddCapabilities = source._defaultAddCapabilities
      _requiredDropCapabilities = source._requiredDropCapabilities
      _allowedCapabilities = source._allowedCapabilities
      _volumes = source._volumes
      _hostNetwork = source._hostNetwork
      _hostPorts = source._hostPorts
      _hostPid = source._hostPid
      _hostIpc = source._hostIpc
      _seLinux = source._seLinux
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _supplementalGroups = source._supplementalGroups
      _fsGroup = source._fsGroup
      _readOnlyRootFilesystem = source._readOnlyRootFilesystem
      _defaultAllowPrivilegeEscalation = source._defaultAllowPrivilegeEscalation
      _allowPrivilegeEscalation = source._allowPrivilegeEscalation
      _allowedHostPaths = source._allowedHostPaths
      _allowedFlexVolumes = source._allowedFlexVolumes
      _allowedCsidrivers = source._allowedCsidrivers
      _allowedUnsafeSysctls = source._allowedUnsafeSysctls
      _forbiddenSysctls = source._forbiddenSysctls
      _allowedProcMountTypes = source._allowedProcMountTypes
      _runtimeClass = source._runtimeClass
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._privileged)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._defaultAddCapabilities)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._requiredDropCapabilities)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._allowedCapabilities)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._volumes)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._hostNetwork)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._hostPorts)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._hostPid)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._hostIpc)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._seLinux)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._runAsUser)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._supplementalGroups)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._fsGroup)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._readOnlyRootFilesystem)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._defaultAllowPrivilegeEscalation)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._allowPrivilegeEscalation)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._allowedHostPaths)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._allowedFlexVolumes)
        case 19: try decoder.decodeRepeatedStringField(value: &_storage._allowedUnsafeSysctls)
        case 20: try decoder.decodeRepeatedStringField(value: &_storage._forbiddenSysctls)
        case 21: try decoder.decodeRepeatedStringField(value: &_storage._allowedProcMountTypes)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._runAsGroup)
        case 23: try decoder.decodeRepeatedMessageField(value: &_storage._allowedCsidrivers)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._runtimeClass)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._privileged {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if !_storage._defaultAddCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._defaultAddCapabilities, fieldNumber: 2)
      }
      if !_storage._requiredDropCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requiredDropCapabilities, fieldNumber: 3)
      }
      if !_storage._allowedCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedCapabilities, fieldNumber: 4)
      }
      if !_storage._volumes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._volumes, fieldNumber: 5)
      }
      if let v = _storage._hostNetwork {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if !_storage._hostPorts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hostPorts, fieldNumber: 7)
      }
      if let v = _storage._hostPid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._hostIpc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
      if let v = _storage._seLinux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._runAsUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._supplementalGroups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._fsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._readOnlyRootFilesystem {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }
      if let v = _storage._defaultAllowPrivilegeEscalation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      }
      if let v = _storage._allowPrivilegeEscalation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if !_storage._allowedHostPaths.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedHostPaths, fieldNumber: 17)
      }
      if !_storage._allowedFlexVolumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedFlexVolumes, fieldNumber: 18)
      }
      if !_storage._allowedUnsafeSysctls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedUnsafeSysctls, fieldNumber: 19)
      }
      if !_storage._forbiddenSysctls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._forbiddenSysctls, fieldNumber: 20)
      }
      if !_storage._allowedProcMountTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedProcMountTypes, fieldNumber: 21)
      }
      if let v = _storage._runAsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if !_storage._allowedCsidrivers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedCsidrivers, fieldNumber: 23)
      }
      if let v = _storage._runtimeClass {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec, rhs: K8s_Io_Api_Extensions_V1beta1_PodSecurityPolicySpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._privileged != rhs_storage._privileged {return false}
        if _storage._defaultAddCapabilities != rhs_storage._defaultAddCapabilities {return false}
        if _storage._requiredDropCapabilities != rhs_storage._requiredDropCapabilities {return false}
        if _storage._allowedCapabilities != rhs_storage._allowedCapabilities {return false}
        if _storage._volumes != rhs_storage._volumes {return false}
        if _storage._hostNetwork != rhs_storage._hostNetwork {return false}
        if _storage._hostPorts != rhs_storage._hostPorts {return false}
        if _storage._hostPid != rhs_storage._hostPid {return false}
        if _storage._hostIpc != rhs_storage._hostIpc {return false}
        if _storage._seLinux != rhs_storage._seLinux {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._supplementalGroups != rhs_storage._supplementalGroups {return false}
        if _storage._fsGroup != rhs_storage._fsGroup {return false}
        if _storage._readOnlyRootFilesystem != rhs_storage._readOnlyRootFilesystem {return false}
        if _storage._defaultAllowPrivilegeEscalation != rhs_storage._defaultAllowPrivilegeEscalation {return false}
        if _storage._allowPrivilegeEscalation != rhs_storage._allowPrivilegeEscalation {return false}
        if _storage._allowedHostPaths != rhs_storage._allowedHostPaths {return false}
        if _storage._allowedFlexVolumes != rhs_storage._allowedFlexVolumes {return false}
        if _storage._allowedCsidrivers != rhs_storage._allowedCsidrivers {return false}
        if _storage._allowedUnsafeSysctls != rhs_storage._allowedUnsafeSysctls {return false}
        if _storage._forbiddenSysctls != rhs_storage._forbiddenSysctls {return false}
        if _storage._allowedProcMountTypes != rhs_storage._allowedProcMountTypes {return false}
        if _storage._runtimeClass != rhs_storage._runtimeClass {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicaSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicaSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec? = nil
    var _status: K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSet, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicaSetCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicaSetCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetCondition, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicaSetList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicaSetList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Extensions_V1beta1_ReplicaSet] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetList, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicaSetSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    4: .same(proto: "minReadySeconds"),
    2: .same(proto: "selector"),
    3: .same(proto: "template"),
  ]

  fileprivate class _StorageClass {
    var _replicas: Int32? = nil
    var _minReadySeconds: Int32? = nil
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicas = source._replicas
      _minReadySeconds = source._minReadySeconds
      _selector = source._selector
      _template = source._template
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._replicas)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._minReadySeconds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._minReadySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._minReadySeconds != rhs_storage._minReadySeconds {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicaSetStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "fullyLabeledReplicas"),
    4: .same(proto: "readyReplicas"),
    5: .same(proto: "availableReplicas"),
    3: .same(proto: "observedGeneration"),
    6: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 2: try decoder.decodeSingularInt32Field(value: &self._fullyLabeledReplicas)
      case 3: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 4: try decoder.decodeSingularInt32Field(value: &self._readyReplicas)
      case 5: try decoder.decodeSingularInt32Field(value: &self._availableReplicas)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._fullyLabeledReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._readyReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._availableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicaSetStatus) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs._fullyLabeledReplicas != rhs._fullyLabeledReplicas {return false}
    if lhs._readyReplicas != rhs._readyReplicas {return false}
    if lhs._availableReplicas != rhs._availableReplicas {return false}
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ReplicationControllerDummy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationControllerDummy"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ReplicationControllerDummy, rhs: K8s_Io_Api_Extensions_V1beta1_ReplicationControllerDummy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RollbackConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollbackConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._revision)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._revision {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RollbackConfig, rhs: K8s_Io_Api_Extensions_V1beta1_RollbackConfig) -> Bool {
    if lhs._revision != rhs._revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollingUpdateDaemonSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxUnavailable"),
  ]

  fileprivate class _StorageClass {
    var _maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxUnavailable = source._maxUnavailable
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._maxUnavailable)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxUnavailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet, rhs: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDaemonSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxUnavailable != rhs_storage._maxUnavailable {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollingUpdateDeployment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxUnavailable"),
    2: .same(proto: "maxSurge"),
  ]

  fileprivate class _StorageClass {
    var _maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _maxSurge: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxUnavailable = source._maxUnavailable
      _maxSurge = source._maxSurge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._maxUnavailable)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._maxSurge)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxUnavailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._maxSurge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment, rhs: K8s_Io_Api_Extensions_V1beta1_RollingUpdateDeployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxUnavailable != rhs_storage._maxUnavailable {return false}
        if _storage._maxSurge != rhs_storage._maxSurge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAsGroupStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_RunAsGroupStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAsUserStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_RunAsUserStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeClassStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowedRuntimeClassNames"),
    2: .same(proto: "defaultRuntimeClassName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.allowedRuntimeClassNames)
      case 2: try decoder.decodeSingularStringField(value: &self._defaultRuntimeClassName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedRuntimeClassNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedRuntimeClassNames, fieldNumber: 1)
    }
    if let v = self._defaultRuntimeClassName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_RuntimeClassStrategyOptions) -> Bool {
    if lhs.allowedRuntimeClassNames != rhs.allowedRuntimeClassNames {return false}
    if lhs._defaultRuntimeClassName != rhs._defaultRuntimeClassName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SELinuxStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "seLinuxOptions"),
  ]

  fileprivate class _StorageClass {
    var _rule: String? = nil
    var _seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
      _seLinuxOptions = source._seLinuxOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._rule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._seLinuxOptions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rule {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._seLinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_SELinuxStrategyOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._seLinuxOptions != rhs_storage._seLinuxOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_Scale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scale"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Extensions_V1beta1_ScaleSpec? = nil
    var _status: K8s_Io_Api_Extensions_V1beta1_ScaleStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_Scale, rhs: K8s_Io_Api_Extensions_V1beta1_Scale) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ScaleSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ScaleSpec, rhs: K8s_Io_Api_Extensions_V1beta1_ScaleSpec) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_ScaleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "selector"),
    3: .same(proto: "targetSelector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.selector)
      case 3: try decoder.decodeSingularStringField(value: &self._targetSelector)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.selector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.selector, fieldNumber: 2)
    }
    if let v = self._targetSelector {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_ScaleStatus, rhs: K8s_Io_Api_Extensions_V1beta1_ScaleStatus) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs.selector != rhs.selector {return false}
    if lhs._targetSelector != rhs._targetSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupplementalGroupsStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions, rhs: K8s_Io_Api_Extensions_V1beta1_SupplementalGroupsStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
