// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/admissionregistration/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MutatingWebhook describes an admission webhook and the resources and operations it applies to.
struct K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the admission webhook.
  /// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
  /// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
  /// of the organization.
  /// Required.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// ClientConfig defines how to communicate with the hook.
  /// Required
  var clientConfig: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig {
    get {return _storage._clientConfig ?? K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig()}
    set {_uniqueStorage()._clientConfig = newValue}
  }
  /// Returns true if `clientConfig` has been explicitly set.
  var hasClientConfig: Bool {return _storage._clientConfig != nil}
  /// Clears the value of `clientConfig`. Subsequent reads from it will return its default value.
  mutating func clearClientConfig() {_uniqueStorage()._clientConfig = nil}

  /// Rules describes what operations on what resources/subresources the webhook cares about.
  /// The webhook cares about an operation if it matches _any_ Rule.
  /// However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
  /// from putting the cluster in a state which cannot be recovered from without completely
  /// disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
  /// on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
  var rules: [K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
  /// allowed values are Ignore or Fail. Defaults to Ignore.
  /// +optional
  var failurePolicy: String {
    get {return _storage._failurePolicy ?? String()}
    set {_uniqueStorage()._failurePolicy = newValue}
  }
  /// Returns true if `failurePolicy` has been explicitly set.
  var hasFailurePolicy: Bool {return _storage._failurePolicy != nil}
  /// Clears the value of `failurePolicy`. Subsequent reads from it will return its default value.
  mutating func clearFailurePolicy() {_uniqueStorage()._failurePolicy = nil}

  /// matchPolicy defines how the "rules" list is used to match incoming requests.
  /// Allowed values are "Exact" or "Equivalent".
  ///
  /// - Exact: match a request only if it exactly matches a specified rule.
  /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
  ///
  /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
  /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
  ///
  /// Defaults to "Exact"
  /// +optional
  var matchPolicy: String {
    get {return _storage._matchPolicy ?? String()}
    set {_uniqueStorage()._matchPolicy = newValue}
  }
  /// Returns true if `matchPolicy` has been explicitly set.
  var hasMatchPolicy: Bool {return _storage._matchPolicy != nil}
  /// Clears the value of `matchPolicy`. Subsequent reads from it will return its default value.
  mutating func clearMatchPolicy() {_uniqueStorage()._matchPolicy = nil}

  /// NamespaceSelector decides whether to run the webhook on an object based
  /// on whether the namespace for that object matches the selector. If the
  /// object itself is a namespace, the matching is performed on
  /// object.metadata.labels. If the object is another cluster scoped resource,
  /// it never skips the webhook.
  ///
  /// For example, to run the webhook on any objects whose namespace is not
  /// associated with "runlevel" of "0" or "1";  you will set the selector as
  /// follows:
  /// "namespaceSelector": {
  ///   "matchExpressions": [
  ///     {
  ///       "key": "runlevel",
  ///       "operator": "NotIn",
  ///       "values": [
  ///         "0",
  ///         "1"
  ///       ]
  ///     }
  ///   ]
  /// }
  ///
  /// If instead you want to only run the webhook on any objects whose
  /// namespace is associated with the "environment" of "prod" or "staging";
  /// you will set the selector as follows:
  /// "namespaceSelector": {
  ///   "matchExpressions": [
  ///     {
  ///       "key": "environment",
  ///       "operator": "In",
  ///       "values": [
  ///         "prod",
  ///         "staging"
  ///       ]
  ///     }
  ///   ]
  /// }
  ///
  /// See
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  /// for more examples of label selectors.
  ///
  /// Default to the empty LabelSelector, which matches everything.
  /// +optional
  var namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._namespaceSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._namespaceSelector = newValue}
  }
  /// Returns true if `namespaceSelector` has been explicitly set.
  var hasNamespaceSelector: Bool {return _storage._namespaceSelector != nil}
  /// Clears the value of `namespaceSelector`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceSelector() {_uniqueStorage()._namespaceSelector = nil}

  /// ObjectSelector decides whether to run the webhook based on if the
  /// object has matching labels. objectSelector is evaluated against both
  /// the oldObject and newObject that would be sent to the webhook, and
  /// is considered to match if either object matches the selector. A null
  /// object (oldObject in the case of create, or newObject in the case of
  /// delete) or an object that cannot have labels (like a
  /// DeploymentRollback or a PodProxyOptions object) is not considered to
  /// match.
  /// Use the object selector only if the webhook is opt-in, because end
  /// users may skip the admission webhook by setting the labels.
  /// Default to the empty LabelSelector, which matches everything.
  /// +optional
  var objectSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._objectSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._objectSelector = newValue}
  }
  /// Returns true if `objectSelector` has been explicitly set.
  var hasObjectSelector: Bool {return _storage._objectSelector != nil}
  /// Clears the value of `objectSelector`. Subsequent reads from it will return its default value.
  mutating func clearObjectSelector() {_uniqueStorage()._objectSelector = nil}

  /// SideEffects states whether this webhook has side effects.
  /// Acceptable values are: Unknown, None, Some, NoneOnDryRun
  /// Webhooks with side effects MUST implement a reconciliation system, since a request may be
  /// rejected by a future step in the admission change and the side effects therefore need to be undone.
  /// Requests with the dryRun attribute will be auto-rejected if they match a webhook with
  /// sideEffects == Unknown or Some. Defaults to Unknown.
  /// +optional
  var sideEffects: String {
    get {return _storage._sideEffects ?? String()}
    set {_uniqueStorage()._sideEffects = newValue}
  }
  /// Returns true if `sideEffects` has been explicitly set.
  var hasSideEffects: Bool {return _storage._sideEffects != nil}
  /// Clears the value of `sideEffects`. Subsequent reads from it will return its default value.
  mutating func clearSideEffects() {_uniqueStorage()._sideEffects = nil}

  /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
  /// the webhook call will be ignored or the API call will fail based on the
  /// failure policy.
  /// The timeout value must be between 1 and 30 seconds.
  /// Default to 30 seconds.
  /// +optional
  var timeoutSeconds: Int32 {
    get {return _storage._timeoutSeconds ?? 0}
    set {_uniqueStorage()._timeoutSeconds = newValue}
  }
  /// Returns true if `timeoutSeconds` has been explicitly set.
  var hasTimeoutSeconds: Bool {return _storage._timeoutSeconds != nil}
  /// Clears the value of `timeoutSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutSeconds() {_uniqueStorage()._timeoutSeconds = nil}

  /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
  /// versions the Webhook expects. API server will try to use first version in
  /// the list which it supports. If none of the versions specified in this list
  /// supported by API server, validation will fail for this object.
  /// If a persisted webhook configuration specifies allowed versions and does not
  /// include any versions known to the API Server, calls to the webhook will fail
  /// and be subject to the failure policy.
  /// Default to `['v1beta1']`.
  /// +optional
  var admissionReviewVersions: [String] {
    get {return _storage._admissionReviewVersions}
    set {_uniqueStorage()._admissionReviewVersions = newValue}
  }

  /// reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
  /// Allowed values are "Never" and "IfNeeded".
  ///
  /// Never: the webhook will not be called more than once in a single admission evaluation.
  ///
  /// IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
  /// if the object being admitted is modified by other admission plugins after the initial webhook call.
  /// Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
  /// Note:
  /// * the number of additional invocations is not guaranteed to be exactly one.
  /// * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
  /// * webhooks that use this option may be reordered to minimize the number of additional invocations.
  /// * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
  ///
  /// Defaults to "Never".
  /// +optional
  var reinvocationPolicy: String {
    get {return _storage._reinvocationPolicy ?? String()}
    set {_uniqueStorage()._reinvocationPolicy = newValue}
  }
  /// Returns true if `reinvocationPolicy` has been explicitly set.
  var hasReinvocationPolicy: Bool {return _storage._reinvocationPolicy != nil}
  /// Clears the value of `reinvocationPolicy`. Subsequent reads from it will return its default value.
  mutating func clearReinvocationPolicy() {_uniqueStorage()._reinvocationPolicy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
/// Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
struct K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Webhooks is a list of webhooks and the affected resources and operations.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var webhooks: [K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook] {
    get {return _storage._webhooks}
    set {_uniqueStorage()._webhooks = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.
struct K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfigurationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of MutatingWebhookConfiguration.
  var items: [K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Rule is a tuple of APIGroups, APIVersion, and Resources.It is recommended
/// to make sure that all the tuple expansions are valid.
struct K8s_Io_Api_Admissionregistration_V1beta1_Rule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// APIGroups is the API groups the resources belong to. '*' is all groups.
  /// If '*' is present, the length of the slice must be one.
  /// Required.
  var apiGroups: [String] = []

  /// APIVersions is the API versions the resources belong to. '*' is all versions.
  /// If '*' is present, the length of the slice must be one.
  /// Required.
  var apiVersions: [String] = []

  /// Resources is a list of resources this rule applies to.
  ///
  /// For example:
  /// 'pods' means pods.
  /// 'pods/log' means the log subresource of pods.
  /// '*' means all resources, but not subresources.
  /// 'pods/*' means all subresources of pods.
  /// '*/scale' means all scale subresources.
  /// '*/*' means all resources and their subresources.
  ///
  /// If wildcard is present, the validation rule will ensure resources do not
  /// overlap with each other.
  ///
  /// Depending on the enclosing object, subresources might not be allowed.
  /// Required.
  var resources: [String] = []

  /// scope specifies the scope of this rule.
  /// Valid values are "Cluster", "Namespaced", and "*"
  /// "Cluster" means that only cluster-scoped resources will match this rule.
  /// Namespace API objects are cluster-scoped.
  /// "Namespaced" means that only namespaced resources will match this rule.
  /// "*" means that there are no scope restrictions.
  /// Subresources match the scope of their parent resource.
  /// Default is "*".
  ///
  /// +optional
  var scope: String {
    get {return _scope ?? String()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: String? = nil
}

/// RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
/// sure that all the tuple expansions are valid.
struct K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operations is the operations the admission hook cares about - CREATE, UPDATE, or *
  /// for all operations.
  /// If '*' is present, the length of the slice must be one.
  /// Required.
  var operations: [String] {
    get {return _storage._operations}
    set {_uniqueStorage()._operations = newValue}
  }

  /// Rule is embedded, it describes other criteria of the rule, like
  /// APIGroups, APIVersions, Resources, etc.
  var rule: K8s_Io_Api_Admissionregistration_V1beta1_Rule {
    get {return _storage._rule ?? K8s_Io_Api_Admissionregistration_V1beta1_Rule()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {_uniqueStorage()._rule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceReference holds a reference to Service.legacy.k8s.io
struct K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `namespace` is the namespace of the service.
  /// Required
  var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {self._namespace = nil}

  /// `name` is the name of the service.
  /// Required
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// `path` is an optional URL path which will be sent in any request to
  /// this service.
  /// +optional
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// If specified, the port on the service that hosting webhook.
  /// Default to 443 for backward compatibility.
  /// `port` should be a valid port number (1-65535, inclusive).
  /// +optional
  var port: Int32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _namespace: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _port: Int32? = nil
}

/// ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
struct K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the admission webhook.
  /// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
  /// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
  /// of the organization.
  /// Required.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// ClientConfig defines how to communicate with the hook.
  /// Required
  var clientConfig: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig {
    get {return _storage._clientConfig ?? K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig()}
    set {_uniqueStorage()._clientConfig = newValue}
  }
  /// Returns true if `clientConfig` has been explicitly set.
  var hasClientConfig: Bool {return _storage._clientConfig != nil}
  /// Clears the value of `clientConfig`. Subsequent reads from it will return its default value.
  mutating func clearClientConfig() {_uniqueStorage()._clientConfig = nil}

  /// Rules describes what operations on what resources/subresources the webhook cares about.
  /// The webhook cares about an operation if it matches _any_ Rule.
  /// However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
  /// from putting the cluster in a state which cannot be recovered from without completely
  /// disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
  /// on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
  var rules: [K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  /// FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
  /// allowed values are Ignore or Fail. Defaults to Ignore.
  /// +optional
  var failurePolicy: String {
    get {return _storage._failurePolicy ?? String()}
    set {_uniqueStorage()._failurePolicy = newValue}
  }
  /// Returns true if `failurePolicy` has been explicitly set.
  var hasFailurePolicy: Bool {return _storage._failurePolicy != nil}
  /// Clears the value of `failurePolicy`. Subsequent reads from it will return its default value.
  mutating func clearFailurePolicy() {_uniqueStorage()._failurePolicy = nil}

  /// matchPolicy defines how the "rules" list is used to match incoming requests.
  /// Allowed values are "Exact" or "Equivalent".
  ///
  /// - Exact: match a request only if it exactly matches a specified rule.
  /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  /// but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  /// a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
  ///
  /// - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
  /// For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  /// and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  /// a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
  ///
  /// Defaults to "Exact"
  /// +optional
  var matchPolicy: String {
    get {return _storage._matchPolicy ?? String()}
    set {_uniqueStorage()._matchPolicy = newValue}
  }
  /// Returns true if `matchPolicy` has been explicitly set.
  var hasMatchPolicy: Bool {return _storage._matchPolicy != nil}
  /// Clears the value of `matchPolicy`. Subsequent reads from it will return its default value.
  mutating func clearMatchPolicy() {_uniqueStorage()._matchPolicy = nil}

  /// NamespaceSelector decides whether to run the webhook on an object based
  /// on whether the namespace for that object matches the selector. If the
  /// object itself is a namespace, the matching is performed on
  /// object.metadata.labels. If the object is another cluster scoped resource,
  /// it never skips the webhook.
  ///
  /// For example, to run the webhook on any objects whose namespace is not
  /// associated with "runlevel" of "0" or "1";  you will set the selector as
  /// follows:
  /// "namespaceSelector": {
  ///   "matchExpressions": [
  ///     {
  ///       "key": "runlevel",
  ///       "operator": "NotIn",
  ///       "values": [
  ///         "0",
  ///         "1"
  ///       ]
  ///     }
  ///   ]
  /// }
  ///
  /// If instead you want to only run the webhook on any objects whose
  /// namespace is associated with the "environment" of "prod" or "staging";
  /// you will set the selector as follows:
  /// "namespaceSelector": {
  ///   "matchExpressions": [
  ///     {
  ///       "key": "environment",
  ///       "operator": "In",
  ///       "values": [
  ///         "prod",
  ///         "staging"
  ///       ]
  ///     }
  ///   ]
  /// }
  ///
  /// See
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
  /// for more examples of label selectors.
  ///
  /// Default to the empty LabelSelector, which matches everything.
  /// +optional
  var namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._namespaceSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._namespaceSelector = newValue}
  }
  /// Returns true if `namespaceSelector` has been explicitly set.
  var hasNamespaceSelector: Bool {return _storage._namespaceSelector != nil}
  /// Clears the value of `namespaceSelector`. Subsequent reads from it will return its default value.
  mutating func clearNamespaceSelector() {_uniqueStorage()._namespaceSelector = nil}

  /// ObjectSelector decides whether to run the webhook based on if the
  /// object has matching labels. objectSelector is evaluated against both
  /// the oldObject and newObject that would be sent to the webhook, and
  /// is considered to match if either object matches the selector. A null
  /// object (oldObject in the case of create, or newObject in the case of
  /// delete) or an object that cannot have labels (like a
  /// DeploymentRollback or a PodProxyOptions object) is not considered to
  /// match.
  /// Use the object selector only if the webhook is opt-in, because end
  /// users may skip the admission webhook by setting the labels.
  /// Default to the empty LabelSelector, which matches everything.
  /// +optional
  var objectSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._objectSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._objectSelector = newValue}
  }
  /// Returns true if `objectSelector` has been explicitly set.
  var hasObjectSelector: Bool {return _storage._objectSelector != nil}
  /// Clears the value of `objectSelector`. Subsequent reads from it will return its default value.
  mutating func clearObjectSelector() {_uniqueStorage()._objectSelector = nil}

  /// SideEffects states whether this webhook has side effects.
  /// Acceptable values are: Unknown, None, Some, NoneOnDryRun
  /// Webhooks with side effects MUST implement a reconciliation system, since a request may be
  /// rejected by a future step in the admission change and the side effects therefore need to be undone.
  /// Requests with the dryRun attribute will be auto-rejected if they match a webhook with
  /// sideEffects == Unknown or Some. Defaults to Unknown.
  /// +optional
  var sideEffects: String {
    get {return _storage._sideEffects ?? String()}
    set {_uniqueStorage()._sideEffects = newValue}
  }
  /// Returns true if `sideEffects` has been explicitly set.
  var hasSideEffects: Bool {return _storage._sideEffects != nil}
  /// Clears the value of `sideEffects`. Subsequent reads from it will return its default value.
  mutating func clearSideEffects() {_uniqueStorage()._sideEffects = nil}

  /// TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
  /// the webhook call will be ignored or the API call will fail based on the
  /// failure policy.
  /// The timeout value must be between 1 and 30 seconds.
  /// Default to 30 seconds.
  /// +optional
  var timeoutSeconds: Int32 {
    get {return _storage._timeoutSeconds ?? 0}
    set {_uniqueStorage()._timeoutSeconds = newValue}
  }
  /// Returns true if `timeoutSeconds` has been explicitly set.
  var hasTimeoutSeconds: Bool {return _storage._timeoutSeconds != nil}
  /// Clears the value of `timeoutSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutSeconds() {_uniqueStorage()._timeoutSeconds = nil}

  /// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
  /// versions the Webhook expects. API server will try to use first version in
  /// the list which it supports. If none of the versions specified in this list
  /// supported by API server, validation will fail for this object.
  /// If a persisted webhook configuration specifies allowed versions and does not
  /// include any versions known to the API Server, calls to the webhook will fail
  /// and be subject to the failure policy.
  /// Default to `['v1beta1']`.
  /// +optional
  var admissionReviewVersions: [String] {
    get {return _storage._admissionReviewVersions}
    set {_uniqueStorage()._admissionReviewVersions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
/// Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
struct K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Webhooks is a list of webhooks and the affected resources and operations.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var webhooks: [K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook] {
    get {return _storage._webhooks}
    set {_uniqueStorage()._webhooks = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.
struct K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfigurationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of ValidatingWebhookConfiguration.
  var items: [K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WebhookClientConfig contains the information to make a TLS
/// connection with the webhook
struct K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `url` gives the location of the webhook, in standard URL form
  /// (`scheme://host:port/path`). Exactly one of `url` or `service`
  /// must be specified.
  ///
  /// The `host` should not refer to a service running in the cluster; use
  /// the `service` field instead. The host might be resolved via external
  /// DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
  /// in-cluster DNS as that would be a layering violation). `host` may
  /// also be an IP address.
  ///
  /// Please note that using `localhost` or `127.0.0.1` as a `host` is
  /// risky unless you take great care to run this webhook on all hosts
  /// which run an apiserver which might need to make calls to this
  /// webhook. Such installs are likely to be non-portable, i.e., not easy
  /// to turn up in a new cluster.
  ///
  /// The scheme must be "https"; the URL must begin with "https://".
  ///
  /// A path is optional, and if present may be any string permissible in
  /// a URL. You may use the path to pass an arbitrary string to the
  /// webhook, for example, a cluster identifier.
  ///
  /// Attempting to use a user or basic auth e.g. "user:password@" is not
  /// allowed. Fragments ("#...") and query parameters ("?...") are not
  /// allowed, either.
  ///
  /// +optional
  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  /// `service` is a reference to the service for this webhook. Either
  /// `service` or `url` must be specified.
  ///
  /// If the webhook is running within the cluster, then you should use `service`.
  ///
  /// +optional
  var service: K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference {
    get {return _storage._service ?? K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {_uniqueStorage()._service = nil}

  /// `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
  /// If unspecified, system trust roots on the apiserver are used.
  /// +optional
  var caBundle: Data {
    get {return _storage._caBundle ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._caBundle = newValue}
  }
  /// Returns true if `caBundle` has been explicitly set.
  var hasCaBundle: Bool {return _storage._caBundle != nil}
  /// Clears the value of `caBundle`. Subsequent reads from it will return its default value.
  mutating func clearCaBundle() {_uniqueStorage()._caBundle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.admissionregistration.v1beta1"

extension K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MutatingWebhook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "clientConfig"),
    3: .same(proto: "rules"),
    4: .same(proto: "failurePolicy"),
    9: .same(proto: "matchPolicy"),
    5: .same(proto: "namespaceSelector"),
    11: .same(proto: "objectSelector"),
    6: .same(proto: "sideEffects"),
    7: .same(proto: "timeoutSeconds"),
    8: .same(proto: "admissionReviewVersions"),
    10: .same(proto: "reinvocationPolicy"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _clientConfig: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig? = nil
    var _rules: [K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations] = []
    var _failurePolicy: String? = nil
    var _matchPolicy: String? = nil
    var _namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _objectSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _sideEffects: String? = nil
    var _timeoutSeconds: Int32? = nil
    var _admissionReviewVersions: [String] = []
    var _reinvocationPolicy: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _clientConfig = source._clientConfig
      _rules = source._rules
      _failurePolicy = source._failurePolicy
      _matchPolicy = source._matchPolicy
      _namespaceSelector = source._namespaceSelector
      _objectSelector = source._objectSelector
      _sideEffects = source._sideEffects
      _timeoutSeconds = source._timeoutSeconds
      _admissionReviewVersions = source._admissionReviewVersions
      _reinvocationPolicy = source._reinvocationPolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._clientConfig)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._rules)
        case 4: try decoder.decodeSingularStringField(value: &_storage._failurePolicy)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._namespaceSelector)
        case 6: try decoder.decodeSingularStringField(value: &_storage._sideEffects)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 8: try decoder.decodeRepeatedStringField(value: &_storage._admissionReviewVersions)
        case 9: try decoder.decodeSingularStringField(value: &_storage._matchPolicy)
        case 10: try decoder.decodeSingularStringField(value: &_storage._reinvocationPolicy)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._objectSelector)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._clientConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 3)
      }
      if let v = _storage._failurePolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._namespaceSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._sideEffects {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._timeoutSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      }
      if !_storage._admissionReviewVersions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._admissionReviewVersions, fieldNumber: 8)
      }
      if let v = _storage._matchPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._reinvocationPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._objectSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook, rhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._clientConfig != rhs_storage._clientConfig {return false}
        if _storage._rules != rhs_storage._rules {return false}
        if _storage._failurePolicy != rhs_storage._failurePolicy {return false}
        if _storage._matchPolicy != rhs_storage._matchPolicy {return false}
        if _storage._namespaceSelector != rhs_storage._namespaceSelector {return false}
        if _storage._objectSelector != rhs_storage._objectSelector {return false}
        if _storage._sideEffects != rhs_storage._sideEffects {return false}
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._admissionReviewVersions != rhs_storage._admissionReviewVersions {return false}
        if _storage._reinvocationPolicy != rhs_storage._reinvocationPolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MutatingWebhookConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "Webhooks"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _webhooks: [K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhook] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _webhooks = source._webhooks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._webhooks)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._webhooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._webhooks, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration, rhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._webhooks != rhs_storage._webhooks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfigurationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MutatingWebhookConfigurationList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfiguration] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfigurationList, rhs: K8s_Io_Api_Admissionregistration_V1beta1_MutatingWebhookConfigurationList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apiGroups"),
    2: .same(proto: "apiVersions"),
    3: .same(proto: "resources"),
    4: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.apiGroups)
      case 2: try decoder.decodeRepeatedStringField(value: &self.apiVersions)
      case 3: try decoder.decodeRepeatedStringField(value: &self.resources)
      case 4: try decoder.decodeSingularStringField(value: &self._scope)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.apiGroups, fieldNumber: 1)
    }
    if !self.apiVersions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.apiVersions, fieldNumber: 2)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resources, fieldNumber: 3)
    }
    if let v = self._scope {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_Rule, rhs: K8s_Io_Api_Admissionregistration_V1beta1_Rule) -> Bool {
    if lhs.apiGroups != rhs.apiGroups {return false}
    if lhs.apiVersions != rhs.apiVersions {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs._scope != rhs._scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuleWithOperations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
    2: .same(proto: "rule"),
  ]

  fileprivate class _StorageClass {
    var _operations: [String] = []
    var _rule: K8s_Io_Api_Admissionregistration_V1beta1_Rule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operations = source._operations
      _rule = source._rule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._operations)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rule)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._operations.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._operations, fieldNumber: 1)
      }
      if let v = _storage._rule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations, rhs: K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operations != rhs_storage._operations {return false}
        if _storage._rule != rhs_storage._rule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "name"),
    3: .same(proto: "path"),
    4: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._namespace)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      case 3: try decoder.decodeSingularStringField(value: &self._path)
      case 4: try decoder.decodeSingularInt32Field(value: &self._port)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._port {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference, rhs: K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference) -> Bool {
    if lhs._namespace != rhs._namespace {return false}
    if lhs._name != rhs._name {return false}
    if lhs._path != rhs._path {return false}
    if lhs._port != rhs._port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatingWebhook"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "clientConfig"),
    3: .same(proto: "rules"),
    4: .same(proto: "failurePolicy"),
    9: .same(proto: "matchPolicy"),
    5: .same(proto: "namespaceSelector"),
    10: .same(proto: "objectSelector"),
    6: .same(proto: "sideEffects"),
    7: .same(proto: "timeoutSeconds"),
    8: .same(proto: "admissionReviewVersions"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _clientConfig: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig? = nil
    var _rules: [K8s_Io_Api_Admissionregistration_V1beta1_RuleWithOperations] = []
    var _failurePolicy: String? = nil
    var _matchPolicy: String? = nil
    var _namespaceSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _objectSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _sideEffects: String? = nil
    var _timeoutSeconds: Int32? = nil
    var _admissionReviewVersions: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _clientConfig = source._clientConfig
      _rules = source._rules
      _failurePolicy = source._failurePolicy
      _matchPolicy = source._matchPolicy
      _namespaceSelector = source._namespaceSelector
      _objectSelector = source._objectSelector
      _sideEffects = source._sideEffects
      _timeoutSeconds = source._timeoutSeconds
      _admissionReviewVersions = source._admissionReviewVersions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._clientConfig)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._rules)
        case 4: try decoder.decodeSingularStringField(value: &_storage._failurePolicy)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._namespaceSelector)
        case 6: try decoder.decodeSingularStringField(value: &_storage._sideEffects)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 8: try decoder.decodeRepeatedStringField(value: &_storage._admissionReviewVersions)
        case 9: try decoder.decodeSingularStringField(value: &_storage._matchPolicy)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._objectSelector)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._clientConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 3)
      }
      if let v = _storage._failurePolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._namespaceSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._sideEffects {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._timeoutSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      }
      if !_storage._admissionReviewVersions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._admissionReviewVersions, fieldNumber: 8)
      }
      if let v = _storage._matchPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._objectSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook, rhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._clientConfig != rhs_storage._clientConfig {return false}
        if _storage._rules != rhs_storage._rules {return false}
        if _storage._failurePolicy != rhs_storage._failurePolicy {return false}
        if _storage._matchPolicy != rhs_storage._matchPolicy {return false}
        if _storage._namespaceSelector != rhs_storage._namespaceSelector {return false}
        if _storage._objectSelector != rhs_storage._objectSelector {return false}
        if _storage._sideEffects != rhs_storage._sideEffects {return false}
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._admissionReviewVersions != rhs_storage._admissionReviewVersions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatingWebhookConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "Webhooks"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _webhooks: [K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhook] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _webhooks = source._webhooks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._webhooks)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._webhooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._webhooks, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration, rhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._webhooks != rhs_storage._webhooks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfigurationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatingWebhookConfigurationList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfiguration] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfigurationList, rhs: K8s_Io_Api_Admissionregistration_V1beta1_ValidatingWebhookConfigurationList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebhookClientConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "url"),
    1: .same(proto: "service"),
    2: .same(proto: "caBundle"),
  ]

  fileprivate class _StorageClass {
    var _url: String? = nil
    var _service: K8s_Io_Api_Admissionregistration_V1beta1_ServiceReference? = nil
    var _caBundle: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _service = source._service
      _caBundle = source._caBundle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._service)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._caBundle)
        case 3: try decoder.decodeSingularStringField(value: &_storage._url)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._service {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._caBundle {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
      if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig, rhs: K8s_Io_Api_Admissionregistration_V1beta1_WebhookClientConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._caBundle != rhs_storage._caBundle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
