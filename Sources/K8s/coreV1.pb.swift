// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/core/v1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a Persistent Disk resource in AWS.
///
/// An AWS EBS disk must exist before mounting to a container. The disk
/// must also be in the same AWS zone as the kubelet. An AWS EBS disk
/// can only be mounted as read/write once. AWS EBS volumes support
/// ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  var volumeID: String {
    get {return _volumeID ?? String()}
    set {_volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  var hasVolumeID: Bool {return self._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  mutating func clearVolumeID() {self._volumeID = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// The partition in the volume that you want to mount.
  /// If omitted, the default is to mount by volume name.
  /// Examples: For volume /dev/sda1, you specify the partition as "1".
  /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  /// +optional
  var partition: Int32 {
    get {return _partition ?? 0}
    set {_partition = newValue}
  }
  /// Returns true if `partition` has been explicitly set.
  var hasPartition: Bool {return self._partition != nil}
  /// Clears the value of `partition`. Subsequent reads from it will return its default value.
  mutating func clearPartition() {self._partition = nil}

  /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  /// If omitted, the default is "false".
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volumeID: String? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _partition: Int32? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Affinity is a group of affinity scheduling rules.
struct K8s_Io_Api_Core_V1_Affinity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes node affinity scheduling rules for the pod.
  /// +optional
  var nodeAffinity: K8s_Io_Api_Core_V1_NodeAffinity {
    get {return _storage._nodeAffinity ?? K8s_Io_Api_Core_V1_NodeAffinity()}
    set {_uniqueStorage()._nodeAffinity = newValue}
  }
  /// Returns true if `nodeAffinity` has been explicitly set.
  var hasNodeAffinity: Bool {return _storage._nodeAffinity != nil}
  /// Clears the value of `nodeAffinity`. Subsequent reads from it will return its default value.
  mutating func clearNodeAffinity() {_uniqueStorage()._nodeAffinity = nil}

  /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  /// +optional
  var podAffinity: K8s_Io_Api_Core_V1_PodAffinity {
    get {return _storage._podAffinity ?? K8s_Io_Api_Core_V1_PodAffinity()}
    set {_uniqueStorage()._podAffinity = newValue}
  }
  /// Returns true if `podAffinity` has been explicitly set.
  var hasPodAffinity: Bool {return _storage._podAffinity != nil}
  /// Clears the value of `podAffinity`. Subsequent reads from it will return its default value.
  mutating func clearPodAffinity() {_uniqueStorage()._podAffinity = nil}

  /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  /// +optional
  var podAntiAffinity: K8s_Io_Api_Core_V1_PodAntiAffinity {
    get {return _storage._podAntiAffinity ?? K8s_Io_Api_Core_V1_PodAntiAffinity()}
    set {_uniqueStorage()._podAntiAffinity = newValue}
  }
  /// Returns true if `podAntiAffinity` has been explicitly set.
  var hasPodAntiAffinity: Bool {return _storage._podAntiAffinity != nil}
  /// Clears the value of `podAntiAffinity`. Subsequent reads from it will return its default value.
  mutating func clearPodAntiAffinity() {_uniqueStorage()._podAntiAffinity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AttachedVolume describes a volume attached to a node
struct K8s_Io_Api_Core_V1_AttachedVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the attached volume
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// DevicePath represents the device path where the volume should be available
  var devicePath: String {
    get {return _devicePath ?? String()}
    set {_devicePath = newValue}
  }
  /// Returns true if `devicePath` has been explicitly set.
  var hasDevicePath: Bool {return self._devicePath != nil}
  /// Clears the value of `devicePath`. Subsequent reads from it will return its default value.
  mutating func clearDevicePath() {self._devicePath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _devicePath: String? = nil
}

/// AvoidPods describes pods that should avoid this node. This is the value for a
/// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
/// will eventually become a field of NodeStatus.
struct K8s_Io_Api_Core_V1_AvoidPods {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bounded-sized list of signatures of pods that should avoid this node, sorted
  /// in timestamp order from oldest to newest. Size of the slice is unspecified.
  /// +optional
  var preferAvoidPods: [K8s_Io_Api_Core_V1_PreferAvoidPodsEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
struct K8s_Io_Api_Core_V1_AzureDiskVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Name of the data disk in the blob storage
  var diskName: String {
    get {return _diskName ?? String()}
    set {_diskName = newValue}
  }
  /// Returns true if `diskName` has been explicitly set.
  var hasDiskName: Bool {return self._diskName != nil}
  /// Clears the value of `diskName`. Subsequent reads from it will return its default value.
  mutating func clearDiskName() {self._diskName = nil}

  /// The URI the data disk in the blob storage
  var diskUri: String {
    get {return _diskUri ?? String()}
    set {_diskUri = newValue}
  }
  /// Returns true if `diskUri` has been explicitly set.
  var hasDiskUri: Bool {return self._diskUri != nil}
  /// Clears the value of `diskUri`. Subsequent reads from it will return its default value.
  mutating func clearDiskUri() {self._diskUri = nil}

  /// Host Caching mode: None, Read Only, Read Write.
  /// +optional
  var cachingMode: String {
    get {return _cachingMode ?? String()}
    set {_cachingMode = newValue}
  }
  /// Returns true if `cachingMode` has been explicitly set.
  var hasCachingMode: Bool {return self._cachingMode != nil}
  /// Clears the value of `cachingMode`. Subsequent reads from it will return its default value.
  mutating func clearCachingMode() {self._cachingMode = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _diskName: String? = nil
  fileprivate var _diskUri: String? = nil
  fileprivate var _cachingMode: String? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _readOnly: Bool? = nil
  fileprivate var _kind: String? = nil
}

/// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
struct K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the name of secret that contains Azure Storage Account Name and Key
  var secretName: String {
    get {return _secretName ?? String()}
    set {_secretName = newValue}
  }
  /// Returns true if `secretName` has been explicitly set.
  var hasSecretName: Bool {return self._secretName != nil}
  /// Clears the value of `secretName`. Subsequent reads from it will return its default value.
  mutating func clearSecretName() {self._secretName = nil}

  /// Share Name
  var shareName: String {
    get {return _shareName ?? String()}
    set {_shareName = newValue}
  }
  /// Returns true if `shareName` has been explicitly set.
  var hasShareName: Bool {return self._shareName != nil}
  /// Clears the value of `shareName`. Subsequent reads from it will return its default value.
  mutating func clearShareName() {self._shareName = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// the namespace of the secret that contains Azure Storage Account Name and Key
  /// default is the same as the Pod
  /// +optional
  var secretNamespace: String {
    get {return _secretNamespace ?? String()}
    set {_secretNamespace = newValue}
  }
  /// Returns true if `secretNamespace` has been explicitly set.
  var hasSecretNamespace: Bool {return self._secretNamespace != nil}
  /// Clears the value of `secretNamespace`. Subsequent reads from it will return its default value.
  mutating func clearSecretNamespace() {self._secretNamespace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secretName: String? = nil
  fileprivate var _shareName: String? = nil
  fileprivate var _readOnly: Bool? = nil
  fileprivate var _secretNamespace: String? = nil
}

/// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
struct K8s_Io_Api_Core_V1_AzureFileVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the name of secret that contains Azure Storage Account Name and Key
  var secretName: String {
    get {return _secretName ?? String()}
    set {_secretName = newValue}
  }
  /// Returns true if `secretName` has been explicitly set.
  var hasSecretName: Bool {return self._secretName != nil}
  /// Clears the value of `secretName`. Subsequent reads from it will return its default value.
  mutating func clearSecretName() {self._secretName = nil}

  /// Share Name
  var shareName: String {
    get {return _shareName ?? String()}
    set {_shareName = newValue}
  }
  /// Returns true if `shareName` has been explicitly set.
  var hasShareName: Bool {return self._shareName != nil}
  /// Clears the value of `shareName`. Subsequent reads from it will return its default value.
  mutating func clearShareName() {self._shareName = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secretName: String? = nil
  fileprivate var _shareName: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
/// Deprecated in 1.7, please use the bindings subresource of pods instead.
struct K8s_Io_Api_Core_V1_Binding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The target object that you want to bind to the standard object.
  var target: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._target ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {_uniqueStorage()._target = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents storage that is managed by an external CSI volume driver (Beta feature)
struct K8s_Io_Api_Core_V1_CSIPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Driver is the name of the driver to use for this volume.
  /// Required.
  var driver: String {
    get {return _storage._driver ?? String()}
    set {_uniqueStorage()._driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return _storage._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {_uniqueStorage()._driver = nil}

  /// VolumeHandle is the unique volume name returned by the CSI volume
  /// plugin’s CreateVolume to refer to the volume on all subsequent calls.
  /// Required.
  var volumeHandle: String {
    get {return _storage._volumeHandle ?? String()}
    set {_uniqueStorage()._volumeHandle = newValue}
  }
  /// Returns true if `volumeHandle` has been explicitly set.
  var hasVolumeHandle: Bool {return _storage._volumeHandle != nil}
  /// Clears the value of `volumeHandle`. Subsequent reads from it will return its default value.
  mutating func clearVolumeHandle() {_uniqueStorage()._volumeHandle = nil}

  /// Optional: The value to pass to ControllerPublishVolumeRequest.
  /// Defaults to false (read/write).
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Attributes of the volume to publish.
  /// +optional
  var volumeAttributes: Dictionary<String,String> {
    get {return _storage._volumeAttributes}
    set {_uniqueStorage()._volumeAttributes = newValue}
  }

  /// ControllerPublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// ControllerPublishVolume and ControllerUnpublishVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  var controllerPublishSecretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._controllerPublishSecretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._controllerPublishSecretRef = newValue}
  }
  /// Returns true if `controllerPublishSecretRef` has been explicitly set.
  var hasControllerPublishSecretRef: Bool {return _storage._controllerPublishSecretRef != nil}
  /// Clears the value of `controllerPublishSecretRef`. Subsequent reads from it will return its default value.
  mutating func clearControllerPublishSecretRef() {_uniqueStorage()._controllerPublishSecretRef = nil}

  /// NodeStageSecretRef is a reference to the secret object containing sensitive
  /// information to pass to the CSI driver to complete the CSI NodeStageVolume
  /// and NodeStageVolume and NodeUnstageVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  var nodeStageSecretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._nodeStageSecretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._nodeStageSecretRef = newValue}
  }
  /// Returns true if `nodeStageSecretRef` has been explicitly set.
  var hasNodeStageSecretRef: Bool {return _storage._nodeStageSecretRef != nil}
  /// Clears the value of `nodeStageSecretRef`. Subsequent reads from it will return its default value.
  mutating func clearNodeStageSecretRef() {_uniqueStorage()._nodeStageSecretRef = nil}

  /// NodePublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// NodePublishVolume and NodeUnpublishVolume calls.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  var nodePublishSecretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._nodePublishSecretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._nodePublishSecretRef = newValue}
  }
  /// Returns true if `nodePublishSecretRef` has been explicitly set.
  var hasNodePublishSecretRef: Bool {return _storage._nodePublishSecretRef != nil}
  /// Clears the value of `nodePublishSecretRef`. Subsequent reads from it will return its default value.
  mutating func clearNodePublishSecretRef() {_uniqueStorage()._nodePublishSecretRef = nil}

  /// ControllerExpandSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// ControllerExpandVolume call.
  /// This is an alpha field and requires enabling ExpandCSIVolumes feature gate.
  /// This field is optional, and may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secrets are passed.
  /// +optional
  var controllerExpandSecretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._controllerExpandSecretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._controllerExpandSecretRef = newValue}
  }
  /// Returns true if `controllerExpandSecretRef` has been explicitly set.
  var hasControllerExpandSecretRef: Bool {return _storage._controllerExpandSecretRef != nil}
  /// Clears the value of `controllerExpandSecretRef`. Subsequent reads from it will return its default value.
  mutating func clearControllerExpandSecretRef() {_uniqueStorage()._controllerExpandSecretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a source location of a volume to mount, managed by an external CSI driver
struct K8s_Io_Api_Core_V1_CSIVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Driver is the name of the CSI driver that handles this volume.
  /// Consult with your admin for the correct name as registered in the cluster.
  var driver: String {
    get {return _storage._driver ?? String()}
    set {_uniqueStorage()._driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return _storage._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {_uniqueStorage()._driver = nil}

  /// Specifies a read-only configuration for the volume.
  /// Defaults to false (read/write).
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
  /// If not provided, the empty value is passed to the associated CSI driver
  /// which will determine the default filesystem to apply.
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// VolumeAttributes stores driver-specific properties that are passed to the CSI
  /// driver. Consult your driver's documentation for supported values.
  /// +optional
  var volumeAttributes: Dictionary<String,String> {
    get {return _storage._volumeAttributes}
    set {_uniqueStorage()._volumeAttributes = newValue}
  }

  /// NodePublishSecretRef is a reference to the secret object containing
  /// sensitive information to pass to the CSI driver to complete the CSI
  /// NodePublishVolume and NodeUnpublishVolume calls.
  /// This field is optional, and  may be empty if no secret is required. If the
  /// secret object contains more than one secret, all secret references are passed.
  /// +optional
  var nodePublishSecretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._nodePublishSecretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._nodePublishSecretRef = newValue}
  }
  /// Returns true if `nodePublishSecretRef` has been explicitly set.
  var hasNodePublishSecretRef: Bool {return _storage._nodePublishSecretRef != nil}
  /// Clears the value of `nodePublishSecretRef`. Subsequent reads from it will return its default value.
  mutating func clearNodePublishSecretRef() {_uniqueStorage()._nodePublishSecretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Adds and removes POSIX capabilities from running containers.
struct K8s_Io_Api_Core_V1_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Added capabilities
  /// +optional
  var add: [String] = []

  /// Removed capabilities
  /// +optional
  var drop: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
/// Cephfs volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required: Monitors is a collection of Ceph monitors
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  var monitors: [String] {
    get {return _storage._monitors}
    set {_uniqueStorage()._monitors = newValue}
  }

  /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  /// +optional
  var path: String {
    get {return _storage._path ?? String()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Optional: User is the rados user name, default is admin
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var secretFile: String {
    get {return _storage._secretFile ?? String()}
    set {_uniqueStorage()._secretFile = newValue}
  }
  /// Returns true if `secretFile` has been explicitly set.
  var hasSecretFile: Bool {return _storage._secretFile != nil}
  /// Clears the value of `secretFile`. Subsequent reads from it will return its default value.
  mutating func clearSecretFile() {_uniqueStorage()._secretFile = nil}

  /// Optional: SecretRef is reference to the authentication secret for User, default is empty.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
/// Cephfs volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_CephFSVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required: Monitors is a collection of Ceph monitors
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  var monitors: [String] {
    get {return _storage._monitors}
    set {_uniqueStorage()._monitors = newValue}
  }

  /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  /// +optional
  var path: String {
    get {return _storage._path ?? String()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Optional: User is the rados user name, default is admin
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var secretFile: String {
    get {return _storage._secretFile ?? String()}
    set {_uniqueStorage()._secretFile = newValue}
  }
  /// Returns true if `secretFile` has been explicitly set.
  var hasSecretFile: Bool {return _storage._secretFile != nil}
  /// Clears the value of `secretFile`. Subsequent reads from it will return its default value.
  mutating func clearSecretFile() {_uniqueStorage()._secretFile = nil}

  /// Optional: SecretRef is reference to the authentication secret for User, default is empty.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a cinder volume resource in Openstack.
/// A Cinder volume must exist before mounting to a container.
/// The volume must also be in the same region as the kubelet.
/// Cinder volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_CinderPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// volume id used to identify the volume in cinder.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  var volumeID: String {
    get {return _storage._volumeID ?? String()}
    set {_uniqueStorage()._volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  var hasVolumeID: Bool {return _storage._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  mutating func clearVolumeID() {_uniqueStorage()._volumeID = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Optional: points to a secret object containing parameters used to connect
  /// to OpenStack.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a cinder volume resource in Openstack.
/// A Cinder volume must exist before mounting to a container.
/// The volume must also be in the same region as the kubelet.
/// Cinder volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_CinderVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// volume id used to identify the volume in cinder.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  var volumeID: String {
    get {return _storage._volumeID ?? String()}
    set {_uniqueStorage()._volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  var hasVolumeID: Bool {return _storage._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  mutating func clearVolumeID() {_uniqueStorage()._volumeID = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Optional: points to a secret object containing parameters used to connect
  /// to OpenStack.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClientIPConfig represents the configurations of Client IP based session affinity.
struct K8s_Io_Api_Core_V1_ClientIPConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
  /// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
  /// Default value is 10800(for 3 hours).
  /// +optional
  var timeoutSeconds: Int32 {
    get {return _timeoutSeconds ?? 0}
    set {_timeoutSeconds = newValue}
  }
  /// Returns true if `timeoutSeconds` has been explicitly set.
  var hasTimeoutSeconds: Bool {return self._timeoutSeconds != nil}
  /// Clears the value of `timeoutSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutSeconds() {self._timeoutSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeoutSeconds: Int32? = nil
}

/// Information about the condition of a component.
struct K8s_Io_Api_Core_V1_ComponentCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of condition for a component.
  /// Valid value: "Healthy"
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Status of the condition for a component.
  /// Valid values for "Healthy": "True", "False", or "Unknown".
  var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Message about the condition for a component.
  /// For example, information about a health check.
  /// +optional
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Condition error code for a component.
  /// For example, a health check error code.
  /// +optional
  var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: String? = nil
  fileprivate var _status: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _error: String? = nil
}

/// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
struct K8s_Io_Api_Core_V1_ComponentStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of component conditions observed
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_ComponentCondition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Status of all the conditions for the component as a list of ComponentStatus objects.
struct K8s_Io_Api_Core_V1_ComponentStatusList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of ComponentStatus objects.
  var items: [K8s_Io_Api_Core_V1_ComponentStatus] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ConfigMap holds configuration data for pods to consume.
struct K8s_Io_Api_Core_V1_ConfigMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Data contains the configuration data.
  /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
  /// Values with non-UTF-8 byte sequences must use the BinaryData field.
  /// The keys stored in Data must not overlap with the keys in
  /// the BinaryData field, this is enforced during validation process.
  /// +optional
  var data: Dictionary<String,String> {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// BinaryData contains the binary data.
  /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
  /// BinaryData can contain byte sequences that are not in the UTF-8 range.
  /// The keys stored in BinaryData must not overlap with the ones in
  /// the Data field, this is enforced during validation process.
  /// Using this field will require 1.10+ apiserver and
  /// kubelet.
  /// +optional
  var binaryData: Dictionary<String,Data> {
    get {return _storage._binaryData}
    set {_uniqueStorage()._binaryData = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ConfigMapEnvSource selects a ConfigMap to populate the environment
/// variables with.
///
/// The contents of the target ConfigMap's Data field will represent the
/// key-value pairs as environment variables.
struct K8s_Io_Api_Core_V1_ConfigMapEnvSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ConfigMap to select from.
  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// Specify whether the ConfigMap must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Selects a key from a ConfigMap.
struct K8s_Io_Api_Core_V1_ConfigMapKeySelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ConfigMap to select from.
  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// The key to select.
  var key: String {
    get {return _storage._key ?? String()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Specify whether the ConfigMap or its key must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ConfigMapList is a resource containing a list of ConfigMap objects.
struct K8s_Io_Api_Core_V1_ConfigMapList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of ConfigMaps.
  var items: [K8s_Io_Api_Core_V1_ConfigMap] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
struct K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the metadata.namespace of the referenced ConfigMap.
  /// This field is required in all cases.
  var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {self._namespace = nil}

  /// Name is the metadata.name of the referenced ConfigMap.
  /// This field is required in all cases.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// UID is the metadata.UID of the referenced ConfigMap.
  /// This field is forbidden in Node.Spec, and required in Node.Status.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
  /// This field is forbidden in Node.Spec, and required in Node.Status.
  /// +optional
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
  /// This field is required in all cases.
  var kubeletConfigKey: String {
    get {return _kubeletConfigKey ?? String()}
    set {_kubeletConfigKey = newValue}
  }
  /// Returns true if `kubeletConfigKey` has been explicitly set.
  var hasKubeletConfigKey: Bool {return self._kubeletConfigKey != nil}
  /// Clears the value of `kubeletConfigKey`. Subsequent reads from it will return its default value.
  mutating func clearKubeletConfigKey() {self._kubeletConfigKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _namespace: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _uid: String? = nil
  fileprivate var _resourceVersion: String? = nil
  fileprivate var _kubeletConfigKey: String? = nil
}

/// Adapts a ConfigMap into a projected volume.
///
/// The contents of the target ConfigMap's Data field will be presented in a
/// projected volume as files using the keys in the Data field as the file names,
/// unless the items element is populated with specific mappings of keys to paths.
/// Note that this is identical to a configmap volume source without the default
/// mode.
struct K8s_Io_Api_Core_V1_ConfigMapProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// If unspecified, each key-value pair in the Data field of the referenced
  /// ConfigMap will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the ConfigMap,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  var items: [K8s_Io_Api_Core_V1_KeyToPath] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  /// Specify whether the ConfigMap or its keys must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Adapts a ConfigMap into a volume.
///
/// The contents of the target ConfigMap's Data field will be presented in a
/// volume as files using the keys in the Data field as the file names, unless
/// the items element is populated with specific mappings of keys to paths.
/// ConfigMap volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_ConfigMapVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// If unspecified, each key-value pair in the Data field of the referenced
  /// ConfigMap will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the ConfigMap,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  var items: [K8s_Io_Api_Core_V1_KeyToPath] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  /// Optional: mode bits to use on created files by default. Must be a
  /// value between 0 and 0777. Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var defaultMode: Int32 {
    get {return _storage._defaultMode ?? 0}
    set {_uniqueStorage()._defaultMode = newValue}
  }
  /// Returns true if `defaultMode` has been explicitly set.
  var hasDefaultMode: Bool {return _storage._defaultMode != nil}
  /// Clears the value of `defaultMode`. Subsequent reads from it will return its default value.
  mutating func clearDefaultMode() {_uniqueStorage()._defaultMode = nil}

  /// Specify whether the ConfigMap or its keys must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A single application container that you want to run within a pod.
struct K8s_Io_Api_Core_V1_Container {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the container specified as a DNS_LABEL.
  /// Each container in a pod must have a unique name (DNS_LABEL).
  /// Cannot be updated.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Docker image name.
  /// More info: https://kubernetes.io/docs/concepts/containers/images
  /// This field is optional to allow higher level config management to default or override
  /// container images in workload controllers like Deployments and StatefulSets.
  /// +optional
  var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Entrypoint array. Not executed within a shell.
  /// The docker image's ENTRYPOINT is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  /// regardless of whether the variable exists or not.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  var command: [String] {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  /// Arguments to the entrypoint.
  /// The docker image's CMD is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  /// regardless of whether the variable exists or not.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Container's working directory.
  /// If not specified, the container runtime's default will be used, which
  /// might be configured in the container image.
  /// Cannot be updated.
  /// +optional
  var workingDir: String {
    get {return _storage._workingDir ?? String()}
    set {_uniqueStorage()._workingDir = newValue}
  }
  /// Returns true if `workingDir` has been explicitly set.
  var hasWorkingDir: Bool {return _storage._workingDir != nil}
  /// Clears the value of `workingDir`. Subsequent reads from it will return its default value.
  mutating func clearWorkingDir() {_uniqueStorage()._workingDir = nil}

  /// List of ports to expose from the container. Exposing a port here gives
  /// the system additional information about the network connections a
  /// container uses, but is primarily informational. Not specifying a port here
  /// DOES NOT prevent that port from being exposed. Any port which is
  /// listening on the default "0.0.0.0" address inside a container will be
  /// accessible from the network.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=containerPort
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=containerPort
  /// +listMapKey=protocol
  var ports: [K8s_Io_Api_Core_V1_ContainerPort] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  /// List of sources to populate environment variables in the container.
  /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  /// will be reported as an event when the container is starting. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence.
  /// Values defined by an Env with a duplicate key will take precedence.
  /// Cannot be updated.
  /// +optional
  var envFrom: [K8s_Io_Api_Core_V1_EnvFromSource] {
    get {return _storage._envFrom}
    set {_uniqueStorage()._envFrom = newValue}
  }

  /// List of environment variables to set in the container.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var env: [K8s_Io_Api_Core_V1_EnvVar] {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  /// Compute Resources required by this container.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  /// +optional
  var resources: K8s_Io_Api_Core_V1_ResourceRequirements {
    get {return _storage._resources ?? K8s_Io_Api_Core_V1_ResourceRequirements()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// Pod volumes to mount into the container's filesystem.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=mountPath
  /// +patchStrategy=merge
  var volumeMounts: [K8s_Io_Api_Core_V1_VolumeMount] {
    get {return _storage._volumeMounts}
    set {_uniqueStorage()._volumeMounts = newValue}
  }

  /// volumeDevices is the list of block devices to be used by the container.
  /// This is a beta feature.
  /// +patchMergeKey=devicePath
  /// +patchStrategy=merge
  /// +optional
  var volumeDevices: [K8s_Io_Api_Core_V1_VolumeDevice] {
    get {return _storage._volumeDevices}
    set {_uniqueStorage()._volumeDevices = newValue}
  }

  /// Periodic probe of container liveness.
  /// Container will be restarted if the probe fails.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  var livenessProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._livenessProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._livenessProbe = newValue}
  }
  /// Returns true if `livenessProbe` has been explicitly set.
  var hasLivenessProbe: Bool {return _storage._livenessProbe != nil}
  /// Clears the value of `livenessProbe`. Subsequent reads from it will return its default value.
  mutating func clearLivenessProbe() {_uniqueStorage()._livenessProbe = nil}

  /// Periodic probe of container service readiness.
  /// Container will be removed from service endpoints if the probe fails.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  var readinessProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._readinessProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._readinessProbe = newValue}
  }
  /// Returns true if `readinessProbe` has been explicitly set.
  var hasReadinessProbe: Bool {return _storage._readinessProbe != nil}
  /// Clears the value of `readinessProbe`. Subsequent reads from it will return its default value.
  mutating func clearReadinessProbe() {_uniqueStorage()._readinessProbe = nil}

  /// StartupProbe indicates that the Pod has successfully initialized.
  /// If specified, no other probes are executed until this completes successfully.
  /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
  /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
  /// when it might take a long time to load data or warm a cache, than during steady-state operation.
  /// This cannot be updated.
  /// This is an alpha feature enabled by the StartupProbe feature flag.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  var startupProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._startupProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._startupProbe = newValue}
  }
  /// Returns true if `startupProbe` has been explicitly set.
  var hasStartupProbe: Bool {return _storage._startupProbe != nil}
  /// Clears the value of `startupProbe`. Subsequent reads from it will return its default value.
  mutating func clearStartupProbe() {_uniqueStorage()._startupProbe = nil}

  /// Actions that the management system should take in response to container lifecycle events.
  /// Cannot be updated.
  /// +optional
  var lifecycle: K8s_Io_Api_Core_V1_Lifecycle {
    get {return _storage._lifecycle ?? K8s_Io_Api_Core_V1_Lifecycle()}
    set {_uniqueStorage()._lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  var hasLifecycle: Bool {return _storage._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  mutating func clearLifecycle() {_uniqueStorage()._lifecycle = nil}

  /// Optional: Path at which the file to which the container's termination message
  /// will be written is mounted into the container's filesystem.
  /// Message written is intended to be brief final status, such as an assertion failure message.
  /// Will be truncated by the node if greater than 4096 bytes. The total message length across
  /// all containers will be limited to 12kb.
  /// Defaults to /dev/termination-log.
  /// Cannot be updated.
  /// +optional
  var terminationMessagePath: String {
    get {return _storage._terminationMessagePath ?? String()}
    set {_uniqueStorage()._terminationMessagePath = newValue}
  }
  /// Returns true if `terminationMessagePath` has been explicitly set.
  var hasTerminationMessagePath: Bool {return _storage._terminationMessagePath != nil}
  /// Clears the value of `terminationMessagePath`. Subsequent reads from it will return its default value.
  mutating func clearTerminationMessagePath() {_uniqueStorage()._terminationMessagePath = nil}

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination
  /// message file is empty and the container exited with an error.
  /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  /// Defaults to File.
  /// Cannot be updated.
  /// +optional
  var terminationMessagePolicy: String {
    get {return _storage._terminationMessagePolicy ?? String()}
    set {_uniqueStorage()._terminationMessagePolicy = newValue}
  }
  /// Returns true if `terminationMessagePolicy` has been explicitly set.
  var hasTerminationMessagePolicy: Bool {return _storage._terminationMessagePolicy != nil}
  /// Clears the value of `terminationMessagePolicy`. Subsequent reads from it will return its default value.
  mutating func clearTerminationMessagePolicy() {_uniqueStorage()._terminationMessagePolicy = nil}

  /// Image pull policy.
  /// One of Always, Never, IfNotPresent.
  /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  /// +optional
  var imagePullPolicy: String {
    get {return _storage._imagePullPolicy ?? String()}
    set {_uniqueStorage()._imagePullPolicy = newValue}
  }
  /// Returns true if `imagePullPolicy` has been explicitly set.
  var hasImagePullPolicy: Bool {return _storage._imagePullPolicy != nil}
  /// Clears the value of `imagePullPolicy`. Subsequent reads from it will return its default value.
  mutating func clearImagePullPolicy() {_uniqueStorage()._imagePullPolicy = nil}

  /// Security options the pod should run with.
  /// More info: https://kubernetes.io/docs/concepts/policy/security-context/
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  /// +optional
  var securityContext: K8s_Io_Api_Core_V1_SecurityContext {
    get {return _storage._securityContext ?? K8s_Io_Api_Core_V1_SecurityContext()}
    set {_uniqueStorage()._securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return _storage._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {_uniqueStorage()._securityContext = nil}

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this
  /// is not set, reads from stdin in the container will always result in EOF.
  /// Default is false.
  /// +optional
  var stdin: Bool {
    get {return _storage._stdin ?? false}
    set {_uniqueStorage()._stdin = newValue}
  }
  /// Returns true if `stdin` has been explicitly set.
  var hasStdin: Bool {return _storage._stdin != nil}
  /// Clears the value of `stdin`. Subsequent reads from it will return its default value.
  mutating func clearStdin() {_uniqueStorage()._stdin = nil}

  /// Whether the container runtime should close the stdin channel after it has been opened by
  /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
  /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  /// at which time stdin is closed and remains closed until the container is restarted. If this
  /// flag is false, a container processes that reads from stdin will never receive an EOF.
  /// Default is false
  /// +optional
  var stdinOnce: Bool {
    get {return _storage._stdinOnce ?? false}
    set {_uniqueStorage()._stdinOnce = newValue}
  }
  /// Returns true if `stdinOnce` has been explicitly set.
  var hasStdinOnce: Bool {return _storage._stdinOnce != nil}
  /// Clears the value of `stdinOnce`. Subsequent reads from it will return its default value.
  mutating func clearStdinOnce() {_uniqueStorage()._stdinOnce = nil}

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  /// Default is false.
  /// +optional
  var tty: Bool {
    get {return _storage._tty ?? false}
    set {_uniqueStorage()._tty = newValue}
  }
  /// Returns true if `tty` has been explicitly set.
  var hasTty: Bool {return _storage._tty != nil}
  /// Clears the value of `tty`. Subsequent reads from it will return its default value.
  mutating func clearTty() {_uniqueStorage()._tty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describe a container image
struct K8s_Io_Api_Core_V1_ContainerImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names by which this image is known.
  /// e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
  var names: [String] = []

  /// The size of the image in bytes.
  /// +optional
  var sizeBytes: Int64 {
    get {return _sizeBytes ?? 0}
    set {_sizeBytes = newValue}
  }
  /// Returns true if `sizeBytes` has been explicitly set.
  var hasSizeBytes: Bool {return self._sizeBytes != nil}
  /// Clears the value of `sizeBytes`. Subsequent reads from it will return its default value.
  mutating func clearSizeBytes() {self._sizeBytes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sizeBytes: Int64? = nil
}

/// ContainerPort represents a network port in a single container.
struct K8s_Io_Api_Core_V1_ContainerPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  /// named port in a pod must have a unique name. Name for the port that can be
  /// referred to by services.
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Number of port to expose on the host.
  /// If specified, this must be a valid port number, 0 < x < 65536.
  /// If HostNetwork is specified, this must match ContainerPort.
  /// Most containers do not need this.
  /// +optional
  var hostPort: Int32 {
    get {return _hostPort ?? 0}
    set {_hostPort = newValue}
  }
  /// Returns true if `hostPort` has been explicitly set.
  var hasHostPort: Bool {return self._hostPort != nil}
  /// Clears the value of `hostPort`. Subsequent reads from it will return its default value.
  mutating func clearHostPort() {self._hostPort = nil}

  /// Number of port to expose on the pod's IP address.
  /// This must be a valid port number, 0 < x < 65536.
  var containerPort: Int32 {
    get {return _containerPort ?? 0}
    set {_containerPort = newValue}
  }
  /// Returns true if `containerPort` has been explicitly set.
  var hasContainerPort: Bool {return self._containerPort != nil}
  /// Clears the value of `containerPort`. Subsequent reads from it will return its default value.
  mutating func clearContainerPort() {self._containerPort = nil}

  /// Protocol for port. Must be UDP, TCP, or SCTP.
  /// Defaults to "TCP".
  /// +optional
  var `protocol`: String {
    get {return _protocol ?? String()}
    set {_protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return self._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {self._protocol = nil}

  /// What host IP to bind the external port to.
  /// +optional
  var hostIp: String {
    get {return _hostIp ?? String()}
    set {_hostIp = newValue}
  }
  /// Returns true if `hostIp` has been explicitly set.
  var hasHostIp: Bool {return self._hostIp != nil}
  /// Clears the value of `hostIp`. Subsequent reads from it will return its default value.
  mutating func clearHostIp() {self._hostIp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _hostPort: Int32? = nil
  fileprivate var _containerPort: Int32? = nil
  fileprivate var _protocol: String? = nil
  fileprivate var _hostIp: String? = nil
}

/// ContainerState holds a possible state of container.
/// Only one of its members may be specified.
/// If none of them is specified, the default one is ContainerStateWaiting.
struct K8s_Io_Api_Core_V1_ContainerState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about a waiting container
  /// +optional
  var waiting: K8s_Io_Api_Core_V1_ContainerStateWaiting {
    get {return _storage._waiting ?? K8s_Io_Api_Core_V1_ContainerStateWaiting()}
    set {_uniqueStorage()._waiting = newValue}
  }
  /// Returns true if `waiting` has been explicitly set.
  var hasWaiting: Bool {return _storage._waiting != nil}
  /// Clears the value of `waiting`. Subsequent reads from it will return its default value.
  mutating func clearWaiting() {_uniqueStorage()._waiting = nil}

  /// Details about a running container
  /// +optional
  var running: K8s_Io_Api_Core_V1_ContainerStateRunning {
    get {return _storage._running ?? K8s_Io_Api_Core_V1_ContainerStateRunning()}
    set {_uniqueStorage()._running = newValue}
  }
  /// Returns true if `running` has been explicitly set.
  var hasRunning: Bool {return _storage._running != nil}
  /// Clears the value of `running`. Subsequent reads from it will return its default value.
  mutating func clearRunning() {_uniqueStorage()._running = nil}

  /// Details about a terminated container
  /// +optional
  var terminated: K8s_Io_Api_Core_V1_ContainerStateTerminated {
    get {return _storage._terminated ?? K8s_Io_Api_Core_V1_ContainerStateTerminated()}
    set {_uniqueStorage()._terminated = newValue}
  }
  /// Returns true if `terminated` has been explicitly set.
  var hasTerminated: Bool {return _storage._terminated != nil}
  /// Clears the value of `terminated`. Subsequent reads from it will return its default value.
  mutating func clearTerminated() {_uniqueStorage()._terminated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ContainerStateRunning is a running state of a container.
struct K8s_Io_Api_Core_V1_ContainerStateRunning {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time at which the container was last (re-)started
  /// +optional
  var startedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._startedAt ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  var hasStartedAt: Bool {return _storage._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  mutating func clearStartedAt() {_uniqueStorage()._startedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ContainerStateTerminated is a terminated state of a container.
struct K8s_Io_Api_Core_V1_ContainerStateTerminated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exit status from the last termination of the container
  var exitCode: Int32 {
    get {return _storage._exitCode ?? 0}
    set {_uniqueStorage()._exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  var hasExitCode: Bool {return _storage._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  mutating func clearExitCode() {_uniqueStorage()._exitCode = nil}

  /// Signal from the last termination of the container
  /// +optional
  var signal: Int32 {
    get {return _storage._signal ?? 0}
    set {_uniqueStorage()._signal = newValue}
  }
  /// Returns true if `signal` has been explicitly set.
  var hasSignal: Bool {return _storage._signal != nil}
  /// Clears the value of `signal`. Subsequent reads from it will return its default value.
  mutating func clearSignal() {_uniqueStorage()._signal = nil}

  /// (brief) reason from the last termination of the container
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Message regarding the last termination of the container
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// Time at which previous execution of the container started
  /// +optional
  var startedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._startedAt ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  var hasStartedAt: Bool {return _storage._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  mutating func clearStartedAt() {_uniqueStorage()._startedAt = nil}

  /// Time at which the container last terminated
  /// +optional
  var finishedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._finishedAt ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._finishedAt = newValue}
  }
  /// Returns true if `finishedAt` has been explicitly set.
  var hasFinishedAt: Bool {return _storage._finishedAt != nil}
  /// Clears the value of `finishedAt`. Subsequent reads from it will return its default value.
  mutating func clearFinishedAt() {_uniqueStorage()._finishedAt = nil}

  /// Container's ID in the format 'docker://<container_id>'
  /// +optional
  var containerID: String {
    get {return _storage._containerID ?? String()}
    set {_uniqueStorage()._containerID = newValue}
  }
  /// Returns true if `containerID` has been explicitly set.
  var hasContainerID: Bool {return _storage._containerID != nil}
  /// Clears the value of `containerID`. Subsequent reads from it will return its default value.
  mutating func clearContainerID() {_uniqueStorage()._containerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ContainerStateWaiting is a waiting state of a container.
struct K8s_Io_Api_Core_V1_ContainerStateWaiting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (brief) reason the container is not yet running.
  /// +optional
  var reason: String {
    get {return _reason ?? String()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  /// Message regarding why the container is not yet running.
  /// +optional
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reason: String? = nil
  fileprivate var _message: String? = nil
}

/// ContainerStatus contains details for the current status of this container.
struct K8s_Io_Api_Core_V1_ContainerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This must be a DNS_LABEL. Each container in a pod must have a unique name.
  /// Cannot be updated.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Details about the container's current condition.
  /// +optional
  var state: K8s_Io_Api_Core_V1_ContainerState {
    get {return _storage._state ?? K8s_Io_Api_Core_V1_ContainerState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  /// Details about the container's last termination condition.
  /// +optional
  var lastState: K8s_Io_Api_Core_V1_ContainerState {
    get {return _storage._lastState ?? K8s_Io_Api_Core_V1_ContainerState()}
    set {_uniqueStorage()._lastState = newValue}
  }
  /// Returns true if `lastState` has been explicitly set.
  var hasLastState: Bool {return _storage._lastState != nil}
  /// Clears the value of `lastState`. Subsequent reads from it will return its default value.
  mutating func clearLastState() {_uniqueStorage()._lastState = nil}

  /// Specifies whether the container has passed its readiness probe.
  var ready: Bool {
    get {return _storage._ready ?? false}
    set {_uniqueStorage()._ready = newValue}
  }
  /// Returns true if `ready` has been explicitly set.
  var hasReady: Bool {return _storage._ready != nil}
  /// Clears the value of `ready`. Subsequent reads from it will return its default value.
  mutating func clearReady() {_uniqueStorage()._ready = nil}

  /// The number of times the container has been restarted, currently based on
  /// the number of dead containers that have not yet been removed.
  /// Note that this is calculated from dead containers. But those containers are subject to
  /// garbage collection. This value will get capped at 5 by GC.
  var restartCount: Int32 {
    get {return _storage._restartCount ?? 0}
    set {_uniqueStorage()._restartCount = newValue}
  }
  /// Returns true if `restartCount` has been explicitly set.
  var hasRestartCount: Bool {return _storage._restartCount != nil}
  /// Clears the value of `restartCount`. Subsequent reads from it will return its default value.
  mutating func clearRestartCount() {_uniqueStorage()._restartCount = nil}

  /// The image the container is running.
  /// More info: https://kubernetes.io/docs/concepts/containers/images
  /// TODO(dchen1107): Which image the container is running with?
  var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// ImageID of the container's image.
  var imageID: String {
    get {return _storage._imageID ?? String()}
    set {_uniqueStorage()._imageID = newValue}
  }
  /// Returns true if `imageID` has been explicitly set.
  var hasImageID: Bool {return _storage._imageID != nil}
  /// Clears the value of `imageID`. Subsequent reads from it will return its default value.
  mutating func clearImageID() {_uniqueStorage()._imageID = nil}

  /// Container's ID in the format 'docker://<container_id>'.
  /// +optional
  var containerID: String {
    get {return _storage._containerID ?? String()}
    set {_uniqueStorage()._containerID = newValue}
  }
  /// Returns true if `containerID` has been explicitly set.
  var hasContainerID: Bool {return _storage._containerID != nil}
  /// Clears the value of `containerID`. Subsequent reads from it will return its default value.
  mutating func clearContainerID() {_uniqueStorage()._containerID = nil}

  /// Specifies whether the container has passed its startup probe.
  /// Initialized as false, becomes true after startupProbe is considered successful.
  /// Resets to false when the container is restarted, or if kubelet loses state temporarily.
  /// Is always true when no startupProbe is defined.
  /// +optional
  var started: Bool {
    get {return _storage._started ?? false}
    set {_uniqueStorage()._started = newValue}
  }
  /// Returns true if `started` has been explicitly set.
  var hasStarted: Bool {return _storage._started != nil}
  /// Clears the value of `started`. Subsequent reads from it will return its default value.
  mutating func clearStarted() {_uniqueStorage()._started = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DaemonEndpoint contains information about a single Daemon endpoint.
struct K8s_Io_Api_Core_V1_DaemonEndpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Port number of the given endpoint.
  var port: Int32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _port: Int32? = nil
}

/// Represents downward API info for projecting into a projected volume.
/// Note that this is identical to a downwardAPI volume source without the default
/// mode.
struct K8s_Io_Api_Core_V1_DownwardAPIProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Items is a list of DownwardAPIVolume file
  /// +optional
  var items: [K8s_Io_Api_Core_V1_DownwardAPIVolumeFile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
struct K8s_Io_Api_Core_V1_DownwardAPIVolumeFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  var path: String {
    get {return _storage._path ?? String()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  /// +optional
  var fieldRef: K8s_Io_Api_Core_V1_ObjectFieldSelector {
    get {return _storage._fieldRef ?? K8s_Io_Api_Core_V1_ObjectFieldSelector()}
    set {_uniqueStorage()._fieldRef = newValue}
  }
  /// Returns true if `fieldRef` has been explicitly set.
  var hasFieldRef: Bool {return _storage._fieldRef != nil}
  /// Clears the value of `fieldRef`. Subsequent reads from it will return its default value.
  mutating func clearFieldRef() {_uniqueStorage()._fieldRef = nil}

  /// Selects a resource of the container: only resources limits and requests
  /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  /// +optional
  var resourceFieldRef: K8s_Io_Api_Core_V1_ResourceFieldSelector {
    get {return _storage._resourceFieldRef ?? K8s_Io_Api_Core_V1_ResourceFieldSelector()}
    set {_uniqueStorage()._resourceFieldRef = newValue}
  }
  /// Returns true if `resourceFieldRef` has been explicitly set.
  var hasResourceFieldRef: Bool {return _storage._resourceFieldRef != nil}
  /// Clears the value of `resourceFieldRef`. Subsequent reads from it will return its default value.
  mutating func clearResourceFieldRef() {_uniqueStorage()._resourceFieldRef = nil}

  /// Optional: mode bits to use on this file, must be a value between 0
  /// and 0777. If not specified, the volume defaultMode will be used.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var mode: Int32 {
    get {return _storage._mode ?? 0}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DownwardAPIVolumeSource represents a volume containing downward API info.
/// Downward API volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_DownwardAPIVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Items is a list of downward API volume file
  /// +optional
  var items: [K8s_Io_Api_Core_V1_DownwardAPIVolumeFile] = []

  /// Optional: mode bits to use on created files by default. Must be a
  /// value between 0 and 0777. Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var defaultMode: Int32 {
    get {return _defaultMode ?? 0}
    set {_defaultMode = newValue}
  }
  /// Returns true if `defaultMode` has been explicitly set.
  var hasDefaultMode: Bool {return self._defaultMode != nil}
  /// Clears the value of `defaultMode`. Subsequent reads from it will return its default value.
  mutating func clearDefaultMode() {self._defaultMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultMode: Int32? = nil
}

/// Represents an empty directory for a pod.
/// Empty directory volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_EmptyDirVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// What type of storage medium should back this directory.
  /// The default is "" which means to use the node's default medium.
  /// Must be an empty string (default) or Memory.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  /// +optional
  var medium: String {
    get {return _storage._medium ?? String()}
    set {_uniqueStorage()._medium = newValue}
  }
  /// Returns true if `medium` has been explicitly set.
  var hasMedium: Bool {return _storage._medium != nil}
  /// Clears the value of `medium`. Subsequent reads from it will return its default value.
  mutating func clearMedium() {_uniqueStorage()._medium = nil}

  /// Total amount of local storage required for this EmptyDir volume.
  /// The size limit is also applicable for memory medium.
  /// The maximum usage on memory medium EmptyDir would be the minimum value between
  /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  /// The default is nil which means that the limit is undefined.
  /// More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  /// +optional
  var sizeLimit: K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity {
    get {return _storage._sizeLimit ?? K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity()}
    set {_uniqueStorage()._sizeLimit = newValue}
  }
  /// Returns true if `sizeLimit` has been explicitly set.
  var hasSizeLimit: Bool {return _storage._sizeLimit != nil}
  /// Clears the value of `sizeLimit`. Subsequent reads from it will return its default value.
  mutating func clearSizeLimit() {_uniqueStorage()._sizeLimit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EndpointAddress is a tuple that describes single IP address.
struct K8s_Io_Api_Core_V1_EndpointAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The IP of this endpoint.
  /// May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
  /// or link-local multicast ((224.0.0.0/24).
  /// IPv6 is also accepted but not fully supported on all platforms. Also, certain
  /// kubernetes components, like kube-proxy, are not IPv6 ready.
  /// TODO: This should allow hostname or IP, See #4447.
  var ip: String {
    get {return _storage._ip ?? String()}
    set {_uniqueStorage()._ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return _storage._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {_uniqueStorage()._ip = nil}

  /// The Hostname of this endpoint
  /// +optional
  var hostname: String {
    get {return _storage._hostname ?? String()}
    set {_uniqueStorage()._hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  var hasHostname: Bool {return _storage._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  mutating func clearHostname() {_uniqueStorage()._hostname = nil}

  /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  /// +optional
  var nodeName: String {
    get {return _storage._nodeName ?? String()}
    set {_uniqueStorage()._nodeName = newValue}
  }
  /// Returns true if `nodeName` has been explicitly set.
  var hasNodeName: Bool {return _storage._nodeName != nil}
  /// Clears the value of `nodeName`. Subsequent reads from it will return its default value.
  mutating func clearNodeName() {_uniqueStorage()._nodeName = nil}

  /// Reference to object providing the endpoint.
  /// +optional
  var targetRef: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._targetRef ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._targetRef = newValue}
  }
  /// Returns true if `targetRef` has been explicitly set.
  var hasTargetRef: Bool {return _storage._targetRef != nil}
  /// Clears the value of `targetRef`. Subsequent reads from it will return its default value.
  mutating func clearTargetRef() {_uniqueStorage()._targetRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EndpointPort is a tuple that describes a single port.
struct K8s_Io_Api_Core_V1_EndpointPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this port.  This must match the 'name' field in the
  /// corresponding ServicePort.
  /// Must be a DNS_LABEL.
  /// Optional only if one port is defined.
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The port number of the endpoint.
  var port: Int32 {
    get {return _port ?? 0}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  /// The IP protocol for this port.
  /// Must be UDP, TCP, or SCTP.
  /// Default is TCP.
  /// +optional
  var `protocol`: String {
    get {return _protocol ?? String()}
    set {_protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return self._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {self._protocol = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _port: Int32? = nil
  fileprivate var _protocol: String? = nil
}

/// EndpointSubset is a group of addresses with a common set of ports. The
/// expanded set of endpoints is the Cartesian product of Addresses x Ports.
/// For example, given:
///   {
///     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
///     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
///   }
/// The resulting set of endpoints can be viewed as:
///     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
///     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
struct K8s_Io_Api_Core_V1_EndpointSubset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IP addresses which offer the related ports that are marked as ready. These endpoints
  /// should be considered safe for load balancers and clients to utilize.
  /// +optional
  var addresses: [K8s_Io_Api_Core_V1_EndpointAddress] = []

  /// IP addresses which offer the related ports but are not currently marked as ready
  /// because they have not yet finished starting, have recently failed a readiness check,
  /// or have recently failed a liveness check.
  /// +optional
  var notReadyAddresses: [K8s_Io_Api_Core_V1_EndpointAddress] = []

  /// Port numbers available on the related IP addresses.
  /// +optional
  var ports: [K8s_Io_Api_Core_V1_EndpointPort] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Endpoints is a collection of endpoints that implement the actual service. Example:
///   Name: "mysvc",
///   Subsets: [
///     {
///       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
///       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
///     },
///     {
///       Addresses: [{"ip": "10.10.3.3"}],
///       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
///     },
///  ]
struct K8s_Io_Api_Core_V1_Endpoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The set of all endpoints is the union of all subsets. Addresses are placed into
  /// subsets according to the IPs they share. A single address with multiple ports,
  /// some of which are ready and some of which are not (because they come from
  /// different containers) will result in the address being displayed in different
  /// subsets for the different ports. No address will appear in both Addresses and
  /// NotReadyAddresses in the same subset.
  /// Sets of addresses and ports that comprise a service.
  /// +optional
  var subsets: [K8s_Io_Api_Core_V1_EndpointSubset] {
    get {return _storage._subsets}
    set {_uniqueStorage()._subsets = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EndpointsList is a list of endpoints.
struct K8s_Io_Api_Core_V1_EndpointsList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of endpoints.
  var items: [K8s_Io_Api_Core_V1_Endpoints] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EnvFromSource represents the source of a set of ConfigMaps
struct K8s_Io_Api_Core_V1_EnvFromSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  /// +optional
  var prefix: String {
    get {return _storage._prefix ?? String()}
    set {_uniqueStorage()._prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Bool {return _storage._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating func clearPrefix() {_uniqueStorage()._prefix = nil}

  /// The ConfigMap to select from
  /// +optional
  var configMapRef: K8s_Io_Api_Core_V1_ConfigMapEnvSource {
    get {return _storage._configMapRef ?? K8s_Io_Api_Core_V1_ConfigMapEnvSource()}
    set {_uniqueStorage()._configMapRef = newValue}
  }
  /// Returns true if `configMapRef` has been explicitly set.
  var hasConfigMapRef: Bool {return _storage._configMapRef != nil}
  /// Clears the value of `configMapRef`. Subsequent reads from it will return its default value.
  mutating func clearConfigMapRef() {_uniqueStorage()._configMapRef = nil}

  /// The Secret to select from
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretEnvSource {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretEnvSource()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EnvVar represents an environment variable present in a Container.
struct K8s_Io_Api_Core_V1_EnvVar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the environment variable. Must be a C_IDENTIFIER.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Variable references $(VAR_NAME) are expanded
  /// using the previous defined environment variables in the container and
  /// any service environment variables. If a variable cannot be resolved,
  /// the reference in the input string will be unchanged. The $(VAR_NAME)
  /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  /// references will never be expanded, regardless of whether the variable
  /// exists or not.
  /// Defaults to "".
  /// +optional
  var value: String {
    get {return _storage._value ?? String()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  /// Source for the environment variable's value. Cannot be used if value is not empty.
  /// +optional
  var valueFrom: K8s_Io_Api_Core_V1_EnvVarSource {
    get {return _storage._valueFrom ?? K8s_Io_Api_Core_V1_EnvVarSource()}
    set {_uniqueStorage()._valueFrom = newValue}
  }
  /// Returns true if `valueFrom` has been explicitly set.
  var hasValueFrom: Bool {return _storage._valueFrom != nil}
  /// Clears the value of `valueFrom`. Subsequent reads from it will return its default value.
  mutating func clearValueFrom() {_uniqueStorage()._valueFrom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EnvVarSource represents a source for the value of an EnvVar.
struct K8s_Io_Api_Core_V1_EnvVarSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
  /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP.
  /// +optional
  var fieldRef: K8s_Io_Api_Core_V1_ObjectFieldSelector {
    get {return _storage._fieldRef ?? K8s_Io_Api_Core_V1_ObjectFieldSelector()}
    set {_uniqueStorage()._fieldRef = newValue}
  }
  /// Returns true if `fieldRef` has been explicitly set.
  var hasFieldRef: Bool {return _storage._fieldRef != nil}
  /// Clears the value of `fieldRef`. Subsequent reads from it will return its default value.
  mutating func clearFieldRef() {_uniqueStorage()._fieldRef = nil}

  /// Selects a resource of the container: only resources limits and requests
  /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  /// +optional
  var resourceFieldRef: K8s_Io_Api_Core_V1_ResourceFieldSelector {
    get {return _storage._resourceFieldRef ?? K8s_Io_Api_Core_V1_ResourceFieldSelector()}
    set {_uniqueStorage()._resourceFieldRef = newValue}
  }
  /// Returns true if `resourceFieldRef` has been explicitly set.
  var hasResourceFieldRef: Bool {return _storage._resourceFieldRef != nil}
  /// Clears the value of `resourceFieldRef`. Subsequent reads from it will return its default value.
  mutating func clearResourceFieldRef() {_uniqueStorage()._resourceFieldRef = nil}

  /// Selects a key of a ConfigMap.
  /// +optional
  var configMapKeyRef: K8s_Io_Api_Core_V1_ConfigMapKeySelector {
    get {return _storage._configMapKeyRef ?? K8s_Io_Api_Core_V1_ConfigMapKeySelector()}
    set {_uniqueStorage()._configMapKeyRef = newValue}
  }
  /// Returns true if `configMapKeyRef` has been explicitly set.
  var hasConfigMapKeyRef: Bool {return _storage._configMapKeyRef != nil}
  /// Clears the value of `configMapKeyRef`. Subsequent reads from it will return its default value.
  mutating func clearConfigMapKeyRef() {_uniqueStorage()._configMapKeyRef = nil}

  /// Selects a key of a secret in the pod's namespace
  /// +optional
  var secretKeyRef: K8s_Io_Api_Core_V1_SecretKeySelector {
    get {return _storage._secretKeyRef ?? K8s_Io_Api_Core_V1_SecretKeySelector()}
    set {_uniqueStorage()._secretKeyRef = newValue}
  }
  /// Returns true if `secretKeyRef` has been explicitly set.
  var hasSecretKeyRef: Bool {return _storage._secretKeyRef != nil}
  /// Clears the value of `secretKeyRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretKeyRef() {_uniqueStorage()._secretKeyRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An EphemeralContainer is a container that may be added temporarily to an existing pod for
/// user-initiated activities such as debugging. Ephemeral containers have no resource or
/// scheduling guarantees, and they will not be restarted when they exit or when a pod is
/// removed or restarted. If an ephemeral container causes a pod to exceed its resource
/// allocation, the pod may be evicted.
/// Ephemeral containers may not be added by directly updating the pod spec. They must be added
/// via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
/// once added.
/// This is an alpha feature enabled by the EphemeralContainers feature flag.
struct K8s_Io_Api_Core_V1_EphemeralContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ephemeral containers have all of the fields of Container, plus additional fields
  /// specific to ephemeral containers. Fields in common with Container are in the
  /// following inlined struct so than an EphemeralContainer may easily be converted
  /// to a Container.
  var ephemeralContainerCommon: K8s_Io_Api_Core_V1_EphemeralContainerCommon {
    get {return _storage._ephemeralContainerCommon ?? K8s_Io_Api_Core_V1_EphemeralContainerCommon()}
    set {_uniqueStorage()._ephemeralContainerCommon = newValue}
  }
  /// Returns true if `ephemeralContainerCommon` has been explicitly set.
  var hasEphemeralContainerCommon: Bool {return _storage._ephemeralContainerCommon != nil}
  /// Clears the value of `ephemeralContainerCommon`. Subsequent reads from it will return its default value.
  mutating func clearEphemeralContainerCommon() {_uniqueStorage()._ephemeralContainerCommon = nil}

  /// If set, the name of the container from PodSpec that this ephemeral container targets.
  /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
  /// If not set then the ephemeral container is run in whatever namespaces are shared
  /// for the pod. Note that the container runtime must support this feature.
  /// +optional
  var targetContainerName: String {
    get {return _storage._targetContainerName ?? String()}
    set {_uniqueStorage()._targetContainerName = newValue}
  }
  /// Returns true if `targetContainerName` has been explicitly set.
  var hasTargetContainerName: Bool {return _storage._targetContainerName != nil}
  /// Clears the value of `targetContainerName`. Subsequent reads from it will return its default value.
  mutating func clearTargetContainerName() {_uniqueStorage()._targetContainerName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EphemeralContainerCommon is a copy of all fields in Container to be inlined in
/// EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
/// to Container and allows separate documentation for the fields of EphemeralContainer.
/// When a new field is added to Container it must be added here as well.
struct K8s_Io_Api_Core_V1_EphemeralContainerCommon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the ephemeral container specified as a DNS_LABEL.
  /// This name must be unique among all containers, init containers and ephemeral containers.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// Docker image name.
  /// More info: https://kubernetes.io/docs/concepts/containers/images
  var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Entrypoint array. Not executed within a shell.
  /// The docker image's ENTRYPOINT is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  /// regardless of whether the variable exists or not.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  var command: [String] {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  /// Arguments to the entrypoint.
  /// The docker image's CMD is used if this is not provided.
  /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  /// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  /// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  /// regardless of whether the variable exists or not.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  /// +optional
  var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Container's working directory.
  /// If not specified, the container runtime's default will be used, which
  /// might be configured in the container image.
  /// Cannot be updated.
  /// +optional
  var workingDir: String {
    get {return _storage._workingDir ?? String()}
    set {_uniqueStorage()._workingDir = newValue}
  }
  /// Returns true if `workingDir` has been explicitly set.
  var hasWorkingDir: Bool {return _storage._workingDir != nil}
  /// Clears the value of `workingDir`. Subsequent reads from it will return its default value.
  mutating func clearWorkingDir() {_uniqueStorage()._workingDir = nil}

  /// Ports are not allowed for ephemeral containers.
  var ports: [K8s_Io_Api_Core_V1_ContainerPort] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  /// List of sources to populate environment variables in the container.
  /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  /// will be reported as an event when the container is starting. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence.
  /// Values defined by an Env with a duplicate key will take precedence.
  /// Cannot be updated.
  /// +optional
  var envFrom: [K8s_Io_Api_Core_V1_EnvFromSource] {
    get {return _storage._envFrom}
    set {_uniqueStorage()._envFrom = newValue}
  }

  /// List of environment variables to set in the container.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var env: [K8s_Io_Api_Core_V1_EnvVar] {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
  /// already allocated to the pod.
  /// +optional
  var resources: K8s_Io_Api_Core_V1_ResourceRequirements {
    get {return _storage._resources ?? K8s_Io_Api_Core_V1_ResourceRequirements()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// Pod volumes to mount into the container's filesystem.
  /// Cannot be updated.
  /// +optional
  /// +patchMergeKey=mountPath
  /// +patchStrategy=merge
  var volumeMounts: [K8s_Io_Api_Core_V1_VolumeMount] {
    get {return _storage._volumeMounts}
    set {_uniqueStorage()._volumeMounts = newValue}
  }

  /// volumeDevices is the list of block devices to be used by the container.
  /// This is a beta feature.
  /// +patchMergeKey=devicePath
  /// +patchStrategy=merge
  /// +optional
  var volumeDevices: [K8s_Io_Api_Core_V1_VolumeDevice] {
    get {return _storage._volumeDevices}
    set {_uniqueStorage()._volumeDevices = newValue}
  }

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  var livenessProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._livenessProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._livenessProbe = newValue}
  }
  /// Returns true if `livenessProbe` has been explicitly set.
  var hasLivenessProbe: Bool {return _storage._livenessProbe != nil}
  /// Clears the value of `livenessProbe`. Subsequent reads from it will return its default value.
  mutating func clearLivenessProbe() {_uniqueStorage()._livenessProbe = nil}

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  var readinessProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._readinessProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._readinessProbe = newValue}
  }
  /// Returns true if `readinessProbe` has been explicitly set.
  var hasReadinessProbe: Bool {return _storage._readinessProbe != nil}
  /// Clears the value of `readinessProbe`. Subsequent reads from it will return its default value.
  mutating func clearReadinessProbe() {_uniqueStorage()._readinessProbe = nil}

  /// Probes are not allowed for ephemeral containers.
  /// +optional
  var startupProbe: K8s_Io_Api_Core_V1_Probe {
    get {return _storage._startupProbe ?? K8s_Io_Api_Core_V1_Probe()}
    set {_uniqueStorage()._startupProbe = newValue}
  }
  /// Returns true if `startupProbe` has been explicitly set.
  var hasStartupProbe: Bool {return _storage._startupProbe != nil}
  /// Clears the value of `startupProbe`. Subsequent reads from it will return its default value.
  mutating func clearStartupProbe() {_uniqueStorage()._startupProbe = nil}

  /// Lifecycle is not allowed for ephemeral containers.
  /// +optional
  var lifecycle: K8s_Io_Api_Core_V1_Lifecycle {
    get {return _storage._lifecycle ?? K8s_Io_Api_Core_V1_Lifecycle()}
    set {_uniqueStorage()._lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  var hasLifecycle: Bool {return _storage._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  mutating func clearLifecycle() {_uniqueStorage()._lifecycle = nil}

  /// Optional: Path at which the file to which the container's termination message
  /// will be written is mounted into the container's filesystem.
  /// Message written is intended to be brief final status, such as an assertion failure message.
  /// Will be truncated by the node if greater than 4096 bytes. The total message length across
  /// all containers will be limited to 12kb.
  /// Defaults to /dev/termination-log.
  /// Cannot be updated.
  /// +optional
  var terminationMessagePath: String {
    get {return _storage._terminationMessagePath ?? String()}
    set {_uniqueStorage()._terminationMessagePath = newValue}
  }
  /// Returns true if `terminationMessagePath` has been explicitly set.
  var hasTerminationMessagePath: Bool {return _storage._terminationMessagePath != nil}
  /// Clears the value of `terminationMessagePath`. Subsequent reads from it will return its default value.
  mutating func clearTerminationMessagePath() {_uniqueStorage()._terminationMessagePath = nil}

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination
  /// message file is empty and the container exited with an error.
  /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  /// Defaults to File.
  /// Cannot be updated.
  /// +optional
  var terminationMessagePolicy: String {
    get {return _storage._terminationMessagePolicy ?? String()}
    set {_uniqueStorage()._terminationMessagePolicy = newValue}
  }
  /// Returns true if `terminationMessagePolicy` has been explicitly set.
  var hasTerminationMessagePolicy: Bool {return _storage._terminationMessagePolicy != nil}
  /// Clears the value of `terminationMessagePolicy`. Subsequent reads from it will return its default value.
  mutating func clearTerminationMessagePolicy() {_uniqueStorage()._terminationMessagePolicy = nil}

  /// Image pull policy.
  /// One of Always, Never, IfNotPresent.
  /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  /// +optional
  var imagePullPolicy: String {
    get {return _storage._imagePullPolicy ?? String()}
    set {_uniqueStorage()._imagePullPolicy = newValue}
  }
  /// Returns true if `imagePullPolicy` has been explicitly set.
  var hasImagePullPolicy: Bool {return _storage._imagePullPolicy != nil}
  /// Clears the value of `imagePullPolicy`. Subsequent reads from it will return its default value.
  mutating func clearImagePullPolicy() {_uniqueStorage()._imagePullPolicy = nil}

  /// SecurityContext is not allowed for ephemeral containers.
  /// +optional
  var securityContext: K8s_Io_Api_Core_V1_SecurityContext {
    get {return _storage._securityContext ?? K8s_Io_Api_Core_V1_SecurityContext()}
    set {_uniqueStorage()._securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return _storage._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {_uniqueStorage()._securityContext = nil}

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this
  /// is not set, reads from stdin in the container will always result in EOF.
  /// Default is false.
  /// +optional
  var stdin: Bool {
    get {return _storage._stdin ?? false}
    set {_uniqueStorage()._stdin = newValue}
  }
  /// Returns true if `stdin` has been explicitly set.
  var hasStdin: Bool {return _storage._stdin != nil}
  /// Clears the value of `stdin`. Subsequent reads from it will return its default value.
  mutating func clearStdin() {_uniqueStorage()._stdin = nil}

  /// Whether the container runtime should close the stdin channel after it has been opened by
  /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
  /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  /// at which time stdin is closed and remains closed until the container is restarted. If this
  /// flag is false, a container processes that reads from stdin will never receive an EOF.
  /// Default is false
  /// +optional
  var stdinOnce: Bool {
    get {return _storage._stdinOnce ?? false}
    set {_uniqueStorage()._stdinOnce = newValue}
  }
  /// Returns true if `stdinOnce` has been explicitly set.
  var hasStdinOnce: Bool {return _storage._stdinOnce != nil}
  /// Clears the value of `stdinOnce`. Subsequent reads from it will return its default value.
  mutating func clearStdinOnce() {_uniqueStorage()._stdinOnce = nil}

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  /// Default is false.
  /// +optional
  var tty: Bool {
    get {return _storage._tty ?? false}
    set {_uniqueStorage()._tty = newValue}
  }
  /// Returns true if `tty` has been explicitly set.
  var hasTty: Bool {return _storage._tty != nil}
  /// Clears the value of `tty`. Subsequent reads from it will return its default value.
  mutating func clearTty() {_uniqueStorage()._tty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of ephemeral containers used with the Pod ephemeralcontainers subresource.
struct K8s_Io_Api_Core_V1_EphemeralContainers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// A list of ephemeral containers associated with this pod. New ephemeral containers
  /// may be appended to this list, but existing ephemeral containers may not be removed
  /// or modified.
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var ephemeralContainers: [K8s_Io_Api_Core_V1_EphemeralContainer] {
    get {return _storage._ephemeralContainers}
    set {_uniqueStorage()._ephemeralContainers = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Event is a report of an event somewhere in the cluster.
struct K8s_Io_Api_Core_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The object that this event is about.
  var involvedObject: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._involvedObject ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._involvedObject = newValue}
  }
  /// Returns true if `involvedObject` has been explicitly set.
  var hasInvolvedObject: Bool {return _storage._involvedObject != nil}
  /// Clears the value of `involvedObject`. Subsequent reads from it will return its default value.
  mutating func clearInvolvedObject() {_uniqueStorage()._involvedObject = nil}

  /// This should be a short, machine understandable string that gives the reason
  /// for the transition into the object's current status.
  /// TODO: provide exact specification for format.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human-readable description of the status of this operation.
  /// TODO: decide on maximum length.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// The component reporting this event. Should be a short machine understandable string.
  /// +optional
  var source: K8s_Io_Api_Core_V1_EventSource {
    get {return _storage._source ?? K8s_Io_Api_Core_V1_EventSource()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
  /// +optional
  var firstTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._firstTimestamp ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._firstTimestamp = newValue}
  }
  /// Returns true if `firstTimestamp` has been explicitly set.
  var hasFirstTimestamp: Bool {return _storage._firstTimestamp != nil}
  /// Clears the value of `firstTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearFirstTimestamp() {_uniqueStorage()._firstTimestamp = nil}

  /// The time at which the most recent occurrence of this event was recorded.
  /// +optional
  var lastTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTimestamp ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTimestamp = newValue}
  }
  /// Returns true if `lastTimestamp` has been explicitly set.
  var hasLastTimestamp: Bool {return _storage._lastTimestamp != nil}
  /// Clears the value of `lastTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastTimestamp() {_uniqueStorage()._lastTimestamp = nil}

  /// The number of times this event has occurred.
  /// +optional
  var count: Int32 {
    get {return _storage._count ?? 0}
    set {_uniqueStorage()._count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return _storage._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {_uniqueStorage()._count = nil}

  /// Type of this event (Normal, Warning), new types could be added in the future
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Time when this Event was first observed.
  /// +optional
  var eventTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime {
    get {return _storage._eventTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime()}
    set {_uniqueStorage()._eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  var hasEventTime: Bool {return _storage._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  mutating func clearEventTime() {_uniqueStorage()._eventTime = nil}

  /// Data about the Event series this event represents or nil if it's a singleton Event.
  /// +optional
  var series: K8s_Io_Api_Core_V1_EventSeries {
    get {return _storage._series ?? K8s_Io_Api_Core_V1_EventSeries()}
    set {_uniqueStorage()._series = newValue}
  }
  /// Returns true if `series` has been explicitly set.
  var hasSeries: Bool {return _storage._series != nil}
  /// Clears the value of `series`. Subsequent reads from it will return its default value.
  mutating func clearSeries() {_uniqueStorage()._series = nil}

  /// What action was taken/failed regarding to the Regarding object.
  /// +optional
  var action: String {
    get {return _storage._action ?? String()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {_uniqueStorage()._action = nil}

  /// Optional secondary object for more complex actions.
  /// +optional
  var related: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._related ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._related = newValue}
  }
  /// Returns true if `related` has been explicitly set.
  var hasRelated: Bool {return _storage._related != nil}
  /// Clears the value of `related`. Subsequent reads from it will return its default value.
  mutating func clearRelated() {_uniqueStorage()._related = nil}

  /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
  /// +optional
  var reportingComponent: String {
    get {return _storage._reportingComponent ?? String()}
    set {_uniqueStorage()._reportingComponent = newValue}
  }
  /// Returns true if `reportingComponent` has been explicitly set.
  var hasReportingComponent: Bool {return _storage._reportingComponent != nil}
  /// Clears the value of `reportingComponent`. Subsequent reads from it will return its default value.
  mutating func clearReportingComponent() {_uniqueStorage()._reportingComponent = nil}

  /// ID of the controller instance, e.g. `kubelet-xyzf`.
  /// +optional
  var reportingInstance: String {
    get {return _storage._reportingInstance ?? String()}
    set {_uniqueStorage()._reportingInstance = newValue}
  }
  /// Returns true if `reportingInstance` has been explicitly set.
  var hasReportingInstance: Bool {return _storage._reportingInstance != nil}
  /// Clears the value of `reportingInstance`. Subsequent reads from it will return its default value.
  mutating func clearReportingInstance() {_uniqueStorage()._reportingInstance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EventList is a list of events.
struct K8s_Io_Api_Core_V1_EventList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of events
  var items: [K8s_Io_Api_Core_V1_Event] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EventSeries contain information on series of events, i.e. thing that was/is happening
/// continuously for some time.
struct K8s_Io_Api_Core_V1_EventSeries {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of occurrences in this series up to the last heartbeat time
  var count: Int32 {
    get {return _storage._count ?? 0}
    set {_uniqueStorage()._count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return _storage._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {_uniqueStorage()._count = nil}

  /// Time of the last occurrence observed
  var lastObservedTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime {
    get {return _storage._lastObservedTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime()}
    set {_uniqueStorage()._lastObservedTime = newValue}
  }
  /// Returns true if `lastObservedTime` has been explicitly set.
  var hasLastObservedTime: Bool {return _storage._lastObservedTime != nil}
  /// Clears the value of `lastObservedTime`. Subsequent reads from it will return its default value.
  mutating func clearLastObservedTime() {_uniqueStorage()._lastObservedTime = nil}

  /// State of this Series: Ongoing or Finished
  /// Deprecated. Planned removal for 1.18
  var state: String {
    get {return _storage._state ?? String()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// EventSource contains information for an event.
struct K8s_Io_Api_Core_V1_EventSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Component from which the event is generated.
  /// +optional
  var component: String {
    get {return _component ?? String()}
    set {_component = newValue}
  }
  /// Returns true if `component` has been explicitly set.
  var hasComponent: Bool {return self._component != nil}
  /// Clears the value of `component`. Subsequent reads from it will return its default value.
  mutating func clearComponent() {self._component = nil}

  /// Node name on which the event is generated.
  /// +optional
  var host: String {
    get {return _host ?? String()}
    set {_host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return self._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {self._host = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _component: String? = nil
  fileprivate var _host: String? = nil
}

/// ExecAction describes a "run in container" action.
struct K8s_Io_Api_Core_V1_ExecAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Command is the command line to execute inside the container, the working directory for the
  /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  /// a shell, you need to explicitly call out to that shell.
  /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  /// +optional
  var command: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Fibre Channel volume.
/// Fibre Channel volumes can only be mounted as read/write once.
/// Fibre Channel volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_FCVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional: FC target worldwide names (WWNs)
  /// +optional
  var targetWwns: [String] = []

  /// Optional: FC target lun number
  /// +optional
  var lun: Int32 {
    get {return _lun ?? 0}
    set {_lun = newValue}
  }
  /// Returns true if `lun` has been explicitly set.
  var hasLun: Bool {return self._lun != nil}
  /// Clears the value of `lun`. Subsequent reads from it will return its default value.
  mutating func clearLun() {self._lun = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// Optional: FC volume world wide identifiers (wwids)
  /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  /// +optional
  var wwids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lun: Int32? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// FlexPersistentVolumeSource represents a generic persistent volume resource that is
/// provisioned/attached using an exec based plugin.
struct K8s_Io_Api_Core_V1_FlexPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Driver is the name of the driver to use for this volume.
  var driver: String {
    get {return _storage._driver ?? String()}
    set {_uniqueStorage()._driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return _storage._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {_uniqueStorage()._driver = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Optional: SecretRef is reference to the secret object containing
  /// sensitive information to pass to the plugin scripts. This may be
  /// empty if no secret object is specified. If the secret object
  /// contains more than one secret, all secrets are passed to the plugin
  /// scripts.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Optional: Extra command options if any.
  /// +optional
  var options: Dictionary<String,String> {
    get {return _storage._options}
    set {_uniqueStorage()._options = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FlexVolume represents a generic volume resource that is
/// provisioned/attached using an exec based plugin.
struct K8s_Io_Api_Core_V1_FlexVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Driver is the name of the driver to use for this volume.
  var driver: String {
    get {return _storage._driver ?? String()}
    set {_uniqueStorage()._driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return _storage._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {_uniqueStorage()._driver = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Optional: SecretRef is reference to the secret object containing
  /// sensitive information to pass to the plugin scripts. This may be
  /// empty if no secret object is specified. If the secret object
  /// contains more than one secret, all secrets are passed to the plugin
  /// scripts.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Optional: Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// Optional: Extra command options if any.
  /// +optional
  var options: Dictionary<String,String> {
    get {return _storage._options}
    set {_uniqueStorage()._options = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a Flocker volume mounted by the Flocker agent.
/// One and only one of datasetName and datasetUUID should be set.
/// Flocker volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_FlockerVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the dataset stored as metadata -> name on the dataset for Flocker
  /// should be considered as deprecated
  /// +optional
  var datasetName: String {
    get {return _datasetName ?? String()}
    set {_datasetName = newValue}
  }
  /// Returns true if `datasetName` has been explicitly set.
  var hasDatasetName: Bool {return self._datasetName != nil}
  /// Clears the value of `datasetName`. Subsequent reads from it will return its default value.
  mutating func clearDatasetName() {self._datasetName = nil}

  /// UUID of the dataset. This is unique identifier of a Flocker dataset
  /// +optional
  var datasetUuid: String {
    get {return _datasetUuid ?? String()}
    set {_datasetUuid = newValue}
  }
  /// Returns true if `datasetUuid` has been explicitly set.
  var hasDatasetUuid: Bool {return self._datasetUuid != nil}
  /// Clears the value of `datasetUuid`. Subsequent reads from it will return its default value.
  mutating func clearDatasetUuid() {self._datasetUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datasetName: String? = nil
  fileprivate var _datasetUuid: String? = nil
}

/// Represents a Persistent Disk resource in Google Compute Engine.
///
/// A GCE PD must exist before mounting to a container. The disk must
/// also be in the same GCE project and zone as the kubelet. A GCE PD
/// can only be mounted as read/write once or read-only many times. GCE
/// PDs support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  var pdName: String {
    get {return _pdName ?? String()}
    set {_pdName = newValue}
  }
  /// Returns true if `pdName` has been explicitly set.
  var hasPdName: Bool {return self._pdName != nil}
  /// Clears the value of `pdName`. Subsequent reads from it will return its default value.
  mutating func clearPdName() {self._pdName = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// The partition in the volume that you want to mount.
  /// If omitted, the default is to mount by volume name.
  /// Examples: For volume /dev/sda1, you specify the partition as "1".
  /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  var partition: Int32 {
    get {return _partition ?? 0}
    set {_partition = newValue}
  }
  /// Returns true if `partition` has been explicitly set.
  var hasPartition: Bool {return self._partition != nil}
  /// Clears the value of `partition`. Subsequent reads from it will return its default value.
  mutating func clearPartition() {self._partition = nil}

  /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pdName: String? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _partition: Int32? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Represents a volume that is populated with the contents of a git repository.
/// Git repo volumes do not support ownership management.
/// Git repo volumes support SELinux relabeling.
///
/// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
/// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
/// into the Pod's container.
struct K8s_Io_Api_Core_V1_GitRepoVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Repository URL
  var repository: String {
    get {return _repository ?? String()}
    set {_repository = newValue}
  }
  /// Returns true if `repository` has been explicitly set.
  var hasRepository: Bool {return self._repository != nil}
  /// Clears the value of `repository`. Subsequent reads from it will return its default value.
  mutating func clearRepository() {self._repository = nil}

  /// Commit hash for the specified revision.
  /// +optional
  var revision: String {
    get {return _revision ?? String()}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  /// Target directory name.
  /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  /// git repository.  Otherwise, if specified, the volume will contain the git repository in
  /// the subdirectory with the given name.
  /// +optional
  var directory: String {
    get {return _directory ?? String()}
    set {_directory = newValue}
  }
  /// Returns true if `directory` has been explicitly set.
  var hasDirectory: Bool {return self._directory != nil}
  /// Clears the value of `directory`. Subsequent reads from it will return its default value.
  mutating func clearDirectory() {self._directory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _repository: String? = nil
  fileprivate var _revision: String? = nil
  fileprivate var _directory: String? = nil
}

/// Represents a Glusterfs mount that lasts the lifetime of a pod.
/// Glusterfs volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// EndpointsName is the endpoint name that details Glusterfs topology.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  var endpoints: String {
    get {return _endpoints ?? String()}
    set {_endpoints = newValue}
  }
  /// Returns true if `endpoints` has been explicitly set.
  var hasEndpoints: Bool {return self._endpoints != nil}
  /// Clears the value of `endpoints`. Subsequent reads from it will return its default value.
  mutating func clearEndpoints() {self._endpoints = nil}

  /// Path is the Glusterfs volume path.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// EndpointsNamespace is the namespace that contains Glusterfs endpoint.
  /// If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  var endpointsNamespace: String {
    get {return _endpointsNamespace ?? String()}
    set {_endpointsNamespace = newValue}
  }
  /// Returns true if `endpointsNamespace` has been explicitly set.
  var hasEndpointsNamespace: Bool {return self._endpointsNamespace != nil}
  /// Clears the value of `endpointsNamespace`. Subsequent reads from it will return its default value.
  mutating func clearEndpointsNamespace() {self._endpointsNamespace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _endpoints: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _readOnly: Bool? = nil
  fileprivate var _endpointsNamespace: String? = nil
}

/// Represents a Glusterfs mount that lasts the lifetime of a pod.
/// Glusterfs volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_GlusterfsVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// EndpointsName is the endpoint name that details Glusterfs topology.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  var endpoints: String {
    get {return _endpoints ?? String()}
    set {_endpoints = newValue}
  }
  /// Returns true if `endpoints` has been explicitly set.
  var hasEndpoints: Bool {return self._endpoints != nil}
  /// Clears the value of `endpoints`. Subsequent reads from it will return its default value.
  mutating func clearEndpoints() {self._endpoints = nil}

  /// Path is the Glusterfs volume path.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _endpoints: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// HTTPGetAction describes an action based on HTTP Get requests.
struct K8s_Io_Api_Core_V1_HTTPGetAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to access on the HTTP server.
  /// +optional
  var path: String {
    get {return _storage._path ?? String()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {_uniqueStorage()._path = nil}

  /// Name or number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  /// Name must be an IANA_SVC_NAME.
  var port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._port ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return _storage._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {_uniqueStorage()._port = nil}

  /// Host name to connect to, defaults to the pod IP. You probably want to set
  /// "Host" in httpHeaders instead.
  /// +optional
  var host: String {
    get {return _storage._host ?? String()}
    set {_uniqueStorage()._host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return _storage._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {_uniqueStorage()._host = nil}

  /// Scheme to use for connecting to the host.
  /// Defaults to HTTP.
  /// +optional
  var scheme: String {
    get {return _storage._scheme ?? String()}
    set {_uniqueStorage()._scheme = newValue}
  }
  /// Returns true if `scheme` has been explicitly set.
  var hasScheme: Bool {return _storage._scheme != nil}
  /// Clears the value of `scheme`. Subsequent reads from it will return its default value.
  mutating func clearScheme() {_uniqueStorage()._scheme = nil}

  /// Custom headers to set in the request. HTTP allows repeated headers.
  /// +optional
  var httpHeaders: [K8s_Io_Api_Core_V1_HTTPHeader] {
    get {return _storage._httpHeaders}
    set {_uniqueStorage()._httpHeaders = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HTTPHeader describes a custom header to be used in HTTP probes
struct K8s_Io_Api_Core_V1_HTTPHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The header field name
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The header field value
  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: String? = nil
}

/// Handler defines a specific action that should be taken
/// TODO: pass structured data to these actions, and document that data here.
struct K8s_Io_Api_Core_V1_Handler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One and only one of the following should be specified.
  /// Exec specifies the action to take.
  /// +optional
  var exec: K8s_Io_Api_Core_V1_ExecAction {
    get {return _storage._exec ?? K8s_Io_Api_Core_V1_ExecAction()}
    set {_uniqueStorage()._exec = newValue}
  }
  /// Returns true if `exec` has been explicitly set.
  var hasExec: Bool {return _storage._exec != nil}
  /// Clears the value of `exec`. Subsequent reads from it will return its default value.
  mutating func clearExec() {_uniqueStorage()._exec = nil}

  /// HTTPGet specifies the http request to perform.
  /// +optional
  var httpGet: K8s_Io_Api_Core_V1_HTTPGetAction {
    get {return _storage._httpGet ?? K8s_Io_Api_Core_V1_HTTPGetAction()}
    set {_uniqueStorage()._httpGet = newValue}
  }
  /// Returns true if `httpGet` has been explicitly set.
  var hasHTTPGet: Bool {return _storage._httpGet != nil}
  /// Clears the value of `httpGet`. Subsequent reads from it will return its default value.
  mutating func clearHTTPGet() {_uniqueStorage()._httpGet = nil}

  /// TCPSocket specifies an action involving a TCP port.
  /// TCP hooks not yet supported
  /// TODO: implement a realistic TCP lifecycle hook
  /// +optional
  var tcpSocket: K8s_Io_Api_Core_V1_TCPSocketAction {
    get {return _storage._tcpSocket ?? K8s_Io_Api_Core_V1_TCPSocketAction()}
    set {_uniqueStorage()._tcpSocket = newValue}
  }
  /// Returns true if `tcpSocket` has been explicitly set.
  var hasTcpSocket: Bool {return _storage._tcpSocket != nil}
  /// Clears the value of `tcpSocket`. Subsequent reads from it will return its default value.
  mutating func clearTcpSocket() {_uniqueStorage()._tcpSocket = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
/// pod's hosts file.
struct K8s_Io_Api_Core_V1_HostAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IP address of the host file entry.
  var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  /// Hostnames for the above IP address.
  var hostnames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ip: String? = nil
}

/// Represents a host path mapped into a pod.
/// Host path volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_HostPathVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the directory on the host.
  /// If the path is a symlink, it will follow the link to the real path.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// Type for HostPath Volume
  /// Defaults to ""
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// +optional
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
  fileprivate var _type: String? = nil
}

/// ISCSIPersistentVolumeSource represents an ISCSI disk.
/// ISCSI volumes can only be mounted as read/write once.
/// ISCSI volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  var targetPortal: String {
    get {return _storage._targetPortal ?? String()}
    set {_uniqueStorage()._targetPortal = newValue}
  }
  /// Returns true if `targetPortal` has been explicitly set.
  var hasTargetPortal: Bool {return _storage._targetPortal != nil}
  /// Clears the value of `targetPortal`. Subsequent reads from it will return its default value.
  mutating func clearTargetPortal() {_uniqueStorage()._targetPortal = nil}

  /// Target iSCSI Qualified Name.
  var iqn: String {
    get {return _storage._iqn ?? String()}
    set {_uniqueStorage()._iqn = newValue}
  }
  /// Returns true if `iqn` has been explicitly set.
  var hasIqn: Bool {return _storage._iqn != nil}
  /// Clears the value of `iqn`. Subsequent reads from it will return its default value.
  mutating func clearIqn() {_uniqueStorage()._iqn = nil}

  /// iSCSI Target Lun number.
  var lun: Int32 {
    get {return _storage._lun ?? 0}
    set {_uniqueStorage()._lun = newValue}
  }
  /// Returns true if `lun` has been explicitly set.
  var hasLun: Bool {return _storage._lun != nil}
  /// Clears the value of `lun`. Subsequent reads from it will return its default value.
  mutating func clearLun() {_uniqueStorage()._lun = nil}

  /// iSCSI Interface Name that uses an iSCSI transport.
  /// Defaults to 'default' (tcp).
  /// +optional
  var iscsiInterface: String {
    get {return _storage._iscsiInterface ?? String()}
    set {_uniqueStorage()._iscsiInterface = newValue}
  }
  /// Returns true if `iscsiInterface` has been explicitly set.
  var hasIscsiInterface: Bool {return _storage._iscsiInterface != nil}
  /// Clears the value of `iscsiInterface`. Subsequent reads from it will return its default value.
  mutating func clearIscsiInterface() {_uniqueStorage()._iscsiInterface = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  /// +optional
  var portals: [String] {
    get {return _storage._portals}
    set {_uniqueStorage()._portals = newValue}
  }

  /// whether support iSCSI Discovery CHAP authentication
  /// +optional
  var chapAuthDiscovery: Bool {
    get {return _storage._chapAuthDiscovery ?? false}
    set {_uniqueStorage()._chapAuthDiscovery = newValue}
  }
  /// Returns true if `chapAuthDiscovery` has been explicitly set.
  var hasChapAuthDiscovery: Bool {return _storage._chapAuthDiscovery != nil}
  /// Clears the value of `chapAuthDiscovery`. Subsequent reads from it will return its default value.
  mutating func clearChapAuthDiscovery() {_uniqueStorage()._chapAuthDiscovery = nil}

  /// whether support iSCSI Session CHAP authentication
  /// +optional
  var chapAuthSession: Bool {
    get {return _storage._chapAuthSession ?? false}
    set {_uniqueStorage()._chapAuthSession = newValue}
  }
  /// Returns true if `chapAuthSession` has been explicitly set.
  var hasChapAuthSession: Bool {return _storage._chapAuthSession != nil}
  /// Clears the value of `chapAuthSession`. Subsequent reads from it will return its default value.
  mutating func clearChapAuthSession() {_uniqueStorage()._chapAuthSession = nil}

  /// CHAP Secret for iSCSI target and initiator authentication
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Custom iSCSI Initiator Name.
  /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  /// <target portal>:<volume name> will be created for the connection.
  /// +optional
  var initiatorName: String {
    get {return _storage._initiatorName ?? String()}
    set {_uniqueStorage()._initiatorName = newValue}
  }
  /// Returns true if `initiatorName` has been explicitly set.
  var hasInitiatorName: Bool {return _storage._initiatorName != nil}
  /// Clears the value of `initiatorName`. Subsequent reads from it will return its default value.
  mutating func clearInitiatorName() {_uniqueStorage()._initiatorName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents an ISCSI disk.
/// ISCSI volumes can only be mounted as read/write once.
/// ISCSI volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_ISCSIVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  var targetPortal: String {
    get {return _storage._targetPortal ?? String()}
    set {_uniqueStorage()._targetPortal = newValue}
  }
  /// Returns true if `targetPortal` has been explicitly set.
  var hasTargetPortal: Bool {return _storage._targetPortal != nil}
  /// Clears the value of `targetPortal`. Subsequent reads from it will return its default value.
  mutating func clearTargetPortal() {_uniqueStorage()._targetPortal = nil}

  /// Target iSCSI Qualified Name.
  var iqn: String {
    get {return _storage._iqn ?? String()}
    set {_uniqueStorage()._iqn = newValue}
  }
  /// Returns true if `iqn` has been explicitly set.
  var hasIqn: Bool {return _storage._iqn != nil}
  /// Clears the value of `iqn`. Subsequent reads from it will return its default value.
  mutating func clearIqn() {_uniqueStorage()._iqn = nil}

  /// iSCSI Target Lun number.
  var lun: Int32 {
    get {return _storage._lun ?? 0}
    set {_uniqueStorage()._lun = newValue}
  }
  /// Returns true if `lun` has been explicitly set.
  var hasLun: Bool {return _storage._lun != nil}
  /// Clears the value of `lun`. Subsequent reads from it will return its default value.
  mutating func clearLun() {_uniqueStorage()._lun = nil}

  /// iSCSI Interface Name that uses an iSCSI transport.
  /// Defaults to 'default' (tcp).
  /// +optional
  var iscsiInterface: String {
    get {return _storage._iscsiInterface ?? String()}
    set {_uniqueStorage()._iscsiInterface = newValue}
  }
  /// Returns true if `iscsiInterface` has been explicitly set.
  var hasIscsiInterface: Bool {return _storage._iscsiInterface != nil}
  /// Clears the value of `iscsiInterface`. Subsequent reads from it will return its default value.
  mutating func clearIscsiInterface() {_uniqueStorage()._iscsiInterface = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
  /// is other than default (typically TCP ports 860 and 3260).
  /// +optional
  var portals: [String] {
    get {return _storage._portals}
    set {_uniqueStorage()._portals = newValue}
  }

  /// whether support iSCSI Discovery CHAP authentication
  /// +optional
  var chapAuthDiscovery: Bool {
    get {return _storage._chapAuthDiscovery ?? false}
    set {_uniqueStorage()._chapAuthDiscovery = newValue}
  }
  /// Returns true if `chapAuthDiscovery` has been explicitly set.
  var hasChapAuthDiscovery: Bool {return _storage._chapAuthDiscovery != nil}
  /// Clears the value of `chapAuthDiscovery`. Subsequent reads from it will return its default value.
  mutating func clearChapAuthDiscovery() {_uniqueStorage()._chapAuthDiscovery = nil}

  /// whether support iSCSI Session CHAP authentication
  /// +optional
  var chapAuthSession: Bool {
    get {return _storage._chapAuthSession ?? false}
    set {_uniqueStorage()._chapAuthSession = newValue}
  }
  /// Returns true if `chapAuthSession` has been explicitly set.
  var hasChapAuthSession: Bool {return _storage._chapAuthSession != nil}
  /// Clears the value of `chapAuthSession`. Subsequent reads from it will return its default value.
  mutating func clearChapAuthSession() {_uniqueStorage()._chapAuthSession = nil}

  /// CHAP Secret for iSCSI target and initiator authentication
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Custom iSCSI Initiator Name.
  /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  /// <target portal>:<volume name> will be created for the connection.
  /// +optional
  var initiatorName: String {
    get {return _storage._initiatorName ?? String()}
    set {_uniqueStorage()._initiatorName = newValue}
  }
  /// Returns true if `initiatorName` has been explicitly set.
  var hasInitiatorName: Bool {return _storage._initiatorName != nil}
  /// Clears the value of `initiatorName`. Subsequent reads from it will return its default value.
  mutating func clearInitiatorName() {_uniqueStorage()._initiatorName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Maps a string key to a path within a volume.
struct K8s_Io_Api_Core_V1_KeyToPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key to project.
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// The relative path of the file to map the key to.
  /// May not be an absolute path.
  /// May not contain the path element '..'.
  /// May not start with the string '..'.
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// Optional: mode bits to use on this file, must be a value between 0
  /// and 0777. If not specified, the volume defaultMode will be used.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var mode: Int32 {
    get {return _mode ?? 0}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _mode: Int32? = nil
}

/// Lifecycle describes actions that the management system should take in response to container lifecycle
/// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
/// until the action is complete, unless the container process fails, in which case the handler is aborted.
struct K8s_Io_Api_Core_V1_Lifecycle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PostStart is called immediately after a container is created. If the handler fails,
  /// the container is terminated and restarted according to its restart policy.
  /// Other management of the container blocks until the hook completes.
  /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  /// +optional
  var postStart: K8s_Io_Api_Core_V1_Handler {
    get {return _storage._postStart ?? K8s_Io_Api_Core_V1_Handler()}
    set {_uniqueStorage()._postStart = newValue}
  }
  /// Returns true if `postStart` has been explicitly set.
  var hasPostStart: Bool {return _storage._postStart != nil}
  /// Clears the value of `postStart`. Subsequent reads from it will return its default value.
  mutating func clearPostStart() {_uniqueStorage()._postStart = nil}

  /// PreStop is called immediately before a container is terminated due to an
  /// API request or management event such as liveness/startup probe failure,
  /// preemption, resource contention, etc. The handler is not called if the
  /// container crashes or exits. The reason for termination is passed to the
  /// handler. The Pod's termination grace period countdown begins before the
  /// PreStop hooked is executed. Regardless of the outcome of the handler, the
  /// container will eventually terminate within the Pod's termination grace
  /// period. Other management of the container blocks until the hook completes
  /// or until the termination grace period is reached.
  /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  /// +optional
  var preStop: K8s_Io_Api_Core_V1_Handler {
    get {return _storage._preStop ?? K8s_Io_Api_Core_V1_Handler()}
    set {_uniqueStorage()._preStop = newValue}
  }
  /// Returns true if `preStop` has been explicitly set.
  var hasPreStop: Bool {return _storage._preStop != nil}
  /// Clears the value of `preStop`. Subsequent reads from it will return its default value.
  mutating func clearPreStop() {_uniqueStorage()._preStop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LimitRange sets resource usage limits for each kind of resource in a Namespace.
struct K8s_Io_Api_Core_V1_LimitRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the limits enforced.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_LimitRangeSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_LimitRangeSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
struct K8s_Io_Api_Core_V1_LimitRangeItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of resource that this limit applies to.
  /// +optional
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Max usage constraints on this kind by resource name.
  /// +optional
  var max: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// Min usage constraints on this kind by resource name.
  /// +optional
  var min: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// Default resource requirement limit value by resource name if resource limit is omitted.
  /// +optional
  var `default`: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
  /// +optional
  var defaultRequest: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
  /// +optional
  var maxLimitRequestRatio: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: String? = nil
}

/// LimitRangeList is a list of LimitRange items.
struct K8s_Io_Api_Core_V1_LimitRangeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of LimitRange objects.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  var items: [K8s_Io_Api_Core_V1_LimitRange] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
struct K8s_Io_Api_Core_V1_LimitRangeSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limits is the list of LimitRangeItem objects that are enforced.
  var limits: [K8s_Io_Api_Core_V1_LimitRangeItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// List holds a list of objects, which may not be known by the server.
struct K8s_Io_Api_Core_V1_List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of objects
  var items: [K8s_Io_Apimachinery_Pkg_Runtime_RawExtension] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LoadBalancerIngress represents the status of a load-balancer ingress point:
/// traffic intended for the service should be sent to an ingress point.
struct K8s_Io_Api_Core_V1_LoadBalancerIngress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IP is set for load-balancer ingress points that are IP based
  /// (typically GCE or OpenStack load-balancers)
  /// +optional
  var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  /// Hostname is set for load-balancer ingress points that are DNS based
  /// (typically AWS load-balancers)
  /// +optional
  var hostname: String {
    get {return _hostname ?? String()}
    set {_hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  var hasHostname: Bool {return self._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  mutating func clearHostname() {self._hostname = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ip: String? = nil
  fileprivate var _hostname: String? = nil
}

/// LoadBalancerStatus represents the status of a load-balancer.
struct K8s_Io_Api_Core_V1_LoadBalancerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ingress is a list containing ingress points for the load-balancer.
  /// Traffic intended for the service should be sent to these ingress points.
  /// +optional
  var ingress: [K8s_Io_Api_Core_V1_LoadBalancerIngress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LocalObjectReference contains enough information to let you locate the
/// referenced object inside the same namespace.
struct K8s_Io_Api_Core_V1_LocalObjectReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  /// TODO: Add other useful fields. apiVersion, kind, uid?
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
}

/// Local represents directly-attached storage with node affinity (Beta feature)
struct K8s_Io_Api_Core_V1_LocalVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full path to the volume on the node.
  /// It can be either a directory or block device (disk, partition, ...).
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// Filesystem type to mount.
  /// It applies only when the Path is a block device.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a fileystem if unspecified.
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
  fileprivate var _fsType: String? = nil
}

/// Represents an NFS mount that lasts the lifetime of a pod.
/// NFS volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_NFSVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server is the hostname or IP address of the NFS server.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  var server: String {
    get {return _server ?? String()}
    set {_server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return self._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {self._server = nil}

  /// Path that is exported by the NFS server.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  /// ReadOnly here will force
  /// the NFS export to be mounted with read-only permissions.
  /// Defaults to false.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _server: String? = nil
  fileprivate var _path: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Namespace provides a scope for Names.
/// Use of multiple namespaces is optional.
struct K8s_Io_Api_Core_V1_Namespace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the behavior of the Namespace.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_NamespaceSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_NamespaceSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status describes the current status of a Namespace.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_NamespaceStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_NamespaceStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NamespaceCondition contains details about state of namespace.
struct K8s_Io_Api_Core_V1_NamespaceCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of namespace controller condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NamespaceList is a list of Namespaces.
struct K8s_Io_Api_Core_V1_NamespaceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of Namespace objects in the list.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  var items: [K8s_Io_Api_Core_V1_Namespace] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NamespaceSpec describes the attributes on a Namespace.
struct K8s_Io_Api_Core_V1_NamespaceSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
  /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  /// +optional
  var finalizers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NamespaceStatus is information about the current status of a Namespace.
struct K8s_Io_Api_Core_V1_NamespaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Phase is the current lifecycle phase of the namespace.
  /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  /// +optional
  var phase: String {
    get {return _phase ?? String()}
    set {_phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return self._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {self._phase = nil}

  /// Represents the latest available observations of a namespace's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_NamespaceCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _phase: String? = nil
}

/// Node is a worker node in Kubernetes.
/// Each node will have a unique identifier in the cache (i.e. in etcd).
struct K8s_Io_Api_Core_V1_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the behavior of a node.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_NodeSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_NodeSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the node.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_NodeStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_NodeStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeAddress contains information for the node's address.
struct K8s_Io_Api_Core_V1_NodeAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node address type, one of Hostname, ExternalIP or InternalIP.
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// The node address.
  var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: String? = nil
  fileprivate var _address: String? = nil
}

/// Node affinity is a group of node affinity scheduling rules.
struct K8s_Io_Api_Core_V1_NodeAffinity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to an update), the system
  /// may or may not try to eventually evict the pod from its node.
  /// +optional
  var requiredDuringSchedulingIgnoredDuringExecution: K8s_Io_Api_Core_V1_NodeSelector {
    get {return _storage._requiredDuringSchedulingIgnoredDuringExecution ?? K8s_Io_Api_Core_V1_NodeSelector()}
    set {_uniqueStorage()._requiredDuringSchedulingIgnoredDuringExecution = newValue}
  }
  /// Returns true if `requiredDuringSchedulingIgnoredDuringExecution` has been explicitly set.
  var hasRequiredDuringSchedulingIgnoredDuringExecution: Bool {return _storage._requiredDuringSchedulingIgnoredDuringExecution != nil}
  /// Clears the value of `requiredDuringSchedulingIgnoredDuringExecution`. Subsequent reads from it will return its default value.
  mutating func clearRequiredDuringSchedulingIgnoredDuringExecution() {_uniqueStorage()._requiredDuringSchedulingIgnoredDuringExecution = nil}

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node matches the corresponding matchExpressions; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  var preferredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_PreferredSchedulingTerm] {
    get {return _storage._preferredDuringSchedulingIgnoredDuringExecution}
    set {_uniqueStorage()._preferredDuringSchedulingIgnoredDuringExecution = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeCondition contains condition information for a node.
struct K8s_Io_Api_Core_V1_NodeCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of node condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Last time we got an update on a given condition.
  /// +optional
  var lastHeartbeatTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastHeartbeatTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastHeartbeatTime = newValue}
  }
  /// Returns true if `lastHeartbeatTime` has been explicitly set.
  var hasLastHeartbeatTime: Bool {return _storage._lastHeartbeatTime != nil}
  /// Clears the value of `lastHeartbeatTime`. Subsequent reads from it will return its default value.
  mutating func clearLastHeartbeatTime() {_uniqueStorage()._lastHeartbeatTime = nil}

  /// Last time the condition transit from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// (brief) reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Human readable message indicating details about last transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
struct K8s_Io_Api_Core_V1_NodeConfigSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConfigMap is a reference to a Node's ConfigMap
  var configMap: K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource {
    get {return _storage._configMap ?? K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource()}
    set {_uniqueStorage()._configMap = newValue}
  }
  /// Returns true if `configMap` has been explicitly set.
  var hasConfigMap: Bool {return _storage._configMap != nil}
  /// Clears the value of `configMap`. Subsequent reads from it will return its default value.
  mutating func clearConfigMap() {_uniqueStorage()._configMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
struct K8s_Io_Api_Core_V1_NodeConfigStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Assigned reports the checkpointed config the node will try to use.
  /// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
  /// config payload to local disk, along with a record indicating intended
  /// config. The node refers to this record to choose its config checkpoint, and
  /// reports this record in Assigned. Assigned only updates in the status after
  /// the record has been checkpointed to disk. When the Kubelet is restarted,
  /// it tries to make the Assigned config the Active config by loading and
  /// validating the checkpointed payload identified by Assigned.
  /// +optional
  var assigned: K8s_Io_Api_Core_V1_NodeConfigSource {
    get {return _storage._assigned ?? K8s_Io_Api_Core_V1_NodeConfigSource()}
    set {_uniqueStorage()._assigned = newValue}
  }
  /// Returns true if `assigned` has been explicitly set.
  var hasAssigned: Bool {return _storage._assigned != nil}
  /// Clears the value of `assigned`. Subsequent reads from it will return its default value.
  mutating func clearAssigned() {_uniqueStorage()._assigned = nil}

  /// Active reports the checkpointed config the node is actively using.
  /// Active will represent either the current version of the Assigned config,
  /// or the current LastKnownGood config, depending on whether attempting to use the
  /// Assigned config results in an error.
  /// +optional
  var active: K8s_Io_Api_Core_V1_NodeConfigSource {
    get {return _storage._active ?? K8s_Io_Api_Core_V1_NodeConfigSource()}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {_uniqueStorage()._active = nil}

  /// LastKnownGood reports the checkpointed config the node will fall back to
  /// when it encounters an error attempting to use the Assigned config.
  /// The Assigned config becomes the LastKnownGood config when the node determines
  /// that the Assigned config is stable and correct.
  /// This is currently implemented as a 10-minute soak period starting when the local
  /// record of Assigned config is updated. If the Assigned config is Active at the end
  /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
  /// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
  /// because the local default config is always assumed good.
  /// You should not make assumptions about the node's method of determining config stability
  /// and correctness, as this may change or become configurable in the future.
  /// +optional
  var lastKnownGood: K8s_Io_Api_Core_V1_NodeConfigSource {
    get {return _storage._lastKnownGood ?? K8s_Io_Api_Core_V1_NodeConfigSource()}
    set {_uniqueStorage()._lastKnownGood = newValue}
  }
  /// Returns true if `lastKnownGood` has been explicitly set.
  var hasLastKnownGood: Bool {return _storage._lastKnownGood != nil}
  /// Clears the value of `lastKnownGood`. Subsequent reads from it will return its default value.
  mutating func clearLastKnownGood() {_uniqueStorage()._lastKnownGood = nil}

  /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
  /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
  /// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
  /// to load or validate the Assigned config, etc.
  /// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
  /// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
  /// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
  /// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
  /// by fixing the config assigned in Spec.ConfigSource.
  /// You can find additional information for debugging by searching the error message in the Kubelet log.
  /// Error is a human-readable description of the error state; machines can check whether or not Error
  /// is empty, but should not rely on the stability of the Error text across Kubelet versions.
  /// +optional
  var error: String {
    get {return _storage._error ?? String()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
struct K8s_Io_Api_Core_V1_NodeDaemonEndpoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint on which Kubelet is listening.
  /// +optional
  var kubeletEndpoint: K8s_Io_Api_Core_V1_DaemonEndpoint {
    get {return _storage._kubeletEndpoint ?? K8s_Io_Api_Core_V1_DaemonEndpoint()}
    set {_uniqueStorage()._kubeletEndpoint = newValue}
  }
  /// Returns true if `kubeletEndpoint` has been explicitly set.
  var hasKubeletEndpoint: Bool {return _storage._kubeletEndpoint != nil}
  /// Clears the value of `kubeletEndpoint`. Subsequent reads from it will return its default value.
  mutating func clearKubeletEndpoint() {_uniqueStorage()._kubeletEndpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeList is the whole list of all Nodes which have been registered with master.
struct K8s_Io_Api_Core_V1_NodeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of nodes
  var items: [K8s_Io_Api_Core_V1_Node] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeProxyOptions is the query options to a Node's proxy call.
struct K8s_Io_Api_Core_V1_NodeProxyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path is the URL path to use for the current proxy request to node.
  /// +optional
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
}

/// NodeResources is an object for conveying resource information about a node.
/// see http://releases.k8s.io/HEAD/docs/design/resources.md for more details.
struct K8s_Io_Api_Core_V1_NodeResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Capacity represents the available resources of a node
  var capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A node selector represents the union of the results of one or more label queries
/// over a set of nodes; that is, it represents the OR of the selectors represented
/// by the node selector terms.
struct K8s_Io_Api_Core_V1_NodeSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A list of node selector terms. The terms are ORed.
  var nodeSelectorTerms: [K8s_Io_Api_Core_V1_NodeSelectorTerm] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A node selector requirement is a selector that contains values, a key, and an operator
/// that relates the key and values.
struct K8s_Io_Api_Core_V1_NodeSelectorRequirement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label key that the selector applies to.
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// Represents a key's relationship to a set of values.
  /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  var `operator`: String {
    get {return _operator ?? String()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  /// An array of string values. If the operator is In or NotIn,
  /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
  /// the values array must be empty. If the operator is Gt or Lt, the values
  /// array must have a single element, which will be interpreted as an integer.
  /// This array is replaced during a strategic merge patch.
  /// +optional
  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _operator: String? = nil
}

/// A null or empty node selector term matches no objects. The requirements of
/// them are ANDed.
/// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
struct K8s_Io_Api_Core_V1_NodeSelectorTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of node selector requirements by node's labels.
  /// +optional
  var matchExpressions: [K8s_Io_Api_Core_V1_NodeSelectorRequirement] = []

  /// A list of node selector requirements by node's fields.
  /// +optional
  var matchFields: [K8s_Io_Api_Core_V1_NodeSelectorRequirement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NodeSpec describes the attributes that a node is created with.
struct K8s_Io_Api_Core_V1_NodeSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PodCIDR represents the pod IP range assigned to the node.
  /// +optional
  var podCidr: String {
    get {return _storage._podCidr ?? String()}
    set {_uniqueStorage()._podCidr = newValue}
  }
  /// Returns true if `podCidr` has been explicitly set.
  var hasPodCidr: Bool {return _storage._podCidr != nil}
  /// Clears the value of `podCidr`. Subsequent reads from it will return its default value.
  mutating func clearPodCidr() {_uniqueStorage()._podCidr = nil}

  /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
  /// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
  /// each of IPv4 and IPv6.
  /// +optional
  /// +patchStrategy=merge
  var podCidrs: [String] {
    get {return _storage._podCidrs}
    set {_uniqueStorage()._podCidrs = newValue}
  }

  /// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
  /// +optional
  var providerID: String {
    get {return _storage._providerID ?? String()}
    set {_uniqueStorage()._providerID = newValue}
  }
  /// Returns true if `providerID` has been explicitly set.
  var hasProviderID: Bool {return _storage._providerID != nil}
  /// Clears the value of `providerID`. Subsequent reads from it will return its default value.
  mutating func clearProviderID() {_uniqueStorage()._providerID = nil}

  /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
  /// +optional
  var unschedulable: Bool {
    get {return _storage._unschedulable ?? false}
    set {_uniqueStorage()._unschedulable = newValue}
  }
  /// Returns true if `unschedulable` has been explicitly set.
  var hasUnschedulable: Bool {return _storage._unschedulable != nil}
  /// Clears the value of `unschedulable`. Subsequent reads from it will return its default value.
  mutating func clearUnschedulable() {_uniqueStorage()._unschedulable = nil}

  /// If specified, the node's taints.
  /// +optional
  var taints: [K8s_Io_Api_Core_V1_Taint] {
    get {return _storage._taints}
    set {_uniqueStorage()._taints = newValue}
  }

  /// If specified, the source to get node configuration from
  /// The DynamicKubeletConfig feature gate must be enabled for the Kubelet to use this field
  /// +optional
  var configSource: K8s_Io_Api_Core_V1_NodeConfigSource {
    get {return _storage._configSource ?? K8s_Io_Api_Core_V1_NodeConfigSource()}
    set {_uniqueStorage()._configSource = newValue}
  }
  /// Returns true if `configSource` has been explicitly set.
  var hasConfigSource: Bool {return _storage._configSource != nil}
  /// Clears the value of `configSource`. Subsequent reads from it will return its default value.
  mutating func clearConfigSource() {_uniqueStorage()._configSource = nil}

  /// Deprecated. Not all kubelets will set this field. Remove field after 1.13.
  /// see: https://issues.k8s.io/61966
  /// +optional
  var externalID: String {
    get {return _storage._externalID ?? String()}
    set {_uniqueStorage()._externalID = newValue}
  }
  /// Returns true if `externalID` has been explicitly set.
  var hasExternalID: Bool {return _storage._externalID != nil}
  /// Clears the value of `externalID`. Subsequent reads from it will return its default value.
  mutating func clearExternalID() {_uniqueStorage()._externalID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeStatus is information about the current status of a node.
struct K8s_Io_Api_Core_V1_NodeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Capacity represents the total resources of a node.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  /// +optional
  var capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  /// Allocatable represents the resources of a node that are available for scheduling.
  /// Defaults to Capacity.
  /// +optional
  var allocatable: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> {
    get {return _storage._allocatable}
    set {_uniqueStorage()._allocatable = newValue}
  }

  /// NodePhase is the recently observed lifecycle phase of the node.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
  /// The field is never populated, and now is deprecated.
  /// +optional
  var phase: String {
    get {return _storage._phase ?? String()}
    set {_uniqueStorage()._phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return _storage._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {_uniqueStorage()._phase = nil}

  /// Conditions is an array of current observed node conditions.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_NodeCondition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  /// List of addresses reachable to the node.
  /// Queried from cloud provider, if available.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
  /// Note: This field is declared as mergeable, but the merge key is not sufficiently
  /// unique, which can cause data corruption when it is merged. Callers should instead
  /// use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var addresses: [K8s_Io_Api_Core_V1_NodeAddress] {
    get {return _storage._addresses}
    set {_uniqueStorage()._addresses = newValue}
  }

  /// Endpoints of daemons running on the Node.
  /// +optional
  var daemonEndpoints: K8s_Io_Api_Core_V1_NodeDaemonEndpoints {
    get {return _storage._daemonEndpoints ?? K8s_Io_Api_Core_V1_NodeDaemonEndpoints()}
    set {_uniqueStorage()._daemonEndpoints = newValue}
  }
  /// Returns true if `daemonEndpoints` has been explicitly set.
  var hasDaemonEndpoints: Bool {return _storage._daemonEndpoints != nil}
  /// Clears the value of `daemonEndpoints`. Subsequent reads from it will return its default value.
  mutating func clearDaemonEndpoints() {_uniqueStorage()._daemonEndpoints = nil}

  /// Set of ids/uuids to uniquely identify the node.
  /// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
  /// +optional
  var nodeInfo: K8s_Io_Api_Core_V1_NodeSystemInfo {
    get {return _storage._nodeInfo ?? K8s_Io_Api_Core_V1_NodeSystemInfo()}
    set {_uniqueStorage()._nodeInfo = newValue}
  }
  /// Returns true if `nodeInfo` has been explicitly set.
  var hasNodeInfo: Bool {return _storage._nodeInfo != nil}
  /// Clears the value of `nodeInfo`. Subsequent reads from it will return its default value.
  mutating func clearNodeInfo() {_uniqueStorage()._nodeInfo = nil}

  /// List of container images on this node
  /// +optional
  var images: [K8s_Io_Api_Core_V1_ContainerImage] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  /// List of attachable volumes in use (mounted) by the node.
  /// +optional
  var volumesInUse: [String] {
    get {return _storage._volumesInUse}
    set {_uniqueStorage()._volumesInUse = newValue}
  }

  /// List of volumes that are attached to the node.
  /// +optional
  var volumesAttached: [K8s_Io_Api_Core_V1_AttachedVolume] {
    get {return _storage._volumesAttached}
    set {_uniqueStorage()._volumesAttached = newValue}
  }

  /// Status of the config assigned to the node via the dynamic Kubelet config feature.
  /// +optional
  var config: K8s_Io_Api_Core_V1_NodeConfigStatus {
    get {return _storage._config ?? K8s_Io_Api_Core_V1_NodeConfigStatus()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
struct K8s_Io_Api_Core_V1_NodeSystemInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MachineID reported by the node. For unique machine identification
  /// in the cluster this field is preferred. Learn more from man(5)
  /// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
  var machineID: String {
    get {return _machineID ?? String()}
    set {_machineID = newValue}
  }
  /// Returns true if `machineID` has been explicitly set.
  var hasMachineID: Bool {return self._machineID != nil}
  /// Clears the value of `machineID`. Subsequent reads from it will return its default value.
  mutating func clearMachineID() {self._machineID = nil}

  /// SystemUUID reported by the node. For unique machine identification
  /// MachineID is preferred. This field is specific to Red Hat hosts
  /// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
  var systemUuid: String {
    get {return _systemUuid ?? String()}
    set {_systemUuid = newValue}
  }
  /// Returns true if `systemUuid` has been explicitly set.
  var hasSystemUuid: Bool {return self._systemUuid != nil}
  /// Clears the value of `systemUuid`. Subsequent reads from it will return its default value.
  mutating func clearSystemUuid() {self._systemUuid = nil}

  /// Boot ID reported by the node.
  var bootID: String {
    get {return _bootID ?? String()}
    set {_bootID = newValue}
  }
  /// Returns true if `bootID` has been explicitly set.
  var hasBootID: Bool {return self._bootID != nil}
  /// Clears the value of `bootID`. Subsequent reads from it will return its default value.
  mutating func clearBootID() {self._bootID = nil}

  /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
  var kernelVersion: String {
    get {return _kernelVersion ?? String()}
    set {_kernelVersion = newValue}
  }
  /// Returns true if `kernelVersion` has been explicitly set.
  var hasKernelVersion: Bool {return self._kernelVersion != nil}
  /// Clears the value of `kernelVersion`. Subsequent reads from it will return its default value.
  mutating func clearKernelVersion() {self._kernelVersion = nil}

  /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
  var osImage: String {
    get {return _osImage ?? String()}
    set {_osImage = newValue}
  }
  /// Returns true if `osImage` has been explicitly set.
  var hasOsImage: Bool {return self._osImage != nil}
  /// Clears the value of `osImage`. Subsequent reads from it will return its default value.
  mutating func clearOsImage() {self._osImage = nil}

  /// ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
  var containerRuntimeVersion: String {
    get {return _containerRuntimeVersion ?? String()}
    set {_containerRuntimeVersion = newValue}
  }
  /// Returns true if `containerRuntimeVersion` has been explicitly set.
  var hasContainerRuntimeVersion: Bool {return self._containerRuntimeVersion != nil}
  /// Clears the value of `containerRuntimeVersion`. Subsequent reads from it will return its default value.
  mutating func clearContainerRuntimeVersion() {self._containerRuntimeVersion = nil}

  /// Kubelet Version reported by the node.
  var kubeletVersion: String {
    get {return _kubeletVersion ?? String()}
    set {_kubeletVersion = newValue}
  }
  /// Returns true if `kubeletVersion` has been explicitly set.
  var hasKubeletVersion: Bool {return self._kubeletVersion != nil}
  /// Clears the value of `kubeletVersion`. Subsequent reads from it will return its default value.
  mutating func clearKubeletVersion() {self._kubeletVersion = nil}

  /// KubeProxy Version reported by the node.
  var kubeProxyVersion: String {
    get {return _kubeProxyVersion ?? String()}
    set {_kubeProxyVersion = newValue}
  }
  /// Returns true if `kubeProxyVersion` has been explicitly set.
  var hasKubeProxyVersion: Bool {return self._kubeProxyVersion != nil}
  /// Clears the value of `kubeProxyVersion`. Subsequent reads from it will return its default value.
  mutating func clearKubeProxyVersion() {self._kubeProxyVersion = nil}

  /// The Operating System reported by the node
  var operatingSystem: String {
    get {return _operatingSystem ?? String()}
    set {_operatingSystem = newValue}
  }
  /// Returns true if `operatingSystem` has been explicitly set.
  var hasOperatingSystem: Bool {return self._operatingSystem != nil}
  /// Clears the value of `operatingSystem`. Subsequent reads from it will return its default value.
  mutating func clearOperatingSystem() {self._operatingSystem = nil}

  /// The Architecture reported by the node
  var architecture: String {
    get {return _architecture ?? String()}
    set {_architecture = newValue}
  }
  /// Returns true if `architecture` has been explicitly set.
  var hasArchitecture: Bool {return self._architecture != nil}
  /// Clears the value of `architecture`. Subsequent reads from it will return its default value.
  mutating func clearArchitecture() {self._architecture = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _machineID: String? = nil
  fileprivate var _systemUuid: String? = nil
  fileprivate var _bootID: String? = nil
  fileprivate var _kernelVersion: String? = nil
  fileprivate var _osImage: String? = nil
  fileprivate var _containerRuntimeVersion: String? = nil
  fileprivate var _kubeletVersion: String? = nil
  fileprivate var _kubeProxyVersion: String? = nil
  fileprivate var _operatingSystem: String? = nil
  fileprivate var _architecture: String? = nil
}

/// ObjectFieldSelector selects an APIVersioned field of an object.
struct K8s_Io_Api_Core_V1_ObjectFieldSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
  /// +optional
  var apiVersion: String {
    get {return _apiVersion ?? String()}
    set {_apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return self._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {self._apiVersion = nil}

  /// Path of the field to select in the specified API version.
  var fieldPath: String {
    get {return _fieldPath ?? String()}
    set {_fieldPath = newValue}
  }
  /// Returns true if `fieldPath` has been explicitly set.
  var hasFieldPath: Bool {return self._fieldPath != nil}
  /// Clears the value of `fieldPath`. Subsequent reads from it will return its default value.
  mutating func clearFieldPath() {self._fieldPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _apiVersion: String? = nil
  fileprivate var _fieldPath: String? = nil
}

/// ObjectReference contains enough information to let you inspect or modify the referred object.
/// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct K8s_Io_Api_Core_V1_ObjectReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind of the referent.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// Namespace of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  /// +optional
  var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {self._namespace = nil}

  /// Name of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// UID of the referent.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// API version of the referent.
  /// +optional
  var apiVersion: String {
    get {return _apiVersion ?? String()}
    set {_apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return self._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {self._apiVersion = nil}

  /// Specific resourceVersion to which this reference is made, if any.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  /// +optional
  var resourceVersion: String {
    get {return _resourceVersion ?? String()}
    set {_resourceVersion = newValue}
  }
  /// Returns true if `resourceVersion` has been explicitly set.
  var hasResourceVersion: Bool {return self._resourceVersion != nil}
  /// Clears the value of `resourceVersion`. Subsequent reads from it will return its default value.
  mutating func clearResourceVersion() {self._resourceVersion = nil}

  /// If referring to a piece of an object instead of an entire object, this string
  /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
  /// For example, if the object reference is to a container within a pod, this would take on a value like:
  /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
  /// the event) or if no container name is specified "spec.containers[2]" (container with
  /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
  /// referencing a part of an object.
  /// TODO: this design is not final and this field is subject to change in the future.
  /// +optional
  var fieldPath: String {
    get {return _fieldPath ?? String()}
    set {_fieldPath = newValue}
  }
  /// Returns true if `fieldPath` has been explicitly set.
  var hasFieldPath: Bool {return self._fieldPath != nil}
  /// Clears the value of `fieldPath`. Subsequent reads from it will return its default value.
  mutating func clearFieldPath() {self._fieldPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _kind: String? = nil
  fileprivate var _namespace: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _uid: String? = nil
  fileprivate var _apiVersion: String? = nil
  fileprivate var _resourceVersion: String? = nil
  fileprivate var _fieldPath: String? = nil
}

/// PersistentVolume (PV) is a storage resource provisioned by an administrator.
/// It is analogous to a node.
/// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
struct K8s_Io_Api_Core_V1_PersistentVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines a specification of a persistent volume owned by the cluster.
  /// Provisioned by an administrator.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  /// +optional
  var spec: K8s_Io_Api_Core_V1_PersistentVolumeSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_PersistentVolumeSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status represents the current information/status for the persistent volume.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  /// +optional
  var status: K8s_Io_Api_Core_V1_PersistentVolumeStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_PersistentVolumeStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeClaim is a user's request for and claim to a persistent volume
struct K8s_Io_Api_Core_V1_PersistentVolumeClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the desired characteristics of a volume requested by a pod author.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  var spec: K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status represents the current information/status of a persistent volume claim.
  /// Read-only.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  var status: K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeClaimCondition contails details about state of pvc
struct K8s_Io_Api_Core_V1_PersistentVolumeClaimCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Last time we probed the condition.
  /// +optional
  var lastProbeTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastProbeTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastProbeTime = newValue}
  }
  /// Returns true if `lastProbeTime` has been explicitly set.
  var hasLastProbeTime: Bool {return _storage._lastProbeTime != nil}
  /// Clears the value of `lastProbeTime`. Subsequent reads from it will return its default value.
  mutating func clearLastProbeTime() {_uniqueStorage()._lastProbeTime = nil}

  /// Last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// Unique, this should be a short, machine understandable string that gives the reason
  /// for condition's last transition. If it reports "ResizeStarted" that means the underlying
  /// persistent volume is being resized.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Human-readable message indicating details about last transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
struct K8s_Io_Api_Core_V1_PersistentVolumeClaimList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// A list of persistent volume claims.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  var items: [K8s_Io_Api_Core_V1_PersistentVolumeClaim] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeClaimSpec describes the common attributes of storage devices
/// and allows a Source for provider-specific attributes
struct K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccessModes contains the desired access modes the volume should have.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  /// +optional
  var accessModes: [String] {
    get {return _storage._accessModes}
    set {_uniqueStorage()._accessModes = newValue}
  }

  /// A label query over volumes to consider for binding.
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// Resources represents the minimum resources the volume should have.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  /// +optional
  var resources: K8s_Io_Api_Core_V1_ResourceRequirements {
    get {return _storage._resources ?? K8s_Io_Api_Core_V1_ResourceRequirements()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// VolumeName is the binding reference to the PersistentVolume backing this claim.
  /// +optional
  var volumeName: String {
    get {return _storage._volumeName ?? String()}
    set {_uniqueStorage()._volumeName = newValue}
  }
  /// Returns true if `volumeName` has been explicitly set.
  var hasVolumeName: Bool {return _storage._volumeName != nil}
  /// Clears the value of `volumeName`. Subsequent reads from it will return its default value.
  mutating func clearVolumeName() {_uniqueStorage()._volumeName = nil}

  /// Name of the StorageClass required by the claim.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  /// +optional
  var storageClassName: String {
    get {return _storage._storageClassName ?? String()}
    set {_uniqueStorage()._storageClassName = newValue}
  }
  /// Returns true if `storageClassName` has been explicitly set.
  var hasStorageClassName: Bool {return _storage._storageClassName != nil}
  /// Clears the value of `storageClassName`. Subsequent reads from it will return its default value.
  mutating func clearStorageClassName() {_uniqueStorage()._storageClassName = nil}

  /// volumeMode defines what type of volume is required by the claim.
  /// Value of Filesystem is implied when not included in claim spec.
  /// This is a beta feature.
  /// +optional
  var volumeMode: String {
    get {return _storage._volumeMode ?? String()}
    set {_uniqueStorage()._volumeMode = newValue}
  }
  /// Returns true if `volumeMode` has been explicitly set.
  var hasVolumeMode: Bool {return _storage._volumeMode != nil}
  /// Clears the value of `volumeMode`. Subsequent reads from it will return its default value.
  mutating func clearVolumeMode() {_uniqueStorage()._volumeMode = nil}

  /// This field requires the VolumeSnapshotDataSource alpha feature gate to be
  /// enabled and currently VolumeSnapshot is the only supported data source.
  /// If the provisioner can support VolumeSnapshot data source, it will create
  /// a new volume and data will be restored to the volume at the same time.
  /// If the provisioner does not support VolumeSnapshot data source, volume will
  /// not be created and the failure will be reported as an event.
  /// In the future, we plan to support more data source types and the behavior
  /// of the provisioner may change.
  /// +optional
  var dataSource: K8s_Io_Api_Core_V1_TypedLocalObjectReference {
    get {return _storage._dataSource ?? K8s_Io_Api_Core_V1_TypedLocalObjectReference()}
    set {_uniqueStorage()._dataSource = newValue}
  }
  /// Returns true if `dataSource` has been explicitly set.
  var hasDataSource: Bool {return _storage._dataSource != nil}
  /// Clears the value of `dataSource`. Subsequent reads from it will return its default value.
  mutating func clearDataSource() {_uniqueStorage()._dataSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
struct K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Phase represents the current phase of PersistentVolumeClaim.
  /// +optional
  var phase: String {
    get {return _phase ?? String()}
    set {_phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return self._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {self._phase = nil}

  /// AccessModes contains the actual access modes the volume backing the PVC has.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  /// +optional
  var accessModes: [String] = []

  /// Represents the actual resources of the underlying volume.
  /// +optional
  var capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// Current Condition of persistent volume claim. If underlying persistent volume is being
  /// resized then the Condition will be set to 'ResizeStarted'.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_PersistentVolumeClaimCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _phase: String? = nil
}

/// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
/// This volume finds the bound PV and mounts that volume for the pod. A
/// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
/// type of volume that is owned by someone else (the system).
struct K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  var claimName: String {
    get {return _claimName ?? String()}
    set {_claimName = newValue}
  }
  /// Returns true if `claimName` has been explicitly set.
  var hasClaimName: Bool {return self._claimName != nil}
  /// Clears the value of `claimName`. Subsequent reads from it will return its default value.
  mutating func clearClaimName() {self._claimName = nil}

  /// Will force the ReadOnly setting in VolumeMounts.
  /// Default false.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _claimName: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// PersistentVolumeList is a list of PersistentVolume items.
struct K8s_Io_Api_Core_V1_PersistentVolumeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of persistent volumes.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
  var items: [K8s_Io_Api_Core_V1_PersistentVolume] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeSource is similar to VolumeSource but meant for the
/// administrator who creates PVs. Exactly one of its members must be set.
struct K8s_Io_Api_Core_V1_PersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GCEPersistentDisk represents a GCE Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  var gcePersistentDisk: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource {
    get {return _storage._gcePersistentDisk ?? K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource()}
    set {_uniqueStorage()._gcePersistentDisk = newValue}
  }
  /// Returns true if `gcePersistentDisk` has been explicitly set.
  var hasGcePersistentDisk: Bool {return _storage._gcePersistentDisk != nil}
  /// Clears the value of `gcePersistentDisk`. Subsequent reads from it will return its default value.
  mutating func clearGcePersistentDisk() {_uniqueStorage()._gcePersistentDisk = nil}

  /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  var awsElasticBlockStore: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource {
    get {return _storage._awsElasticBlockStore ?? K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource()}
    set {_uniqueStorage()._awsElasticBlockStore = newValue}
  }
  /// Returns true if `awsElasticBlockStore` has been explicitly set.
  var hasAwsElasticBlockStore: Bool {return _storage._awsElasticBlockStore != nil}
  /// Clears the value of `awsElasticBlockStore`. Subsequent reads from it will return its default value.
  mutating func clearAwsElasticBlockStore() {_uniqueStorage()._awsElasticBlockStore = nil}

  /// HostPath represents a directory on the host.
  /// Provisioned by a developer or tester.
  /// This is useful for single-node development and testing only!
  /// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// +optional
  var hostPath: K8s_Io_Api_Core_V1_HostPathVolumeSource {
    get {return _storage._hostPath ?? K8s_Io_Api_Core_V1_HostPathVolumeSource()}
    set {_uniqueStorage()._hostPath = newValue}
  }
  /// Returns true if `hostPath` has been explicitly set.
  var hasHostPath: Bool {return _storage._hostPath != nil}
  /// Clears the value of `hostPath`. Subsequent reads from it will return its default value.
  mutating func clearHostPath() {_uniqueStorage()._hostPath = nil}

  /// Glusterfs represents a Glusterfs volume that is attached to a host and
  /// exposed to the pod. Provisioned by an admin.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
  /// +optional
  var glusterfs: K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource {
    get {return _storage._glusterfs ?? K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource()}
    set {_uniqueStorage()._glusterfs = newValue}
  }
  /// Returns true if `glusterfs` has been explicitly set.
  var hasGlusterfs: Bool {return _storage._glusterfs != nil}
  /// Clears the value of `glusterfs`. Subsequent reads from it will return its default value.
  mutating func clearGlusterfs() {_uniqueStorage()._glusterfs = nil}

  /// NFS represents an NFS mount on the host. Provisioned by an admin.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  var nfs: K8s_Io_Api_Core_V1_NFSVolumeSource {
    get {return _storage._nfs ?? K8s_Io_Api_Core_V1_NFSVolumeSource()}
    set {_uniqueStorage()._nfs = newValue}
  }
  /// Returns true if `nfs` has been explicitly set.
  var hasNfs: Bool {return _storage._nfs != nil}
  /// Clears the value of `nfs`. Subsequent reads from it will return its default value.
  mutating func clearNfs() {_uniqueStorage()._nfs = nil}

  /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md
  /// +optional
  var rbd: K8s_Io_Api_Core_V1_RBDPersistentVolumeSource {
    get {return _storage._rbd ?? K8s_Io_Api_Core_V1_RBDPersistentVolumeSource()}
    set {_uniqueStorage()._rbd = newValue}
  }
  /// Returns true if `rbd` has been explicitly set.
  var hasRbd: Bool {return _storage._rbd != nil}
  /// Clears the value of `rbd`. Subsequent reads from it will return its default value.
  mutating func clearRbd() {_uniqueStorage()._rbd = nil}

  /// ISCSI represents an ISCSI Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  /// +optional
  var iscsi: K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource {
    get {return _storage._iscsi ?? K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource()}
    set {_uniqueStorage()._iscsi = newValue}
  }
  /// Returns true if `iscsi` has been explicitly set.
  var hasIscsi: Bool {return _storage._iscsi != nil}
  /// Clears the value of `iscsi`. Subsequent reads from it will return its default value.
  mutating func clearIscsi() {_uniqueStorage()._iscsi = nil}

  /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var cinder: K8s_Io_Api_Core_V1_CinderPersistentVolumeSource {
    get {return _storage._cinder ?? K8s_Io_Api_Core_V1_CinderPersistentVolumeSource()}
    set {_uniqueStorage()._cinder = newValue}
  }
  /// Returns true if `cinder` has been explicitly set.
  var hasCinder: Bool {return _storage._cinder != nil}
  /// Clears the value of `cinder`. Subsequent reads from it will return its default value.
  mutating func clearCinder() {_uniqueStorage()._cinder = nil}

  /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  /// +optional
  var cephfs: K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource {
    get {return _storage._cephfs ?? K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource()}
    set {_uniqueStorage()._cephfs = newValue}
  }
  /// Returns true if `cephfs` has been explicitly set.
  var hasCephfs: Bool {return _storage._cephfs != nil}
  /// Clears the value of `cephfs`. Subsequent reads from it will return its default value.
  mutating func clearCephfs() {_uniqueStorage()._cephfs = nil}

  /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  /// +optional
  var fc: K8s_Io_Api_Core_V1_FCVolumeSource {
    get {return _storage._fc ?? K8s_Io_Api_Core_V1_FCVolumeSource()}
    set {_uniqueStorage()._fc = newValue}
  }
  /// Returns true if `fc` has been explicitly set.
  var hasFc: Bool {return _storage._fc != nil}
  /// Clears the value of `fc`. Subsequent reads from it will return its default value.
  mutating func clearFc() {_uniqueStorage()._fc = nil}

  /// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  /// +optional
  var flocker: K8s_Io_Api_Core_V1_FlockerVolumeSource {
    get {return _storage._flocker ?? K8s_Io_Api_Core_V1_FlockerVolumeSource()}
    set {_uniqueStorage()._flocker = newValue}
  }
  /// Returns true if `flocker` has been explicitly set.
  var hasFlocker: Bool {return _storage._flocker != nil}
  /// Clears the value of `flocker`. Subsequent reads from it will return its default value.
  mutating func clearFlocker() {_uniqueStorage()._flocker = nil}

  /// FlexVolume represents a generic volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// +optional
  var flexVolume: K8s_Io_Api_Core_V1_FlexPersistentVolumeSource {
    get {return _storage._flexVolume ?? K8s_Io_Api_Core_V1_FlexPersistentVolumeSource()}
    set {_uniqueStorage()._flexVolume = newValue}
  }
  /// Returns true if `flexVolume` has been explicitly set.
  var hasFlexVolume: Bool {return _storage._flexVolume != nil}
  /// Clears the value of `flexVolume`. Subsequent reads from it will return its default value.
  mutating func clearFlexVolume() {_uniqueStorage()._flexVolume = nil}

  /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// +optional
  var azureFile: K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource {
    get {return _storage._azureFile ?? K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource()}
    set {_uniqueStorage()._azureFile = newValue}
  }
  /// Returns true if `azureFile` has been explicitly set.
  var hasAzureFile: Bool {return _storage._azureFile != nil}
  /// Clears the value of `azureFile`. Subsequent reads from it will return its default value.
  mutating func clearAzureFile() {_uniqueStorage()._azureFile = nil}

  /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  /// +optional
  var vsphereVolume: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource {
    get {return _storage._vsphereVolume ?? K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource()}
    set {_uniqueStorage()._vsphereVolume = newValue}
  }
  /// Returns true if `vsphereVolume` has been explicitly set.
  var hasVsphereVolume: Bool {return _storage._vsphereVolume != nil}
  /// Clears the value of `vsphereVolume`. Subsequent reads from it will return its default value.
  mutating func clearVsphereVolume() {_uniqueStorage()._vsphereVolume = nil}

  /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  /// +optional
  var quobyte: K8s_Io_Api_Core_V1_QuobyteVolumeSource {
    get {return _storage._quobyte ?? K8s_Io_Api_Core_V1_QuobyteVolumeSource()}
    set {_uniqueStorage()._quobyte = newValue}
  }
  /// Returns true if `quobyte` has been explicitly set.
  var hasQuobyte: Bool {return _storage._quobyte != nil}
  /// Clears the value of `quobyte`. Subsequent reads from it will return its default value.
  mutating func clearQuobyte() {_uniqueStorage()._quobyte = nil}

  /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  /// +optional
  var azureDisk: K8s_Io_Api_Core_V1_AzureDiskVolumeSource {
    get {return _storage._azureDisk ?? K8s_Io_Api_Core_V1_AzureDiskVolumeSource()}
    set {_uniqueStorage()._azureDisk = newValue}
  }
  /// Returns true if `azureDisk` has been explicitly set.
  var hasAzureDisk: Bool {return _storage._azureDisk != nil}
  /// Clears the value of `azureDisk`. Subsequent reads from it will return its default value.
  mutating func clearAzureDisk() {_uniqueStorage()._azureDisk = nil}

  /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  var photonPersistentDisk: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource {
    get {return _storage._photonPersistentDisk ?? K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource()}
    set {_uniqueStorage()._photonPersistentDisk = newValue}
  }
  /// Returns true if `photonPersistentDisk` has been explicitly set.
  var hasPhotonPersistentDisk: Bool {return _storage._photonPersistentDisk != nil}
  /// Clears the value of `photonPersistentDisk`. Subsequent reads from it will return its default value.
  mutating func clearPhotonPersistentDisk() {_uniqueStorage()._photonPersistentDisk = nil}

  /// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
  /// +optional
  var portworxVolume: K8s_Io_Api_Core_V1_PortworxVolumeSource {
    get {return _storage._portworxVolume ?? K8s_Io_Api_Core_V1_PortworxVolumeSource()}
    set {_uniqueStorage()._portworxVolume = newValue}
  }
  /// Returns true if `portworxVolume` has been explicitly set.
  var hasPortworxVolume: Bool {return _storage._portworxVolume != nil}
  /// Clears the value of `portworxVolume`. Subsequent reads from it will return its default value.
  mutating func clearPortworxVolume() {_uniqueStorage()._portworxVolume = nil}

  /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  /// +optional
  var scaleIo: K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource {
    get {return _storage._scaleIo ?? K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource()}
    set {_uniqueStorage()._scaleIo = newValue}
  }
  /// Returns true if `scaleIo` has been explicitly set.
  var hasScaleIo: Bool {return _storage._scaleIo != nil}
  /// Clears the value of `scaleIo`. Subsequent reads from it will return its default value.
  mutating func clearScaleIo() {_uniqueStorage()._scaleIo = nil}

  /// Local represents directly-attached storage with node affinity
  /// +optional
  var local: K8s_Io_Api_Core_V1_LocalVolumeSource {
    get {return _storage._local ?? K8s_Io_Api_Core_V1_LocalVolumeSource()}
    set {_uniqueStorage()._local = newValue}
  }
  /// Returns true if `local` has been explicitly set.
  var hasLocal: Bool {return _storage._local != nil}
  /// Clears the value of `local`. Subsequent reads from it will return its default value.
  mutating func clearLocal() {_uniqueStorage()._local = nil}

  /// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
  /// More info: https://examples.k8s.io/volumes/storageos/README.md
  /// +optional
  var storageos: K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource {
    get {return _storage._storageos ?? K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource()}
    set {_uniqueStorage()._storageos = newValue}
  }
  /// Returns true if `storageos` has been explicitly set.
  var hasStorageos: Bool {return _storage._storageos != nil}
  /// Clears the value of `storageos`. Subsequent reads from it will return its default value.
  mutating func clearStorageos() {_uniqueStorage()._storageos = nil}

  /// CSI represents storage that is handled by an external CSI driver (Beta feature).
  /// +optional
  var csi: K8s_Io_Api_Core_V1_CSIPersistentVolumeSource {
    get {return _storage._csi ?? K8s_Io_Api_Core_V1_CSIPersistentVolumeSource()}
    set {_uniqueStorage()._csi = newValue}
  }
  /// Returns true if `csi` has been explicitly set.
  var hasCsi: Bool {return _storage._csi != nil}
  /// Clears the value of `csi`. Subsequent reads from it will return its default value.
  mutating func clearCsi() {_uniqueStorage()._csi = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeSpec is the specification of a persistent volume.
struct K8s_Io_Api_Core_V1_PersistentVolumeSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A description of the persistent volume's resources and capacity.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  /// +optional
  var capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> {
    get {return _storage._capacity}
    set {_uniqueStorage()._capacity = newValue}
  }

  /// The actual volume backing the persistent volume.
  var persistentVolumeSource: K8s_Io_Api_Core_V1_PersistentVolumeSource {
    get {return _storage._persistentVolumeSource ?? K8s_Io_Api_Core_V1_PersistentVolumeSource()}
    set {_uniqueStorage()._persistentVolumeSource = newValue}
  }
  /// Returns true if `persistentVolumeSource` has been explicitly set.
  var hasPersistentVolumeSource: Bool {return _storage._persistentVolumeSource != nil}
  /// Clears the value of `persistentVolumeSource`. Subsequent reads from it will return its default value.
  mutating func clearPersistentVolumeSource() {_uniqueStorage()._persistentVolumeSource = nil}

  /// AccessModes contains all ways the volume can be mounted.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
  /// +optional
  var accessModes: [String] {
    get {return _storage._accessModes}
    set {_uniqueStorage()._accessModes = newValue}
  }

  /// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
  /// Expected to be non-nil when bound.
  /// claim.VolumeName is the authoritative bind between PV and PVC.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
  /// +optional
  var claimRef: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._claimRef ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._claimRef = newValue}
  }
  /// Returns true if `claimRef` has been explicitly set.
  var hasClaimRef: Bool {return _storage._claimRef != nil}
  /// Clears the value of `claimRef`. Subsequent reads from it will return its default value.
  mutating func clearClaimRef() {_uniqueStorage()._claimRef = nil}

  /// What happens to a persistent volume when released from its claim.
  /// Valid options are Retain (default for manually created PersistentVolumes), Delete (default
  /// for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
  /// Recycle must be supported by the volume plugin underlying this PersistentVolume.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
  /// +optional
  var persistentVolumeReclaimPolicy: String {
    get {return _storage._persistentVolumeReclaimPolicy ?? String()}
    set {_uniqueStorage()._persistentVolumeReclaimPolicy = newValue}
  }
  /// Returns true if `persistentVolumeReclaimPolicy` has been explicitly set.
  var hasPersistentVolumeReclaimPolicy: Bool {return _storage._persistentVolumeReclaimPolicy != nil}
  /// Clears the value of `persistentVolumeReclaimPolicy`. Subsequent reads from it will return its default value.
  mutating func clearPersistentVolumeReclaimPolicy() {_uniqueStorage()._persistentVolumeReclaimPolicy = nil}

  /// Name of StorageClass to which this persistent volume belongs. Empty value
  /// means that this volume does not belong to any StorageClass.
  /// +optional
  var storageClassName: String {
    get {return _storage._storageClassName ?? String()}
    set {_uniqueStorage()._storageClassName = newValue}
  }
  /// Returns true if `storageClassName` has been explicitly set.
  var hasStorageClassName: Bool {return _storage._storageClassName != nil}
  /// Clears the value of `storageClassName`. Subsequent reads from it will return its default value.
  mutating func clearStorageClassName() {_uniqueStorage()._storageClassName = nil}

  /// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
  /// simply fail if one is invalid.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
  /// +optional
  var mountOptions: [String] {
    get {return _storage._mountOptions}
    set {_uniqueStorage()._mountOptions = newValue}
  }

  /// volumeMode defines if a volume is intended to be used with a formatted filesystem
  /// or to remain in raw block state. Value of Filesystem is implied when not included in spec.
  /// This is a beta feature.
  /// +optional
  var volumeMode: String {
    get {return _storage._volumeMode ?? String()}
    set {_uniqueStorage()._volumeMode = newValue}
  }
  /// Returns true if `volumeMode` has been explicitly set.
  var hasVolumeMode: Bool {return _storage._volumeMode != nil}
  /// Clears the value of `volumeMode`. Subsequent reads from it will return its default value.
  mutating func clearVolumeMode() {_uniqueStorage()._volumeMode = nil}

  /// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
  /// This field influences the scheduling of pods that use this volume.
  /// +optional
  var nodeAffinity: K8s_Io_Api_Core_V1_VolumeNodeAffinity {
    get {return _storage._nodeAffinity ?? K8s_Io_Api_Core_V1_VolumeNodeAffinity()}
    set {_uniqueStorage()._nodeAffinity = newValue}
  }
  /// Returns true if `nodeAffinity` has been explicitly set.
  var hasNodeAffinity: Bool {return _storage._nodeAffinity != nil}
  /// Clears the value of `nodeAffinity`. Subsequent reads from it will return its default value.
  mutating func clearNodeAffinity() {_uniqueStorage()._nodeAffinity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PersistentVolumeStatus is the current status of a persistent volume.
struct K8s_Io_Api_Core_V1_PersistentVolumeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Phase indicates if a volume is available, bound to a claim, or released by a claim.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
  /// +optional
  var phase: String {
    get {return _phase ?? String()}
    set {_phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return self._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {self._phase = nil}

  /// A human-readable message indicating details about why the volume is in this state.
  /// +optional
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Reason is a brief CamelCase string that describes any failure and is meant
  /// for machine parsing and tidy display in the CLI.
  /// +optional
  var reason: String {
    get {return _reason ?? String()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _phase: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _reason: String? = nil
}

/// Represents a Photon Controller persistent disk resource.
struct K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID that identifies Photon Controller persistent disk
  var pdID: String {
    get {return _pdID ?? String()}
    set {_pdID = newValue}
  }
  /// Returns true if `pdID` has been explicitly set.
  var hasPdID: Bool {return self._pdID != nil}
  /// Clears the value of `pdID`. Subsequent reads from it will return its default value.
  mutating func clearPdID() {self._pdID = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pdID: String? = nil
  fileprivate var _fsType: String? = nil
}

/// Pod is a collection of containers that can run on a host. This resource is created
/// by clients and scheduled onto hosts.
struct K8s_Io_Api_Core_V1_Pod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior of the pod.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_PodSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_PodSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the pod.
  /// This data may not be up to date.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_PodStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_PodStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Pod affinity is a group of inter pod affinity scheduling rules.
struct K8s_Io_Api_Core_V1_PodAffinity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to a pod label update), the
  /// system may or may not try to eventually evict the pod from its node.
  /// When there are multiple elements, the lists of nodes corresponding to each
  /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
  /// +optional
  var requiredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_PodAffinityTerm] = []

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  var preferredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_WeightedPodAffinityTerm] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines a set of pods (namely those matching the labelSelector
/// relative to the given namespace(s)) that this pod should be
/// co-located (affinity) or not co-located (anti-affinity) with,
/// where co-located is defined as running on a node whose value of
/// the label with key <topologyKey> matches that of any node on which
/// a pod of the set of pods is running
struct K8s_Io_Api_Core_V1_PodAffinityTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A label query over a set of resources, in this case pods.
  /// +optional
  var labelSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._labelSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._labelSelector = newValue}
  }
  /// Returns true if `labelSelector` has been explicitly set.
  var hasLabelSelector: Bool {return _storage._labelSelector != nil}
  /// Clears the value of `labelSelector`. Subsequent reads from it will return its default value.
  mutating func clearLabelSelector() {_uniqueStorage()._labelSelector = nil}

  /// namespaces specifies which namespaces the labelSelector applies to (matches against);
  /// null or empty list means "this pod's namespace"
  /// +optional
  var namespaces: [String] {
    get {return _storage._namespaces}
    set {_uniqueStorage()._namespaces = newValue}
  }

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the
  /// selected pods is running.
  /// Empty topologyKey is not allowed.
  var topologyKey: String {
    get {return _storage._topologyKey ?? String()}
    set {_uniqueStorage()._topologyKey = newValue}
  }
  /// Returns true if `topologyKey` has been explicitly set.
  var hasTopologyKey: Bool {return _storage._topologyKey != nil}
  /// Clears the value of `topologyKey`. Subsequent reads from it will return its default value.
  mutating func clearTopologyKey() {_uniqueStorage()._topologyKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
struct K8s_Io_Api_Core_V1_PodAntiAffinity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the anti-affinity requirements specified by this field are not met at
  /// scheduling time, the pod will not be scheduled onto the node.
  /// If the anti-affinity requirements specified by this field cease to be met
  /// at some point during pod execution (e.g. due to a pod label update), the
  /// system may or may not try to eventually evict the pod from its node.
  /// When there are multiple elements, the lists of nodes corresponding to each
  /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
  /// +optional
  var requiredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_PodAffinityTerm] = []

  /// The scheduler will prefer to schedule pods to nodes that satisfy
  /// the anti-affinity expressions specified by this field, but it may choose
  /// a node that violates one or more of the expressions. The node that is
  /// most preferred is the one with the greatest sum of weights, i.e.
  /// for each node that meets all of the scheduling requirements (resource
  /// request, requiredDuringScheduling anti-affinity expressions, etc.),
  /// compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  /// +optional
  var preferredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_WeightedPodAffinityTerm] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodAttachOptions is the query options to a Pod's remote attach call.
/// ---
/// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
/// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
struct K8s_Io_Api_Core_V1_PodAttachOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stdin if true, redirects the standard input stream of the pod for this call.
  /// Defaults to false.
  /// +optional
  var stdin: Bool {
    get {return _stdin ?? false}
    set {_stdin = newValue}
  }
  /// Returns true if `stdin` has been explicitly set.
  var hasStdin: Bool {return self._stdin != nil}
  /// Clears the value of `stdin`. Subsequent reads from it will return its default value.
  mutating func clearStdin() {self._stdin = nil}

  /// Stdout if true indicates that stdout is to be redirected for the attach call.
  /// Defaults to true.
  /// +optional
  var stdout: Bool {
    get {return _stdout ?? false}
    set {_stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  var hasStdout: Bool {return self._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  mutating func clearStdout() {self._stdout = nil}

  /// Stderr if true indicates that stderr is to be redirected for the attach call.
  /// Defaults to true.
  /// +optional
  var stderr: Bool {
    get {return _stderr ?? false}
    set {_stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  var hasStderr: Bool {return self._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  mutating func clearStderr() {self._stderr = nil}

  /// TTY if true indicates that a tty will be allocated for the attach call.
  /// This is passed through the container runtime so the tty
  /// is allocated on the worker node by the container runtime.
  /// Defaults to false.
  /// +optional
  var tty: Bool {
    get {return _tty ?? false}
    set {_tty = newValue}
  }
  /// Returns true if `tty` has been explicitly set.
  var hasTty: Bool {return self._tty != nil}
  /// Clears the value of `tty`. Subsequent reads from it will return its default value.
  mutating func clearTty() {self._tty = nil}

  /// The container in which to execute the command.
  /// Defaults to only container if there is only one container in the pod.
  /// +optional
  var container: String {
    get {return _container ?? String()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stdin: Bool? = nil
  fileprivate var _stdout: Bool? = nil
  fileprivate var _stderr: Bool? = nil
  fileprivate var _tty: Bool? = nil
  fileprivate var _container: String? = nil
}

/// PodCondition contains details for the current condition of this pod.
struct K8s_Io_Api_Core_V1_PodCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is the type of the condition.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status is the status of the condition.
  /// Can be True, False, Unknown.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Last time we probed the condition.
  /// +optional
  var lastProbeTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastProbeTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastProbeTime = newValue}
  }
  /// Returns true if `lastProbeTime` has been explicitly set.
  var hasLastProbeTime: Bool {return _storage._lastProbeTime != nil}
  /// Clears the value of `lastProbeTime`. Subsequent reads from it will return its default value.
  mutating func clearLastProbeTime() {_uniqueStorage()._lastProbeTime = nil}

  /// Last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// Unique, one-word, CamelCase reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Human-readable message indicating details about last transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodDNSConfig defines the DNS parameters of a pod in addition to
/// those generated from DNSPolicy.
struct K8s_Io_Api_Core_V1_PodDNSConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of DNS name server IP addresses.
  /// This will be appended to the base nameservers generated from DNSPolicy.
  /// Duplicated nameservers will be removed.
  /// +optional
  var nameservers: [String] = []

  /// A list of DNS search domains for host-name lookup.
  /// This will be appended to the base search paths generated from DNSPolicy.
  /// Duplicated search paths will be removed.
  /// +optional
  var searches: [String] = []

  /// A list of DNS resolver options.
  /// This will be merged with the base options generated from DNSPolicy.
  /// Duplicated entries will be removed. Resolution options given in Options
  /// will override those that appear in the base DNSPolicy.
  /// +optional
  var options: [K8s_Io_Api_Core_V1_PodDNSConfigOption] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
struct K8s_Io_Api_Core_V1_PodDNSConfigOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// +optional
  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: String? = nil
}

/// PodExecOptions is the query options to a Pod's remote exec call.
/// ---
/// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
/// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
struct K8s_Io_Api_Core_V1_PodExecOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Redirect the standard input stream of the pod for this call.
  /// Defaults to false.
  /// +optional
  var stdin: Bool {
    get {return _stdin ?? false}
    set {_stdin = newValue}
  }
  /// Returns true if `stdin` has been explicitly set.
  var hasStdin: Bool {return self._stdin != nil}
  /// Clears the value of `stdin`. Subsequent reads from it will return its default value.
  mutating func clearStdin() {self._stdin = nil}

  /// Redirect the standard output stream of the pod for this call.
  /// Defaults to true.
  /// +optional
  var stdout: Bool {
    get {return _stdout ?? false}
    set {_stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  var hasStdout: Bool {return self._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  mutating func clearStdout() {self._stdout = nil}

  /// Redirect the standard error stream of the pod for this call.
  /// Defaults to true.
  /// +optional
  var stderr: Bool {
    get {return _stderr ?? false}
    set {_stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  var hasStderr: Bool {return self._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  mutating func clearStderr() {self._stderr = nil}

  /// TTY if true indicates that a tty will be allocated for the exec call.
  /// Defaults to false.
  /// +optional
  var tty: Bool {
    get {return _tty ?? false}
    set {_tty = newValue}
  }
  /// Returns true if `tty` has been explicitly set.
  var hasTty: Bool {return self._tty != nil}
  /// Clears the value of `tty`. Subsequent reads from it will return its default value.
  mutating func clearTty() {self._tty = nil}

  /// Container in which to execute the command.
  /// Defaults to only container if there is only one container in the pod.
  /// +optional
  var container: String {
    get {return _container ?? String()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  /// Command is the remote command to execute. argv array. Not executed within a shell.
  var command: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stdin: Bool? = nil
  fileprivate var _stdout: Bool? = nil
  fileprivate var _stderr: Bool? = nil
  fileprivate var _tty: Bool? = nil
  fileprivate var _container: String? = nil
}

/// IP address information for entries in the (plural) PodIPs field.
/// Each entry includes:
///    IP: An IP address allocated to the pod. Routable at least within the cluster.
struct K8s_Io_Api_Core_V1_PodIP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ip is an IP address (IPv4 or IPv6) assigned to the pod
  var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ip: String? = nil
}

/// PodList is a list of Pods.
struct K8s_Io_Api_Core_V1_PodList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of pods.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
  var items: [K8s_Io_Api_Core_V1_Pod] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodLogOptions is the query options for a Pod's logs REST call.
struct K8s_Io_Api_Core_V1_PodLogOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The container for which to stream logs. Defaults to only container if there is one container in the pod.
  /// +optional
  var container: String {
    get {return _storage._container ?? String()}
    set {_uniqueStorage()._container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return _storage._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {_uniqueStorage()._container = nil}

  /// Follow the log stream of the pod. Defaults to false.
  /// +optional
  var follow: Bool {
    get {return _storage._follow ?? false}
    set {_uniqueStorage()._follow = newValue}
  }
  /// Returns true if `follow` has been explicitly set.
  var hasFollow: Bool {return _storage._follow != nil}
  /// Clears the value of `follow`. Subsequent reads from it will return its default value.
  mutating func clearFollow() {_uniqueStorage()._follow = nil}

  /// Return previous terminated container logs. Defaults to false.
  /// +optional
  var previous: Bool {
    get {return _storage._previous ?? false}
    set {_uniqueStorage()._previous = newValue}
  }
  /// Returns true if `previous` has been explicitly set.
  var hasPrevious: Bool {return _storage._previous != nil}
  /// Clears the value of `previous`. Subsequent reads from it will return its default value.
  mutating func clearPrevious() {_uniqueStorage()._previous = nil}

  /// A relative time in seconds before the current time from which to show logs. If this value
  /// precedes the time a pod was started, only logs since the pod start will be returned.
  /// If this value is in the future, no logs will be returned.
  /// Only one of sinceSeconds or sinceTime may be specified.
  /// +optional
  var sinceSeconds: Int64 {
    get {return _storage._sinceSeconds ?? 0}
    set {_uniqueStorage()._sinceSeconds = newValue}
  }
  /// Returns true if `sinceSeconds` has been explicitly set.
  var hasSinceSeconds: Bool {return _storage._sinceSeconds != nil}
  /// Clears the value of `sinceSeconds`. Subsequent reads from it will return its default value.
  mutating func clearSinceSeconds() {_uniqueStorage()._sinceSeconds = nil}

  /// An RFC3339 timestamp from which to show logs. If this value
  /// precedes the time a pod was started, only logs since the pod start will be returned.
  /// If this value is in the future, no logs will be returned.
  /// Only one of sinceSeconds or sinceTime may be specified.
  /// +optional
  var sinceTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._sinceTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._sinceTime = newValue}
  }
  /// Returns true if `sinceTime` has been explicitly set.
  var hasSinceTime: Bool {return _storage._sinceTime != nil}
  /// Clears the value of `sinceTime`. Subsequent reads from it will return its default value.
  mutating func clearSinceTime() {_uniqueStorage()._sinceTime = nil}

  /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
  /// of log output. Defaults to false.
  /// +optional
  var timestamps: Bool {
    get {return _storage._timestamps ?? false}
    set {_uniqueStorage()._timestamps = newValue}
  }
  /// Returns true if `timestamps` has been explicitly set.
  var hasTimestamps: Bool {return _storage._timestamps != nil}
  /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
  mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

  /// If set, the number of lines from the end of the logs to show. If not specified,
  /// logs are shown from the creation of the container or sinceSeconds or sinceTime
  /// +optional
  var tailLines: Int64 {
    get {return _storage._tailLines ?? 0}
    set {_uniqueStorage()._tailLines = newValue}
  }
  /// Returns true if `tailLines` has been explicitly set.
  var hasTailLines: Bool {return _storage._tailLines != nil}
  /// Clears the value of `tailLines`. Subsequent reads from it will return its default value.
  mutating func clearTailLines() {_uniqueStorage()._tailLines = nil}

  /// If set, the number of bytes to read from the server before terminating the
  /// log output. This may not display a complete final line of logging, and may return
  /// slightly more or slightly less than the specified limit.
  /// +optional
  var limitBytes: Int64 {
    get {return _storage._limitBytes ?? 0}
    set {_uniqueStorage()._limitBytes = newValue}
  }
  /// Returns true if `limitBytes` has been explicitly set.
  var hasLimitBytes: Bool {return _storage._limitBytes != nil}
  /// Clears the value of `limitBytes`. Subsequent reads from it will return its default value.
  mutating func clearLimitBytes() {_uniqueStorage()._limitBytes = nil}

  /// insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
  /// serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
  /// and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
  /// kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
  /// connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
  /// the actual log data coming from the real kubelet).
  /// +optional
  var insecureSkipTlsverifyBackend: Bool {
    get {return _storage._insecureSkipTlsverifyBackend ?? false}
    set {_uniqueStorage()._insecureSkipTlsverifyBackend = newValue}
  }
  /// Returns true if `insecureSkipTlsverifyBackend` has been explicitly set.
  var hasInsecureSkipTlsverifyBackend: Bool {return _storage._insecureSkipTlsverifyBackend != nil}
  /// Clears the value of `insecureSkipTlsverifyBackend`. Subsequent reads from it will return its default value.
  mutating func clearInsecureSkipTlsverifyBackend() {_uniqueStorage()._insecureSkipTlsverifyBackend = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodPortForwardOptions is the query options to a Pod's port forward call
/// when using WebSockets.
/// The `port` query parameter must specify the port or
/// ports (comma separated) to forward over.
/// Port forwarding over SPDY does not use these options. It requires the port
/// to be passed in the `port` header as part of request.
struct K8s_Io_Api_Core_V1_PodPortForwardOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of ports to forward
  /// Required when using WebSockets
  /// +optional
  var ports: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PodProxyOptions is the query options to a Pod's proxy call.
struct K8s_Io_Api_Core_V1_PodProxyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path is the URL path to use for the current proxy request to pod.
  /// +optional
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
}

/// PodReadinessGate contains the reference to a pod condition
struct K8s_Io_Api_Core_V1_PodReadinessGate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConditionType refers to a condition in the pod's condition list with matching type.
  var conditionType: String {
    get {return _conditionType ?? String()}
    set {_conditionType = newValue}
  }
  /// Returns true if `conditionType` has been explicitly set.
  var hasConditionType: Bool {return self._conditionType != nil}
  /// Clears the value of `conditionType`. Subsequent reads from it will return its default value.
  mutating func clearConditionType() {self._conditionType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conditionType: String? = nil
}

/// PodSecurityContext holds pod-level security attributes and common container settings.
/// Some fields are also present in container.securityContext.  Field values of
/// container.securityContext take precedence over field values of PodSecurityContext.
struct K8s_Io_Api_Core_V1_PodSecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The SELinux context to be applied to all containers.
  /// If unspecified, the container runtime will allocate a random SELinux context for each
  /// container.  May also be set in SecurityContext.  If set in
  /// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  /// takes precedence for that container.
  /// +optional
  var seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions {
    get {return _storage._seLinuxOptions ?? K8s_Io_Api_Core_V1_SELinuxOptions()}
    set {_uniqueStorage()._seLinuxOptions = newValue}
  }
  /// Returns true if `seLinuxOptions` has been explicitly set.
  var hasSeLinuxOptions: Bool {return _storage._seLinuxOptions != nil}
  /// Clears the value of `seLinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSeLinuxOptions() {_uniqueStorage()._seLinuxOptions = nil}

  /// The Windows specific settings applied to all containers.
  /// If unspecified, the options within a container's SecurityContext will be used.
  /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var windowsOptions: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions {
    get {return _storage._windowsOptions ?? K8s_Io_Api_Core_V1_WindowsSecurityContextOptions()}
    set {_uniqueStorage()._windowsOptions = newValue}
  }
  /// Returns true if `windowsOptions` has been explicitly set.
  var hasWindowsOptions: Bool {return _storage._windowsOptions != nil}
  /// Clears the value of `windowsOptions`. Subsequent reads from it will return its default value.
  mutating func clearWindowsOptions() {_uniqueStorage()._windowsOptions = nil}

  /// The UID to run the entrypoint of the container process.
  /// Defaults to user specified in image metadata if unspecified.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence
  /// for that container.
  /// +optional
  var runAsUser: Int64 {
    get {return _storage._runAsUser ?? 0}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// The GID to run the entrypoint of the container process.
  /// Uses runtime default if unset.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence
  /// for that container.
  /// +optional
  var runAsGroup: Int64 {
    get {return _storage._runAsGroup ?? 0}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// Indicates that the container must run as a non-root user.
  /// If true, the Kubelet will validate the image at runtime to ensure that it
  /// does not run as UID 0 (root) and fail to start the container if it does.
  /// If unset or false, no such validation will be performed.
  /// May also be set in SecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var runAsNonRoot: Bool {
    get {return _storage._runAsNonRoot ?? false}
    set {_uniqueStorage()._runAsNonRoot = newValue}
  }
  /// Returns true if `runAsNonRoot` has been explicitly set.
  var hasRunAsNonRoot: Bool {return _storage._runAsNonRoot != nil}
  /// Clears the value of `runAsNonRoot`. Subsequent reads from it will return its default value.
  mutating func clearRunAsNonRoot() {_uniqueStorage()._runAsNonRoot = nil}

  /// A list of groups applied to the first process run in each container, in addition
  /// to the container's primary GID.  If unspecified, no groups will be added to
  /// any container.
  /// +optional
  var supplementalGroups: [Int64] {
    get {return _storage._supplementalGroups}
    set {_uniqueStorage()._supplementalGroups = newValue}
  }

  /// A special supplemental group that applies to all containers in a pod.
  /// Some volume types allow the Kubelet to change the ownership of that volume
  /// to be owned by the pod:
  ///
  /// 1. The owning GID will be the FSGroup
  /// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  /// 3. The permission bits are OR'd with rw-rw----
  ///
  /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
  /// +optional
  var fsGroup: Int64 {
    get {return _storage._fsGroup ?? 0}
    set {_uniqueStorage()._fsGroup = newValue}
  }
  /// Returns true if `fsGroup` has been explicitly set.
  var hasFsGroup: Bool {return _storage._fsGroup != nil}
  /// Clears the value of `fsGroup`. Subsequent reads from it will return its default value.
  mutating func clearFsGroup() {_uniqueStorage()._fsGroup = nil}

  /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
  /// sysctls (by the container runtime) might fail to launch.
  /// +optional
  var sysctls: [K8s_Io_Api_Core_V1_Sysctl] {
    get {return _storage._sysctls}
    set {_uniqueStorage()._sysctls = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes the class of pods that should avoid this node.
/// Exactly one field should be set.
struct K8s_Io_Api_Core_V1_PodSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to controller whose pods should avoid this node.
  /// +optional
  var podController: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference {
    get {return _storage._podController ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference()}
    set {_uniqueStorage()._podController = newValue}
  }
  /// Returns true if `podController` has been explicitly set.
  var hasPodController: Bool {return _storage._podController != nil}
  /// Clears the value of `podController`. Subsequent reads from it will return its default value.
  mutating func clearPodController() {_uniqueStorage()._podController = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSpec is a description of a pod.
struct K8s_Io_Api_Core_V1_PodSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of volumes that can be mounted by containers belonging to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge,retainKeys
  var volumes: [K8s_Io_Api_Core_V1_Volume] {
    get {return _storage._volumes}
    set {_uniqueStorage()._volumes = newValue}
  }

  /// List of initialization containers belonging to the pod.
  /// Init containers are executed in order prior to containers being started. If any
  /// init container fails, the pod is considered to have failed and is handled according
  /// to its restartPolicy. The name for an init container or normal container must be
  /// unique among all containers.
  /// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
  /// The resourceRequirements of an init container are taken into account during scheduling
  /// by finding the highest request/limit for each resource type, and then using the max of
  /// of that value or the sum of the normal containers. Limits are applied to init containers
  /// in a similar fashion.
  /// Init containers cannot currently be added or removed.
  /// Cannot be updated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var initContainers: [K8s_Io_Api_Core_V1_Container] {
    get {return _storage._initContainers}
    set {_uniqueStorage()._initContainers = newValue}
  }

  /// List of containers belonging to the pod.
  /// Containers cannot currently be added or removed.
  /// There must be at least one container in a Pod.
  /// Cannot be updated.
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var containers: [K8s_Io_Api_Core_V1_Container] {
    get {return _storage._containers}
    set {_uniqueStorage()._containers = newValue}
  }

  /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
  /// pod to perform user-initiated actions such as debugging. This list cannot be specified when
  /// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
  /// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
  /// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var ephemeralContainers: [K8s_Io_Api_Core_V1_EphemeralContainer] {
    get {return _storage._ephemeralContainers}
    set {_uniqueStorage()._ephemeralContainers = newValue}
  }

  /// Restart policy for all containers within the pod.
  /// One of Always, OnFailure, Never.
  /// Default to Always.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  /// +optional
  var restartPolicy: String {
    get {return _storage._restartPolicy ?? String()}
    set {_uniqueStorage()._restartPolicy = newValue}
  }
  /// Returns true if `restartPolicy` has been explicitly set.
  var hasRestartPolicy: Bool {return _storage._restartPolicy != nil}
  /// Clears the value of `restartPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRestartPolicy() {_uniqueStorage()._restartPolicy = nil}

  /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
  /// Value must be non-negative integer. The value zero indicates delete immediately.
  /// If this value is nil, the default grace period will be used instead.
  /// The grace period is the duration in seconds after the processes running in the pod are sent
  /// a termination signal and the time when the processes are forcibly halted with a kill signal.
  /// Set this value longer than the expected cleanup time for your process.
  /// Defaults to 30 seconds.
  /// +optional
  var terminationGracePeriodSeconds: Int64 {
    get {return _storage._terminationGracePeriodSeconds ?? 0}
    set {_uniqueStorage()._terminationGracePeriodSeconds = newValue}
  }
  /// Returns true if `terminationGracePeriodSeconds` has been explicitly set.
  var hasTerminationGracePeriodSeconds: Bool {return _storage._terminationGracePeriodSeconds != nil}
  /// Clears the value of `terminationGracePeriodSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTerminationGracePeriodSeconds() {_uniqueStorage()._terminationGracePeriodSeconds = nil}

  /// Optional duration in seconds the pod may be active on the node relative to
  /// StartTime before the system will actively try to mark it failed and kill associated containers.
  /// Value must be a positive integer.
  /// +optional
  var activeDeadlineSeconds: Int64 {
    get {return _storage._activeDeadlineSeconds ?? 0}
    set {_uniqueStorage()._activeDeadlineSeconds = newValue}
  }
  /// Returns true if `activeDeadlineSeconds` has been explicitly set.
  var hasActiveDeadlineSeconds: Bool {return _storage._activeDeadlineSeconds != nil}
  /// Clears the value of `activeDeadlineSeconds`. Subsequent reads from it will return its default value.
  mutating func clearActiveDeadlineSeconds() {_uniqueStorage()._activeDeadlineSeconds = nil}

  /// Set DNS policy for the pod.
  /// Defaults to "ClusterFirst".
  /// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  /// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  /// To have DNS options set along with hostNetwork, you have to specify DNS policy
  /// explicitly to 'ClusterFirstWithHostNet'.
  /// +optional
  var dnsPolicy: String {
    get {return _storage._dnsPolicy ?? String()}
    set {_uniqueStorage()._dnsPolicy = newValue}
  }
  /// Returns true if `dnsPolicy` has been explicitly set.
  var hasDnsPolicy: Bool {return _storage._dnsPolicy != nil}
  /// Clears the value of `dnsPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDnsPolicy() {_uniqueStorage()._dnsPolicy = nil}

  /// NodeSelector is a selector which must be true for the pod to fit on a node.
  /// Selector which must match a node's labels for the pod to be scheduled on that node.
  /// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  /// +optional
  var nodeSelector: Dictionary<String,String> {
    get {return _storage._nodeSelector}
    set {_uniqueStorage()._nodeSelector = newValue}
  }

  /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  /// +optional
  var serviceAccountName: String {
    get {return _storage._serviceAccountName ?? String()}
    set {_uniqueStorage()._serviceAccountName = newValue}
  }
  /// Returns true if `serviceAccountName` has been explicitly set.
  var hasServiceAccountName: Bool {return _storage._serviceAccountName != nil}
  /// Clears the value of `serviceAccountName`. Subsequent reads from it will return its default value.
  mutating func clearServiceAccountName() {_uniqueStorage()._serviceAccountName = nil}

  /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
  /// Deprecated: Use serviceAccountName instead.
  /// +k8s:conversion-gen=false
  /// +optional
  var serviceAccount: String {
    get {return _storage._serviceAccount ?? String()}
    set {_uniqueStorage()._serviceAccount = newValue}
  }
  /// Returns true if `serviceAccount` has been explicitly set.
  var hasServiceAccount: Bool {return _storage._serviceAccount != nil}
  /// Clears the value of `serviceAccount`. Subsequent reads from it will return its default value.
  mutating func clearServiceAccount() {_uniqueStorage()._serviceAccount = nil}

  /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  /// +optional
  var automountServiceAccountToken: Bool {
    get {return _storage._automountServiceAccountToken ?? false}
    set {_uniqueStorage()._automountServiceAccountToken = newValue}
  }
  /// Returns true if `automountServiceAccountToken` has been explicitly set.
  var hasAutomountServiceAccountToken: Bool {return _storage._automountServiceAccountToken != nil}
  /// Clears the value of `automountServiceAccountToken`. Subsequent reads from it will return its default value.
  mutating func clearAutomountServiceAccountToken() {_uniqueStorage()._automountServiceAccountToken = nil}

  /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
  /// the scheduler simply schedules this pod onto that node, assuming that it fits resource
  /// requirements.
  /// +optional
  var nodeName: String {
    get {return _storage._nodeName ?? String()}
    set {_uniqueStorage()._nodeName = newValue}
  }
  /// Returns true if `nodeName` has been explicitly set.
  var hasNodeName: Bool {return _storage._nodeName != nil}
  /// Clears the value of `nodeName`. Subsequent reads from it will return its default value.
  mutating func clearNodeName() {_uniqueStorage()._nodeName = nil}

  /// Host networking requested for this pod. Use the host's network namespace.
  /// If this option is set, the ports that will be used must be specified.
  /// Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  var hostNetwork: Bool {
    get {return _storage._hostNetwork ?? false}
    set {_uniqueStorage()._hostNetwork = newValue}
  }
  /// Returns true if `hostNetwork` has been explicitly set.
  var hasHostNetwork: Bool {return _storage._hostNetwork != nil}
  /// Clears the value of `hostNetwork`. Subsequent reads from it will return its default value.
  mutating func clearHostNetwork() {_uniqueStorage()._hostNetwork = nil}

  /// Use the host's pid namespace.
  /// Optional: Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  var hostPid: Bool {
    get {return _storage._hostPid ?? false}
    set {_uniqueStorage()._hostPid = newValue}
  }
  /// Returns true if `hostPid` has been explicitly set.
  var hasHostPid: Bool {return _storage._hostPid != nil}
  /// Clears the value of `hostPid`. Subsequent reads from it will return its default value.
  mutating func clearHostPid() {_uniqueStorage()._hostPid = nil}

  /// Use the host's ipc namespace.
  /// Optional: Default to false.
  /// +k8s:conversion-gen=false
  /// +optional
  var hostIpc: Bool {
    get {return _storage._hostIpc ?? false}
    set {_uniqueStorage()._hostIpc = newValue}
  }
  /// Returns true if `hostIpc` has been explicitly set.
  var hasHostIpc: Bool {return _storage._hostIpc != nil}
  /// Clears the value of `hostIpc`. Subsequent reads from it will return its default value.
  mutating func clearHostIpc() {_uniqueStorage()._hostIpc = nil}

  /// Share a single process namespace between all of the containers in a pod.
  /// When this is set containers will be able to view and signal processes from other containers
  /// in the same pod, and the first process in each container will not be assigned PID 1.
  /// HostPID and ShareProcessNamespace cannot both be set.
  /// Optional: Default to false.
  /// This field is beta-level and may be disabled with the PodShareProcessNamespace feature.
  /// +k8s:conversion-gen=false
  /// +optional
  var shareProcessNamespace: Bool {
    get {return _storage._shareProcessNamespace ?? false}
    set {_uniqueStorage()._shareProcessNamespace = newValue}
  }
  /// Returns true if `shareProcessNamespace` has been explicitly set.
  var hasShareProcessNamespace: Bool {return _storage._shareProcessNamespace != nil}
  /// Clears the value of `shareProcessNamespace`. Subsequent reads from it will return its default value.
  mutating func clearShareProcessNamespace() {_uniqueStorage()._shareProcessNamespace = nil}

  /// SecurityContext holds pod-level security attributes and common container settings.
  /// Optional: Defaults to empty.  See type description for default values of each field.
  /// +optional
  var securityContext: K8s_Io_Api_Core_V1_PodSecurityContext {
    get {return _storage._securityContext ?? K8s_Io_Api_Core_V1_PodSecurityContext()}
    set {_uniqueStorage()._securityContext = newValue}
  }
  /// Returns true if `securityContext` has been explicitly set.
  var hasSecurityContext: Bool {return _storage._securityContext != nil}
  /// Clears the value of `securityContext`. Subsequent reads from it will return its default value.
  mutating func clearSecurityContext() {_uniqueStorage()._securityContext = nil}

  /// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  /// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  /// in the case of docker, only DockerConfig type secrets are honored.
  /// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var imagePullSecrets: [K8s_Io_Api_Core_V1_LocalObjectReference] {
    get {return _storage._imagePullSecrets}
    set {_uniqueStorage()._imagePullSecrets = newValue}
  }

  /// Specifies the hostname of the Pod
  /// If not specified, the pod's hostname will be set to a system-defined value.
  /// +optional
  var hostname: String {
    get {return _storage._hostname ?? String()}
    set {_uniqueStorage()._hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  var hasHostname: Bool {return _storage._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  mutating func clearHostname() {_uniqueStorage()._hostname = nil}

  /// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
  /// If not specified, the pod will not have a domainname at all.
  /// +optional
  var subdomain: String {
    get {return _storage._subdomain ?? String()}
    set {_uniqueStorage()._subdomain = newValue}
  }
  /// Returns true if `subdomain` has been explicitly set.
  var hasSubdomain: Bool {return _storage._subdomain != nil}
  /// Clears the value of `subdomain`. Subsequent reads from it will return its default value.
  mutating func clearSubdomain() {_uniqueStorage()._subdomain = nil}

  /// If specified, the pod's scheduling constraints
  /// +optional
  var affinity: K8s_Io_Api_Core_V1_Affinity {
    get {return _storage._affinity ?? K8s_Io_Api_Core_V1_Affinity()}
    set {_uniqueStorage()._affinity = newValue}
  }
  /// Returns true if `affinity` has been explicitly set.
  var hasAffinity: Bool {return _storage._affinity != nil}
  /// Clears the value of `affinity`. Subsequent reads from it will return its default value.
  mutating func clearAffinity() {_uniqueStorage()._affinity = nil}

  /// If specified, the pod will be dispatched by specified scheduler.
  /// If not specified, the pod will be dispatched by default scheduler.
  /// +optional
  var schedulerName: String {
    get {return _storage._schedulerName ?? String()}
    set {_uniqueStorage()._schedulerName = newValue}
  }
  /// Returns true if `schedulerName` has been explicitly set.
  var hasSchedulerName: Bool {return _storage._schedulerName != nil}
  /// Clears the value of `schedulerName`. Subsequent reads from it will return its default value.
  mutating func clearSchedulerName() {_uniqueStorage()._schedulerName = nil}

  /// If specified, the pod's tolerations.
  /// +optional
  var tolerations: [K8s_Io_Api_Core_V1_Toleration] {
    get {return _storage._tolerations}
    set {_uniqueStorage()._tolerations = newValue}
  }

  /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
  /// file if specified. This is only valid for non-hostNetwork pods.
  /// +optional
  /// +patchMergeKey=ip
  /// +patchStrategy=merge
  var hostAliases: [K8s_Io_Api_Core_V1_HostAlias] {
    get {return _storage._hostAliases}
    set {_uniqueStorage()._hostAliases = newValue}
  }

  /// If specified, indicates the pod's priority. "system-node-critical" and
  /// "system-cluster-critical" are two special keywords which indicate the
  /// highest priorities with the former being the highest priority. Any other
  /// name must be defined by creating a PriorityClass object with that name.
  /// If not specified, the pod priority will be default or zero if there is no
  /// default.
  /// +optional
  var priorityClassName: String {
    get {return _storage._priorityClassName ?? String()}
    set {_uniqueStorage()._priorityClassName = newValue}
  }
  /// Returns true if `priorityClassName` has been explicitly set.
  var hasPriorityClassName: Bool {return _storage._priorityClassName != nil}
  /// Clears the value of `priorityClassName`. Subsequent reads from it will return its default value.
  mutating func clearPriorityClassName() {_uniqueStorage()._priorityClassName = nil}

  /// The priority value. Various system components use this field to find the
  /// priority of the pod. When Priority Admission Controller is enabled, it
  /// prevents users from setting this field. The admission controller populates
  /// this field from PriorityClassName.
  /// The higher the value, the higher the priority.
  /// +optional
  var priority: Int32 {
    get {return _storage._priority ?? 0}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  mutating func clearPriority() {_uniqueStorage()._priority = nil}

  /// Specifies the DNS parameters of a pod.
  /// Parameters specified here will be merged to the generated DNS
  /// configuration based on DNSPolicy.
  /// +optional
  var dnsConfig: K8s_Io_Api_Core_V1_PodDNSConfig {
    get {return _storage._dnsConfig ?? K8s_Io_Api_Core_V1_PodDNSConfig()}
    set {_uniqueStorage()._dnsConfig = newValue}
  }
  /// Returns true if `dnsConfig` has been explicitly set.
  var hasDnsConfig: Bool {return _storage._dnsConfig != nil}
  /// Clears the value of `dnsConfig`. Subsequent reads from it will return its default value.
  mutating func clearDnsConfig() {_uniqueStorage()._dnsConfig = nil}

  /// If specified, all readiness gates will be evaluated for pod readiness.
  /// A pod is ready when all its containers are ready AND
  /// all conditions specified in the readiness gates have status equal to "True"
  /// More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
  /// +optional
  var readinessGates: [K8s_Io_Api_Core_V1_PodReadinessGate] {
    get {return _storage._readinessGates}
    set {_uniqueStorage()._readinessGates = newValue}
  }

  /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  /// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  /// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  /// empty definition that uses the default runtime handler.
  /// More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
  /// This is a beta feature as of Kubernetes v1.14.
  /// +optional
  var runtimeClassName: String {
    get {return _storage._runtimeClassName ?? String()}
    set {_uniqueStorage()._runtimeClassName = newValue}
  }
  /// Returns true if `runtimeClassName` has been explicitly set.
  var hasRuntimeClassName: Bool {return _storage._runtimeClassName != nil}
  /// Clears the value of `runtimeClassName`. Subsequent reads from it will return its default value.
  mutating func clearRuntimeClassName() {_uniqueStorage()._runtimeClassName = nil}

  /// EnableServiceLinks indicates whether information about services should be injected into pod's
  /// environment variables, matching the syntax of Docker links.
  /// Optional: Defaults to true.
  /// +optional
  var enableServiceLinks: Bool {
    get {return _storage._enableServiceLinks ?? false}
    set {_uniqueStorage()._enableServiceLinks = newValue}
  }
  /// Returns true if `enableServiceLinks` has been explicitly set.
  var hasEnableServiceLinks: Bool {return _storage._enableServiceLinks != nil}
  /// Clears the value of `enableServiceLinks`. Subsequent reads from it will return its default value.
  mutating func clearEnableServiceLinks() {_uniqueStorage()._enableServiceLinks = nil}

  /// PreemptionPolicy is the Policy for preempting pods with lower priority.
  /// One of Never, PreemptLowerPriority.
  /// Defaults to PreemptLowerPriority if unset.
  /// This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.
  /// +optional
  var preemptionPolicy: String {
    get {return _storage._preemptionPolicy ?? String()}
    set {_uniqueStorage()._preemptionPolicy = newValue}
  }
  /// Returns true if `preemptionPolicy` has been explicitly set.
  var hasPreemptionPolicy: Bool {return _storage._preemptionPolicy != nil}
  /// Clears the value of `preemptionPolicy`. Subsequent reads from it will return its default value.
  mutating func clearPreemptionPolicy() {_uniqueStorage()._preemptionPolicy = nil}

  /// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
  /// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
  /// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
  /// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
  /// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
  /// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
  /// More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md
  /// This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.
  /// +optional
  var overhead: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> {
    get {return _storage._overhead}
    set {_uniqueStorage()._overhead = newValue}
  }

  /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
  /// domains. Scheduler will schedule pods in a way which abides by the constraints.
  /// This field is alpha-level and is only honored by clusters that enables the EvenPodsSpread
  /// feature.
  /// All topologySpreadConstraints are ANDed.
  /// +optional
  /// +patchMergeKey=topologyKey
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=topologyKey
  /// +listMapKey=whenUnsatisfiable
  var topologySpreadConstraints: [K8s_Io_Api_Core_V1_TopologySpreadConstraint] {
    get {return _storage._topologySpreadConstraints}
    set {_uniqueStorage()._topologySpreadConstraints = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodStatus represents information about the status of a pod. Status may trail the actual
/// state of a system, especially if the node that hosts the pod cannot contact the control
/// plane.
struct K8s_Io_Api_Core_V1_PodStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
  /// The conditions array, the reason and message fields, and the individual container status
  /// arrays contain more detail about the pod's status.
  /// There are five possible phase values:
  ///
  /// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
  /// container images has not been created. This includes time before being scheduled as
  /// well as time spent downloading images over the network, which could take a while.
  /// Running: The pod has been bound to a node, and all of the containers have been created.
  /// At least one container is still running, or is in the process of starting or restarting.
  /// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
  /// Failed: All containers in the pod have terminated, and at least one container has
  /// terminated in failure. The container either exited with non-zero status or was terminated
  /// by the system.
  /// Unknown: For some reason the state of the pod could not be obtained, typically due to an
  /// error in communicating with the host of the pod.
  ///
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
  /// +optional
  var phase: String {
    get {return _storage._phase ?? String()}
    set {_uniqueStorage()._phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return _storage._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {_uniqueStorage()._phase = nil}

  /// Current service state of pod.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_PodCondition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  /// A human readable message indicating details about why the pod is in this condition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// A brief CamelCase message indicating details about why the pod is in this state.
  /// e.g. 'Evicted'
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
  /// scheduled right away as preemption victims receive their graceful termination periods.
  /// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
  /// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
  /// give the resources on this node to a higher priority pod that is created after preemption.
  /// As a result, this field may be different than PodSpec.nodeName when the pod is
  /// scheduled.
  /// +optional
  var nominatedNodeName: String {
    get {return _storage._nominatedNodeName ?? String()}
    set {_uniqueStorage()._nominatedNodeName = newValue}
  }
  /// Returns true if `nominatedNodeName` has been explicitly set.
  var hasNominatedNodeName: Bool {return _storage._nominatedNodeName != nil}
  /// Clears the value of `nominatedNodeName`. Subsequent reads from it will return its default value.
  mutating func clearNominatedNodeName() {_uniqueStorage()._nominatedNodeName = nil}

  /// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
  /// +optional
  var hostIp: String {
    get {return _storage._hostIp ?? String()}
    set {_uniqueStorage()._hostIp = newValue}
  }
  /// Returns true if `hostIp` has been explicitly set.
  var hasHostIp: Bool {return _storage._hostIp != nil}
  /// Clears the value of `hostIp`. Subsequent reads from it will return its default value.
  mutating func clearHostIp() {_uniqueStorage()._hostIp = nil}

  /// IP address allocated to the pod. Routable at least within the cluster.
  /// Empty if not yet allocated.
  /// +optional
  var podIp: String {
    get {return _storage._podIp ?? String()}
    set {_uniqueStorage()._podIp = newValue}
  }
  /// Returns true if `podIp` has been explicitly set.
  var hasPodIp: Bool {return _storage._podIp != nil}
  /// Clears the value of `podIp`. Subsequent reads from it will return its default value.
  mutating func clearPodIp() {_uniqueStorage()._podIp = nil}

  /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
  /// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
  /// is empty if no IPs have been allocated yet.
  /// +optional
  /// +patchStrategy=merge
  /// +patchMergeKey=ip
  var podIps: [K8s_Io_Api_Core_V1_PodIP] {
    get {return _storage._podIps}
    set {_uniqueStorage()._podIps = newValue}
  }

  /// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
  /// This is before the Kubelet pulled the container image(s) for the pod.
  /// +optional
  var startTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._startTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// The list has one entry per init container in the manifest. The most recent successful
  /// init container will have ready = true, the most recently started container will have
  /// startTime set.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  var initContainerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] {
    get {return _storage._initContainerStatuses}
    set {_uniqueStorage()._initContainerStatuses = newValue}
  }

  /// The list has one entry per container in the manifest. Each entry is currently the output
  /// of `docker inspect`.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  /// +optional
  var containerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] {
    get {return _storage._containerStatuses}
    set {_uniqueStorage()._containerStatuses = newValue}
  }

  /// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
  /// See PodQOSClass type for available QOS classes
  /// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
  /// +optional
  var qosClass: String {
    get {return _storage._qosClass ?? String()}
    set {_uniqueStorage()._qosClass = newValue}
  }
  /// Returns true if `qosClass` has been explicitly set.
  var hasQosClass: Bool {return _storage._qosClass != nil}
  /// Clears the value of `qosClass`. Subsequent reads from it will return its default value.
  mutating func clearQosClass() {_uniqueStorage()._qosClass = nil}

  /// Status for any ephemeral containers that have run in this pod.
  /// This field is alpha-level and is only populated by servers that enable the EphemeralContainers feature.
  /// +optional
  var ephemeralContainerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] {
    get {return _storage._ephemeralContainerStatuses}
    set {_uniqueStorage()._ephemeralContainerStatuses = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
struct K8s_Io_Api_Core_V1_PodStatusResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Most recently observed status of the pod.
  /// This data may not be up to date.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_PodStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_PodStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodTemplate describes a template for creating copies of a predefined pod.
struct K8s_Io_Api_Core_V1_PodTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Template defines the pods that will be created from this pod template.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodTemplateList is a list of PodTemplates.
struct K8s_Io_Api_Core_V1_PodTemplateList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of pod templates
  var items: [K8s_Io_Api_Core_V1_PodTemplate] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodTemplateSpec describes the data a pod should have when created from a template
struct K8s_Io_Api_Core_V1_PodTemplateSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior of the pod.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_PodSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_PodSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PortworxVolumeSource represents a Portworx volume resource.
struct K8s_Io_Api_Core_V1_PortworxVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VolumeID uniquely identifies a Portworx volume
  var volumeID: String {
    get {return _volumeID ?? String()}
    set {_volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  var hasVolumeID: Bool {return self._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  mutating func clearVolumeID() {self._volumeID = nil}

  /// FSType represents the filesystem type to mount
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volumeID: String? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
/// +k8s:openapi-gen=false
struct K8s_Io_Api_Core_V1_Preconditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the target UID.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uid: String? = nil
}

/// Describes a class of pods that should avoid this node.
struct K8s_Io_Api_Core_V1_PreferAvoidPodsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The class of pods.
  var podSignature: K8s_Io_Api_Core_V1_PodSignature {
    get {return _storage._podSignature ?? K8s_Io_Api_Core_V1_PodSignature()}
    set {_uniqueStorage()._podSignature = newValue}
  }
  /// Returns true if `podSignature` has been explicitly set.
  var hasPodSignature: Bool {return _storage._podSignature != nil}
  /// Clears the value of `podSignature`. Subsequent reads from it will return its default value.
  mutating func clearPodSignature() {_uniqueStorage()._podSignature = nil}

  /// Time at which this entry was added to the list.
  /// +optional
  var evictionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._evictionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._evictionTime = newValue}
  }
  /// Returns true if `evictionTime` has been explicitly set.
  var hasEvictionTime: Bool {return _storage._evictionTime != nil}
  /// Clears the value of `evictionTime`. Subsequent reads from it will return its default value.
  mutating func clearEvictionTime() {_uniqueStorage()._evictionTime = nil}

  /// (brief) reason why this entry was added to the list.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// Human readable message indicating why this entry was added to the list.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An empty preferred scheduling term matches all objects with implicit weight 0
/// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
struct K8s_Io_Api_Core_V1_PreferredSchedulingTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  var weight: Int32 {
    get {return _storage._weight ?? 0}
    set {_uniqueStorage()._weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  var hasWeight: Bool {return _storage._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  mutating func clearWeight() {_uniqueStorage()._weight = nil}

  /// A node selector term, associated with the corresponding weight.
  var preference: K8s_Io_Api_Core_V1_NodeSelectorTerm {
    get {return _storage._preference ?? K8s_Io_Api_Core_V1_NodeSelectorTerm()}
    set {_uniqueStorage()._preference = newValue}
  }
  /// Returns true if `preference` has been explicitly set.
  var hasPreference: Bool {return _storage._preference != nil}
  /// Clears the value of `preference`. Subsequent reads from it will return its default value.
  mutating func clearPreference() {_uniqueStorage()._preference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Probe describes a health check to be performed against a container to determine whether it is
/// alive or ready to receive traffic.
struct K8s_Io_Api_Core_V1_Probe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action taken to determine the health of a container
  var handler: K8s_Io_Api_Core_V1_Handler {
    get {return _storage._handler ?? K8s_Io_Api_Core_V1_Handler()}
    set {_uniqueStorage()._handler = newValue}
  }
  /// Returns true if `handler` has been explicitly set.
  var hasHandler: Bool {return _storage._handler != nil}
  /// Clears the value of `handler`. Subsequent reads from it will return its default value.
  mutating func clearHandler() {_uniqueStorage()._handler = nil}

  /// Number of seconds after the container has started before liveness probes are initiated.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  var initialDelaySeconds: Int32 {
    get {return _storage._initialDelaySeconds ?? 0}
    set {_uniqueStorage()._initialDelaySeconds = newValue}
  }
  /// Returns true if `initialDelaySeconds` has been explicitly set.
  var hasInitialDelaySeconds: Bool {return _storage._initialDelaySeconds != nil}
  /// Clears the value of `initialDelaySeconds`. Subsequent reads from it will return its default value.
  mutating func clearInitialDelaySeconds() {_uniqueStorage()._initialDelaySeconds = nil}

  /// Number of seconds after which the probe times out.
  /// Defaults to 1 second. Minimum value is 1.
  /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  /// +optional
  var timeoutSeconds: Int32 {
    get {return _storage._timeoutSeconds ?? 0}
    set {_uniqueStorage()._timeoutSeconds = newValue}
  }
  /// Returns true if `timeoutSeconds` has been explicitly set.
  var hasTimeoutSeconds: Bool {return _storage._timeoutSeconds != nil}
  /// Clears the value of `timeoutSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutSeconds() {_uniqueStorage()._timeoutSeconds = nil}

  /// How often (in seconds) to perform the probe.
  /// Default to 10 seconds. Minimum value is 1.
  /// +optional
  var periodSeconds: Int32 {
    get {return _storage._periodSeconds ?? 0}
    set {_uniqueStorage()._periodSeconds = newValue}
  }
  /// Returns true if `periodSeconds` has been explicitly set.
  var hasPeriodSeconds: Bool {return _storage._periodSeconds != nil}
  /// Clears the value of `periodSeconds`. Subsequent reads from it will return its default value.
  mutating func clearPeriodSeconds() {_uniqueStorage()._periodSeconds = nil}

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  /// +optional
  var successThreshold: Int32 {
    get {return _storage._successThreshold ?? 0}
    set {_uniqueStorage()._successThreshold = newValue}
  }
  /// Returns true if `successThreshold` has been explicitly set.
  var hasSuccessThreshold: Bool {return _storage._successThreshold != nil}
  /// Clears the value of `successThreshold`. Subsequent reads from it will return its default value.
  mutating func clearSuccessThreshold() {_uniqueStorage()._successThreshold = nil}

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
  /// Defaults to 3. Minimum value is 1.
  /// +optional
  var failureThreshold: Int32 {
    get {return _storage._failureThreshold ?? 0}
    set {_uniqueStorage()._failureThreshold = newValue}
  }
  /// Returns true if `failureThreshold` has been explicitly set.
  var hasFailureThreshold: Bool {return _storage._failureThreshold != nil}
  /// Clears the value of `failureThreshold`. Subsequent reads from it will return its default value.
  mutating func clearFailureThreshold() {_uniqueStorage()._failureThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a projected volume source
struct K8s_Io_Api_Core_V1_ProjectedVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of volume projections
  var sources: [K8s_Io_Api_Core_V1_VolumeProjection] = []

  /// Mode bits to use on created files by default. Must be a value between
  /// 0 and 0777.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var defaultMode: Int32 {
    get {return _defaultMode ?? 0}
    set {_defaultMode = newValue}
  }
  /// Returns true if `defaultMode` has been explicitly set.
  var hasDefaultMode: Bool {return self._defaultMode != nil}
  /// Clears the value of `defaultMode`. Subsequent reads from it will return its default value.
  mutating func clearDefaultMode() {self._defaultMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultMode: Int32? = nil
}

/// Represents a Quobyte mount that lasts the lifetime of a pod.
/// Quobyte volumes do not support ownership management or SELinux relabeling.
struct K8s_Io_Api_Core_V1_QuobyteVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Registry represents a single or multiple Quobyte Registry services
  /// specified as a string as host:port pair (multiple entries are separated with commas)
  /// which acts as the central registry for volumes
  var registry: String {
    get {return _registry ?? String()}
    set {_registry = newValue}
  }
  /// Returns true if `registry` has been explicitly set.
  var hasRegistry: Bool {return self._registry != nil}
  /// Clears the value of `registry`. Subsequent reads from it will return its default value.
  mutating func clearRegistry() {self._registry = nil}

  /// Volume is a string that references an already created Quobyte volume by name.
  var volume: String {
    get {return _volume ?? String()}
    set {_volume = newValue}
  }
  /// Returns true if `volume` has been explicitly set.
  var hasVolume: Bool {return self._volume != nil}
  /// Clears the value of `volume`. Subsequent reads from it will return its default value.
  mutating func clearVolume() {self._volume = nil}

  /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  /// Defaults to false.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// User to map volume access to
  /// Defaults to serivceaccount user
  /// +optional
  var user: String {
    get {return _user ?? String()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  /// Group to map volume access to
  /// Default is no group
  /// +optional
  var group: String {
    get {return _group ?? String()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  /// Tenant owning the given Quobyte volume in the Backend
  /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
  /// +optional
  var tenant: String {
    get {return _tenant ?? String()}
    set {_tenant = newValue}
  }
  /// Returns true if `tenant` has been explicitly set.
  var hasTenant: Bool {return self._tenant != nil}
  /// Clears the value of `tenant`. Subsequent reads from it will return its default value.
  mutating func clearTenant() {self._tenant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _registry: String? = nil
  fileprivate var _volume: String? = nil
  fileprivate var _readOnly: Bool? = nil
  fileprivate var _user: String? = nil
  fileprivate var _group: String? = nil
  fileprivate var _tenant: String? = nil
}

/// Represents a Rados Block Device mount that lasts the lifetime of a pod.
/// RBD volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_RBDPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of Ceph monitors.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  var monitors: [String] {
    get {return _storage._monitors}
    set {_uniqueStorage()._monitors = newValue}
  }

  /// The rados image name.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// The rados pool name.
  /// Default is rbd.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var pool: String {
    get {return _storage._pool ?? String()}
    set {_uniqueStorage()._pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return _storage._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {_uniqueStorage()._pool = nil}

  /// The rados user name.
  /// Default is admin.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Keyring is the path to key ring for RBDUser.
  /// Default is /etc/ceph/keyring.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var keyring: String {
    get {return _storage._keyring ?? String()}
    set {_uniqueStorage()._keyring = newValue}
  }
  /// Returns true if `keyring` has been explicitly set.
  var hasKeyring: Bool {return _storage._keyring != nil}
  /// Clears the value of `keyring`. Subsequent reads from it will return its default value.
  mutating func clearKeyring() {_uniqueStorage()._keyring = nil}

  /// SecretRef is name of the authentication secret for RBDUser. If provided
  /// overrides keyring.
  /// Default is nil.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a Rados Block Device mount that lasts the lifetime of a pod.
/// RBD volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_RBDVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of Ceph monitors.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  var monitors: [String] {
    get {return _storage._monitors}
    set {_uniqueStorage()._monitors = newValue}
  }

  /// The rados image name.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  /// Filesystem type of the volume that you want to mount.
  /// Tip: Ensure that the filesystem type is supported by the host operating system.
  /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  /// TODO: how do we prevent errors in the filesystem from compromising the machine
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// The rados pool name.
  /// Default is rbd.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var pool: String {
    get {return _storage._pool ?? String()}
    set {_uniqueStorage()._pool = newValue}
  }
  /// Returns true if `pool` has been explicitly set.
  var hasPool: Bool {return _storage._pool != nil}
  /// Clears the value of `pool`. Subsequent reads from it will return its default value.
  mutating func clearPool() {_uniqueStorage()._pool = nil}

  /// The rados user name.
  /// Default is admin.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Keyring is the path to key ring for RBDUser.
  /// Default is /etc/ceph/keyring.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var keyring: String {
    get {return _storage._keyring ?? String()}
    set {_uniqueStorage()._keyring = newValue}
  }
  /// Returns true if `keyring` has been explicitly set.
  var hasKeyring: Bool {return _storage._keyring != nil}
  /// Clears the value of `keyring`. Subsequent reads from it will return its default value.
  mutating func clearKeyring() {_uniqueStorage()._keyring = nil}

  /// SecretRef is name of the authentication secret for RBDUser. If provided
  /// overrides keyring.
  /// Default is nil.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
  /// Defaults to false.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RangeAllocation is not a public type.
struct K8s_Io_Api_Core_V1_RangeAllocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Range is string that identifies the range represented by 'data'.
  var range: String {
    get {return _storage._range ?? String()}
    set {_uniqueStorage()._range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return _storage._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {_uniqueStorage()._range = nil}

  /// Data is a bit array containing all allocated addresses in the previous segment.
  var data: Data {
    get {return _storage._data ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicationController represents the configuration of a replication controller.
struct K8s_Io_Api_Core_V1_ReplicationController {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the Labels of a ReplicationController are empty, they are defaulted to
  /// be the same as the Pod(s) that the replication controller manages.
  /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the specification of the desired behavior of the replication controller.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_ReplicationControllerSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_ReplicationControllerSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is the most recently observed status of the replication controller.
  /// This data may be out of date by some window of time.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_ReplicationControllerStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_ReplicationControllerStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicationControllerCondition describes the state of a replication controller at a certain point.
struct K8s_Io_Api_Core_V1_ReplicationControllerCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of replication controller condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicationControllerList is a collection of replication controllers.
struct K8s_Io_Api_Core_V1_ReplicationControllerList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of replication controllers.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
  var items: [K8s_Io_Api_Core_V1_ReplicationController] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicationControllerSpec is the specification of a replication controller.
struct K8s_Io_Api_Core_V1_ReplicationControllerSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Replicas is the number of desired replicas.
  /// This is a pointer to distinguish between explicit zero and unspecified.
  /// Defaults to 1.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  /// +optional
  var replicas: Int32 {
    get {return _storage._replicas ?? 0}
    set {_uniqueStorage()._replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return _storage._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {_uniqueStorage()._replicas = nil}

  /// Minimum number of seconds for which a newly created pod should be ready
  /// without any of its container crashing, for it to be considered available.
  /// Defaults to 0 (pod will be considered available as soon as it is ready)
  /// +optional
  var minReadySeconds: Int32 {
    get {return _storage._minReadySeconds ?? 0}
    set {_uniqueStorage()._minReadySeconds = newValue}
  }
  /// Returns true if `minReadySeconds` has been explicitly set.
  var hasMinReadySeconds: Bool {return _storage._minReadySeconds != nil}
  /// Clears the value of `minReadySeconds`. Subsequent reads from it will return its default value.
  mutating func clearMinReadySeconds() {_uniqueStorage()._minReadySeconds = nil}

  /// Selector is a label query over pods that should match the Replicas count.
  /// If Selector is empty, it is defaulted to the labels present on the Pod template.
  /// Label keys and values that must match in order to be controlled by this replication
  /// controller, if empty defaulted to labels on Pod template.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var selector: Dictionary<String,String> {
    get {return _storage._selector}
    set {_uniqueStorage()._selector = newValue}
  }

  /// Template is the object that describes the pod that will be created if
  /// insufficient replicas are detected. This takes precedence over a TemplateRef.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  /// +optional
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplicationControllerStatus represents the current status of a replication
/// controller.
struct K8s_Io_Api_Core_V1_ReplicationControllerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Replicas is the most recently oberved number of replicas.
  /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// The number of pods that have labels matching the labels of the pod template of the replication controller.
  /// +optional
  var fullyLabeledReplicas: Int32 {
    get {return _fullyLabeledReplicas ?? 0}
    set {_fullyLabeledReplicas = newValue}
  }
  /// Returns true if `fullyLabeledReplicas` has been explicitly set.
  var hasFullyLabeledReplicas: Bool {return self._fullyLabeledReplicas != nil}
  /// Clears the value of `fullyLabeledReplicas`. Subsequent reads from it will return its default value.
  mutating func clearFullyLabeledReplicas() {self._fullyLabeledReplicas = nil}

  /// The number of ready replicas for this replication controller.
  /// +optional
  var readyReplicas: Int32 {
    get {return _readyReplicas ?? 0}
    set {_readyReplicas = newValue}
  }
  /// Returns true if `readyReplicas` has been explicitly set.
  var hasReadyReplicas: Bool {return self._readyReplicas != nil}
  /// Clears the value of `readyReplicas`. Subsequent reads from it will return its default value.
  mutating func clearReadyReplicas() {self._readyReplicas = nil}

  /// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
  /// +optional
  var availableReplicas: Int32 {
    get {return _availableReplicas ?? 0}
    set {_availableReplicas = newValue}
  }
  /// Returns true if `availableReplicas` has been explicitly set.
  var hasAvailableReplicas: Bool {return self._availableReplicas != nil}
  /// Clears the value of `availableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearAvailableReplicas() {self._availableReplicas = nil}

  /// ObservedGeneration reflects the generation of the most recently observed replication controller.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// Represents the latest available observations of a replication controller's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Core_V1_ReplicationControllerCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
  fileprivate var _fullyLabeledReplicas: Int32? = nil
  fileprivate var _readyReplicas: Int32? = nil
  fileprivate var _availableReplicas: Int32? = nil
  fileprivate var _observedGeneration: Int64? = nil
}

/// ResourceFieldSelector represents container resources (cpu, memory) and their output format
struct K8s_Io_Api_Core_V1_ResourceFieldSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container name: required for volumes, optional for env vars
  /// +optional
  var containerName: String {
    get {return _storage._containerName ?? String()}
    set {_uniqueStorage()._containerName = newValue}
  }
  /// Returns true if `containerName` has been explicitly set.
  var hasContainerName: Bool {return _storage._containerName != nil}
  /// Clears the value of `containerName`. Subsequent reads from it will return its default value.
  mutating func clearContainerName() {_uniqueStorage()._containerName = nil}

  /// Required: resource to select
  var resource: String {
    get {return _storage._resource ?? String()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Specifies the output format of the exposed resources, defaults to "1"
  /// +optional
  var divisor: K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity {
    get {return _storage._divisor ?? K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity()}
    set {_uniqueStorage()._divisor = newValue}
  }
  /// Returns true if `divisor` has been explicitly set.
  var hasDivisor: Bool {return _storage._divisor != nil}
  /// Clears the value of `divisor`. Subsequent reads from it will return its default value.
  mutating func clearDivisor() {_uniqueStorage()._divisor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceQuota sets aggregate quota restrictions enforced per namespace
struct K8s_Io_Api_Core_V1_ResourceQuota {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the desired quota.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_ResourceQuotaSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_ResourceQuotaSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status defines the actual enforced quota and its current usage.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_ResourceQuotaStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_ResourceQuotaStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceQuotaList is a list of ResourceQuota items.
struct K8s_Io_Api_Core_V1_ResourceQuotaList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of ResourceQuota objects.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  var items: [K8s_Io_Api_Core_V1_ResourceQuota] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
struct K8s_Io_Api_Core_V1_ResourceQuotaSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hard is the set of desired hard limits for each named resource.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  /// +optional
  var hard: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> {
    get {return _storage._hard}
    set {_uniqueStorage()._hard = newValue}
  }

  /// A collection of filters that must match each object tracked by a quota.
  /// If not specified, the quota matches all objects.
  /// +optional
  var scopes: [String] {
    get {return _storage._scopes}
    set {_uniqueStorage()._scopes = newValue}
  }

  /// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
  /// but expressed using ScopeSelectorOperator in combination with possible values.
  /// For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
  /// +optional
  var scopeSelector: K8s_Io_Api_Core_V1_ScopeSelector {
    get {return _storage._scopeSelector ?? K8s_Io_Api_Core_V1_ScopeSelector()}
    set {_uniqueStorage()._scopeSelector = newValue}
  }
  /// Returns true if `scopeSelector` has been explicitly set.
  var hasScopeSelector: Bool {return _storage._scopeSelector != nil}
  /// Clears the value of `scopeSelector`. Subsequent reads from it will return its default value.
  mutating func clearScopeSelector() {_uniqueStorage()._scopeSelector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceQuotaStatus defines the enforced hard limits and observed use.
struct K8s_Io_Api_Core_V1_ResourceQuotaStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hard is the set of enforced hard limits for each named resource.
  /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  /// +optional
  var hard: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// Used is the current observed total usage of the resource in the namespace.
  /// +optional
  var used: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourceRequirements describes the compute resource requirements.
struct K8s_Io_Api_Core_V1_ResourceRequirements {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limits describes the maximum amount of compute resources allowed.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  /// +optional
  var limits: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  /// Requests describes the minimum amount of compute resources required.
  /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  /// otherwise to an implementation-defined value.
  /// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  /// +optional
  var requests: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SELinuxOptions are the labels to be applied to the container
struct K8s_Io_Api_Core_V1_SELinuxOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is a SELinux user label that applies to the container.
  /// +optional
  var user: String {
    get {return _user ?? String()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  /// Role is a SELinux role label that applies to the container.
  /// +optional
  var role: String {
    get {return _role ?? String()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  /// Type is a SELinux type label that applies to the container.
  /// +optional
  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Level is SELinux level label that applies to the container.
  /// +optional
  var level: String {
    get {return _level ?? String()}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: String? = nil
  fileprivate var _role: String? = nil
  fileprivate var _type: String? = nil
  fileprivate var _level: String? = nil
}

/// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
struct K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The host address of the ScaleIO API Gateway.
  var gateway: String {
    get {return _storage._gateway ?? String()}
    set {_uniqueStorage()._gateway = newValue}
  }
  /// Returns true if `gateway` has been explicitly set.
  var hasGateway: Bool {return _storage._gateway != nil}
  /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
  mutating func clearGateway() {_uniqueStorage()._gateway = nil}

  /// The name of the storage system as configured in ScaleIO.
  var system: String {
    get {return _storage._system ?? String()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  mutating func clearSystem() {_uniqueStorage()._system = nil}

  /// SecretRef references to the secret for ScaleIO user and other
  /// sensitive information. If this is not provided, Login operation will fail.
  var secretRef: K8s_Io_Api_Core_V1_SecretReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_SecretReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Flag to enable/disable SSL communication with Gateway, default false
  /// +optional
  var sslEnabled: Bool {
    get {return _storage._sslEnabled ?? false}
    set {_uniqueStorage()._sslEnabled = newValue}
  }
  /// Returns true if `sslEnabled` has been explicitly set.
  var hasSslEnabled: Bool {return _storage._sslEnabled != nil}
  /// Clears the value of `sslEnabled`. Subsequent reads from it will return its default value.
  mutating func clearSslEnabled() {_uniqueStorage()._sslEnabled = nil}

  /// The name of the ScaleIO Protection Domain for the configured storage.
  /// +optional
  var protectionDomain: String {
    get {return _storage._protectionDomain ?? String()}
    set {_uniqueStorage()._protectionDomain = newValue}
  }
  /// Returns true if `protectionDomain` has been explicitly set.
  var hasProtectionDomain: Bool {return _storage._protectionDomain != nil}
  /// Clears the value of `protectionDomain`. Subsequent reads from it will return its default value.
  mutating func clearProtectionDomain() {_uniqueStorage()._protectionDomain = nil}

  /// The ScaleIO Storage Pool associated with the protection domain.
  /// +optional
  var storagePool: String {
    get {return _storage._storagePool ?? String()}
    set {_uniqueStorage()._storagePool = newValue}
  }
  /// Returns true if `storagePool` has been explicitly set.
  var hasStoragePool: Bool {return _storage._storagePool != nil}
  /// Clears the value of `storagePool`. Subsequent reads from it will return its default value.
  mutating func clearStoragePool() {_uniqueStorage()._storagePool = nil}

  /// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  /// Default is ThinProvisioned.
  /// +optional
  var storageMode: String {
    get {return _storage._storageMode ?? String()}
    set {_uniqueStorage()._storageMode = newValue}
  }
  /// Returns true if `storageMode` has been explicitly set.
  var hasStorageMode: Bool {return _storage._storageMode != nil}
  /// Clears the value of `storageMode`. Subsequent reads from it will return its default value.
  mutating func clearStorageMode() {_uniqueStorage()._storageMode = nil}

  /// The name of a volume already created in the ScaleIO system
  /// that is associated with this volume source.
  var volumeName: String {
    get {return _storage._volumeName ?? String()}
    set {_uniqueStorage()._volumeName = newValue}
  }
  /// Returns true if `volumeName` has been explicitly set.
  var hasVolumeName: Bool {return _storage._volumeName != nil}
  /// Clears the value of `volumeName`. Subsequent reads from it will return its default value.
  mutating func clearVolumeName() {_uniqueStorage()._volumeName = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// Default is "xfs"
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ScaleIOVolumeSource represents a persistent ScaleIO volume
struct K8s_Io_Api_Core_V1_ScaleIOVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The host address of the ScaleIO API Gateway.
  var gateway: String {
    get {return _storage._gateway ?? String()}
    set {_uniqueStorage()._gateway = newValue}
  }
  /// Returns true if `gateway` has been explicitly set.
  var hasGateway: Bool {return _storage._gateway != nil}
  /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
  mutating func clearGateway() {_uniqueStorage()._gateway = nil}

  /// The name of the storage system as configured in ScaleIO.
  var system: String {
    get {return _storage._system ?? String()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  mutating func clearSystem() {_uniqueStorage()._system = nil}

  /// SecretRef references to the secret for ScaleIO user and other
  /// sensitive information. If this is not provided, Login operation will fail.
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  /// Flag to enable/disable SSL communication with Gateway, default false
  /// +optional
  var sslEnabled: Bool {
    get {return _storage._sslEnabled ?? false}
    set {_uniqueStorage()._sslEnabled = newValue}
  }
  /// Returns true if `sslEnabled` has been explicitly set.
  var hasSslEnabled: Bool {return _storage._sslEnabled != nil}
  /// Clears the value of `sslEnabled`. Subsequent reads from it will return its default value.
  mutating func clearSslEnabled() {_uniqueStorage()._sslEnabled = nil}

  /// The name of the ScaleIO Protection Domain for the configured storage.
  /// +optional
  var protectionDomain: String {
    get {return _storage._protectionDomain ?? String()}
    set {_uniqueStorage()._protectionDomain = newValue}
  }
  /// Returns true if `protectionDomain` has been explicitly set.
  var hasProtectionDomain: Bool {return _storage._protectionDomain != nil}
  /// Clears the value of `protectionDomain`. Subsequent reads from it will return its default value.
  mutating func clearProtectionDomain() {_uniqueStorage()._protectionDomain = nil}

  /// The ScaleIO Storage Pool associated with the protection domain.
  /// +optional
  var storagePool: String {
    get {return _storage._storagePool ?? String()}
    set {_uniqueStorage()._storagePool = newValue}
  }
  /// Returns true if `storagePool` has been explicitly set.
  var hasStoragePool: Bool {return _storage._storagePool != nil}
  /// Clears the value of `storagePool`. Subsequent reads from it will return its default value.
  mutating func clearStoragePool() {_uniqueStorage()._storagePool = nil}

  /// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  /// Default is ThinProvisioned.
  /// +optional
  var storageMode: String {
    get {return _storage._storageMode ?? String()}
    set {_uniqueStorage()._storageMode = newValue}
  }
  /// Returns true if `storageMode` has been explicitly set.
  var hasStorageMode: Bool {return _storage._storageMode != nil}
  /// Clears the value of `storageMode`. Subsequent reads from it will return its default value.
  mutating func clearStorageMode() {_uniqueStorage()._storageMode = nil}

  /// The name of a volume already created in the ScaleIO system
  /// that is associated with this volume source.
  var volumeName: String {
    get {return _storage._volumeName ?? String()}
    set {_uniqueStorage()._volumeName = newValue}
  }
  /// Returns true if `volumeName` has been explicitly set.
  var hasVolumeName: Bool {return _storage._volumeName != nil}
  /// Clears the value of `volumeName`. Subsequent reads from it will return its default value.
  mutating func clearVolumeName() {_uniqueStorage()._volumeName = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs".
  /// Default is "xfs".
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A scope selector represents the AND of the selectors represented
/// by the scoped-resource selector requirements.
struct K8s_Io_Api_Core_V1_ScopeSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of scope selector requirements by scope of the resources.
  /// +optional
  var matchExpressions: [K8s_Io_Api_Core_V1_ScopedResourceSelectorRequirement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
/// that relates the scope name and values.
struct K8s_Io_Api_Core_V1_ScopedResourceSelectorRequirement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the scope that the selector applies to.
  var scopeName: String {
    get {return _scopeName ?? String()}
    set {_scopeName = newValue}
  }
  /// Returns true if `scopeName` has been explicitly set.
  var hasScopeName: Bool {return self._scopeName != nil}
  /// Clears the value of `scopeName`. Subsequent reads from it will return its default value.
  mutating func clearScopeName() {self._scopeName = nil}

  /// Represents a scope's relationship to a set of values.
  /// Valid operators are In, NotIn, Exists, DoesNotExist.
  var `operator`: String {
    get {return _operator ?? String()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  /// An array of string values. If the operator is In or NotIn,
  /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
  /// the values array must be empty.
  /// This array is replaced during a strategic merge patch.
  /// +optional
  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scopeName: String? = nil
  fileprivate var _operator: String? = nil
}

/// Secret holds secret data of a certain type. The total bytes of the values in
/// the Data field must be less than MaxSecretSize bytes.
struct K8s_Io_Api_Core_V1_Secret {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Data contains the secret data. Each key must consist of alphanumeric
  /// characters, '-', '_' or '.'. The serialized form of the secret data is a
  /// base64 encoded string, representing the arbitrary (possibly non-string)
  /// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
  /// +optional
  var data: Dictionary<String,Data> {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// stringData allows specifying non-binary secret data in string form.
  /// It is provided as a write-only convenience method.
  /// All keys and values are merged into the data field on write, overwriting any existing values.
  /// It is never output when reading from the API.
  /// +k8s:conversion-gen=false
  /// +optional
  var stringData: Dictionary<String,String> {
    get {return _storage._stringData}
    set {_uniqueStorage()._stringData = newValue}
  }

  /// Used to facilitate programmatic handling of secret data.
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SecretEnvSource selects a Secret to populate the environment
/// variables with.
///
/// The contents of the target Secret's Data field will represent the
/// key-value pairs as environment variables.
struct K8s_Io_Api_Core_V1_SecretEnvSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Secret to select from.
  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// Specify whether the Secret must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SecretKeySelector selects a key of a Secret.
struct K8s_Io_Api_Core_V1_SecretKeySelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the secret in the pod's namespace to select from.
  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// The key of the secret to select from.  Must be a valid secret key.
  var key: String {
    get {return _storage._key ?? String()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Specify whether the Secret or its key must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SecretList is a list of Secret.
struct K8s_Io_Api_Core_V1_SecretList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of secret objects.
  /// More info: https://kubernetes.io/docs/concepts/configuration/secret
  var items: [K8s_Io_Api_Core_V1_Secret] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Adapts a secret into a projected volume.
///
/// The contents of the target Secret's Data field will be presented in a
/// projected volume as files using the keys in the Data field as the file names.
/// Note that this is identical to a secret volume source without the default
/// mode.
struct K8s_Io_Api_Core_V1_SecretProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._localObjectReference ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._localObjectReference = newValue}
  }
  /// Returns true if `localObjectReference` has been explicitly set.
  var hasLocalObjectReference: Bool {return _storage._localObjectReference != nil}
  /// Clears the value of `localObjectReference`. Subsequent reads from it will return its default value.
  mutating func clearLocalObjectReference() {_uniqueStorage()._localObjectReference = nil}

  /// If unspecified, each key-value pair in the Data field of the referenced
  /// Secret will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the Secret,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  var items: [K8s_Io_Api_Core_V1_KeyToPath] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  /// Specify whether the Secret or its key must be defined
  /// +optional
  var optional: Bool {
    get {return _storage._optional ?? false}
    set {_uniqueStorage()._optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return _storage._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {_uniqueStorage()._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SecretReference represents a Secret Reference. It has enough information to retrieve secret
/// in any namespace
struct K8s_Io_Api_Core_V1_SecretReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is unique within a namespace to reference a secret resource.
  /// +optional
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Namespace defines the space within which the secret name must be unique.
  /// +optional
  var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {self._namespace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _namespace: String? = nil
}

/// Adapts a Secret into a volume.
///
/// The contents of the target Secret's Data field will be presented in a volume
/// as files using the keys in the Data field as the file names.
/// Secret volumes support ownership management and SELinux relabeling.
struct K8s_Io_Api_Core_V1_SecretVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the secret in the pod's namespace to use.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  /// +optional
  var secretName: String {
    get {return _secretName ?? String()}
    set {_secretName = newValue}
  }
  /// Returns true if `secretName` has been explicitly set.
  var hasSecretName: Bool {return self._secretName != nil}
  /// Clears the value of `secretName`. Subsequent reads from it will return its default value.
  mutating func clearSecretName() {self._secretName = nil}

  /// If unspecified, each key-value pair in the Data field of the referenced
  /// Secret will be projected into the volume as a file whose name is the
  /// key and content is the value. If specified, the listed keys will be
  /// projected into the specified paths, and unlisted keys will not be
  /// present. If a key is specified which is not present in the Secret,
  /// the volume setup will error unless it is marked optional. Paths must be
  /// relative and may not contain the '..' path or start with '..'.
  /// +optional
  var items: [K8s_Io_Api_Core_V1_KeyToPath] = []

  /// Optional: mode bits to use on created files by default. Must be a
  /// value between 0 and 0777. Defaults to 0644.
  /// Directories within the path are not affected by this setting.
  /// This might be in conflict with other options that affect the file
  /// mode, like fsGroup, and the result can be other mode bits set.
  /// +optional
  var defaultMode: Int32 {
    get {return _defaultMode ?? 0}
    set {_defaultMode = newValue}
  }
  /// Returns true if `defaultMode` has been explicitly set.
  var hasDefaultMode: Bool {return self._defaultMode != nil}
  /// Clears the value of `defaultMode`. Subsequent reads from it will return its default value.
  mutating func clearDefaultMode() {self._defaultMode = nil}

  /// Specify whether the Secret or its keys must be defined
  /// +optional
  var optional: Bool {
    get {return _optional ?? false}
    set {_optional = newValue}
  }
  /// Returns true if `optional` has been explicitly set.
  var hasOptional: Bool {return self._optional != nil}
  /// Clears the value of `optional`. Subsequent reads from it will return its default value.
  mutating func clearOptional() {self._optional = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _secretName: String? = nil
  fileprivate var _defaultMode: Int32? = nil
  fileprivate var _optional: Bool? = nil
}

/// SecurityContext holds security configuration that will be applied to a container.
/// Some fields are present in both SecurityContext and PodSecurityContext.  When both
/// are set, the values in SecurityContext take precedence.
struct K8s_Io_Api_Core_V1_SecurityContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The capabilities to add/drop when running containers.
  /// Defaults to the default set of capabilities granted by the container runtime.
  /// +optional
  var capabilities: K8s_Io_Api_Core_V1_Capabilities {
    get {return _storage._capabilities ?? K8s_Io_Api_Core_V1_Capabilities()}
    set {_uniqueStorage()._capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  var hasCapabilities: Bool {return _storage._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

  /// Run container in privileged mode.
  /// Processes in privileged containers are essentially equivalent to root on the host.
  /// Defaults to false.
  /// +optional
  var privileged: Bool {
    get {return _storage._privileged ?? false}
    set {_uniqueStorage()._privileged = newValue}
  }
  /// Returns true if `privileged` has been explicitly set.
  var hasPrivileged: Bool {return _storage._privileged != nil}
  /// Clears the value of `privileged`. Subsequent reads from it will return its default value.
  mutating func clearPrivileged() {_uniqueStorage()._privileged = nil}

  /// The SELinux context to be applied to the container.
  /// If unspecified, the container runtime will allocate a random SELinux context for each
  /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions {
    get {return _storage._seLinuxOptions ?? K8s_Io_Api_Core_V1_SELinuxOptions()}
    set {_uniqueStorage()._seLinuxOptions = newValue}
  }
  /// Returns true if `seLinuxOptions` has been explicitly set.
  var hasSeLinuxOptions: Bool {return _storage._seLinuxOptions != nil}
  /// Clears the value of `seLinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSeLinuxOptions() {_uniqueStorage()._seLinuxOptions = nil}

  /// The Windows specific settings applied to all containers.
  /// If unspecified, the options from the PodSecurityContext will be used.
  /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var windowsOptions: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions {
    get {return _storage._windowsOptions ?? K8s_Io_Api_Core_V1_WindowsSecurityContextOptions()}
    set {_uniqueStorage()._windowsOptions = newValue}
  }
  /// Returns true if `windowsOptions` has been explicitly set.
  var hasWindowsOptions: Bool {return _storage._windowsOptions != nil}
  /// Clears the value of `windowsOptions`. Subsequent reads from it will return its default value.
  mutating func clearWindowsOptions() {_uniqueStorage()._windowsOptions = nil}

  /// The UID to run the entrypoint of the container process.
  /// Defaults to user specified in image metadata if unspecified.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var runAsUser: Int64 {
    get {return _storage._runAsUser ?? 0}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// The GID to run the entrypoint of the container process.
  /// Uses runtime default if unset.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var runAsGroup: Int64 {
    get {return _storage._runAsGroup ?? 0}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// Indicates that the container must run as a non-root user.
  /// If true, the Kubelet will validate the image at runtime to ensure that it
  /// does not run as UID 0 (root) and fail to start the container if it does.
  /// If unset or false, no such validation will be performed.
  /// May also be set in PodSecurityContext.  If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// +optional
  var runAsNonRoot: Bool {
    get {return _storage._runAsNonRoot ?? false}
    set {_uniqueStorage()._runAsNonRoot = newValue}
  }
  /// Returns true if `runAsNonRoot` has been explicitly set.
  var hasRunAsNonRoot: Bool {return _storage._runAsNonRoot != nil}
  /// Clears the value of `runAsNonRoot`. Subsequent reads from it will return its default value.
  mutating func clearRunAsNonRoot() {_uniqueStorage()._runAsNonRoot = nil}

  /// Whether this container has a read-only root filesystem.
  /// Default is false.
  /// +optional
  var readOnlyRootFilesystem: Bool {
    get {return _storage._readOnlyRootFilesystem ?? false}
    set {_uniqueStorage()._readOnlyRootFilesystem = newValue}
  }
  /// Returns true if `readOnlyRootFilesystem` has been explicitly set.
  var hasReadOnlyRootFilesystem: Bool {return _storage._readOnlyRootFilesystem != nil}
  /// Clears the value of `readOnlyRootFilesystem`. Subsequent reads from it will return its default value.
  mutating func clearReadOnlyRootFilesystem() {_uniqueStorage()._readOnlyRootFilesystem = nil}

  /// AllowPrivilegeEscalation controls whether a process can gain more
  /// privileges than its parent process. This bool directly controls if
  /// the no_new_privs flag will be set on the container process.
  /// AllowPrivilegeEscalation is true always when the container is:
  /// 1) run as Privileged
  /// 2) has CAP_SYS_ADMIN
  /// +optional
  var allowPrivilegeEscalation: Bool {
    get {return _storage._allowPrivilegeEscalation ?? false}
    set {_uniqueStorage()._allowPrivilegeEscalation = newValue}
  }
  /// Returns true if `allowPrivilegeEscalation` has been explicitly set.
  var hasAllowPrivilegeEscalation: Bool {return _storage._allowPrivilegeEscalation != nil}
  /// Clears the value of `allowPrivilegeEscalation`. Subsequent reads from it will return its default value.
  mutating func clearAllowPrivilegeEscalation() {_uniqueStorage()._allowPrivilegeEscalation = nil}

  /// procMount denotes the type of proc mount to use for the containers.
  /// The default is DefaultProcMount which uses the container runtime defaults for
  /// readonly paths and masked paths.
  /// This requires the ProcMountType feature flag to be enabled.
  /// +optional
  var procMount: String {
    get {return _storage._procMount ?? String()}
    set {_uniqueStorage()._procMount = newValue}
  }
  /// Returns true if `procMount` has been explicitly set.
  var hasProcMount: Bool {return _storage._procMount != nil}
  /// Clears the value of `procMount`. Subsequent reads from it will return its default value.
  mutating func clearProcMount() {_uniqueStorage()._procMount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SerializedReference is a reference to serialized object.
struct K8s_Io_Api_Core_V1_SerializedReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The reference to an object in the system.
  /// +optional
  var reference: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._reference ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  var hasReference: Bool {return _storage._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  mutating func clearReference() {_uniqueStorage()._reference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Service is a named abstraction of software service (for example, mysql) consisting of local port
/// (for example 3306) that the proxy listens on, and the selector that determines which pods
/// will answer requests sent through the proxy.
struct K8s_Io_Api_Core_V1_Service {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the behavior of a service.
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var spec: K8s_Io_Api_Core_V1_ServiceSpec {
    get {return _storage._spec ?? K8s_Io_Api_Core_V1_ServiceSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the service.
  /// Populated by the system.
  /// Read-only.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  /// +optional
  var status: K8s_Io_Api_Core_V1_ServiceStatus {
    get {return _storage._status ?? K8s_Io_Api_Core_V1_ServiceStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceAccount binds together:
/// * a name, understood by users, and perhaps by peripheral systems, for an identity
/// * a principal that can be authenticated and authorized
/// * a set of secrets
struct K8s_Io_Api_Core_V1_ServiceAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount.
  /// More info: https://kubernetes.io/docs/concepts/configuration/secret
  /// +optional
  /// +patchMergeKey=name
  /// +patchStrategy=merge
  var secrets: [K8s_Io_Api_Core_V1_ObjectReference] {
    get {return _storage._secrets}
    set {_uniqueStorage()._secrets = newValue}
  }

  /// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
  /// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
  /// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
  /// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  /// +optional
  var imagePullSecrets: [K8s_Io_Api_Core_V1_LocalObjectReference] {
    get {return _storage._imagePullSecrets}
    set {_uniqueStorage()._imagePullSecrets = newValue}
  }

  /// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
  /// Can be overridden at the pod level.
  /// +optional
  var automountServiceAccountToken: Bool {
    get {return _storage._automountServiceAccountToken ?? false}
    set {_uniqueStorage()._automountServiceAccountToken = newValue}
  }
  /// Returns true if `automountServiceAccountToken` has been explicitly set.
  var hasAutomountServiceAccountToken: Bool {return _storage._automountServiceAccountToken != nil}
  /// Clears the value of `automountServiceAccountToken`. Subsequent reads from it will return its default value.
  mutating func clearAutomountServiceAccountToken() {_uniqueStorage()._automountServiceAccountToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceAccountList is a list of ServiceAccount objects
struct K8s_Io_Api_Core_V1_ServiceAccountList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of ServiceAccounts.
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  var items: [K8s_Io_Api_Core_V1_ServiceAccount] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceAccountTokenProjection represents a projected service account token
/// volume. This projection can be used to insert a service account token into
/// the pods runtime filesystem for use against APIs (Kubernetes API Server or
/// otherwise).
struct K8s_Io_Api_Core_V1_ServiceAccountTokenProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Audience is the intended audience of the token. A recipient of a token
  /// must identify itself with an identifier specified in the audience of the
  /// token, and otherwise should reject the token. The audience defaults to the
  /// identifier of the apiserver.
  /// +optional
  var audience: String {
    get {return _audience ?? String()}
    set {_audience = newValue}
  }
  /// Returns true if `audience` has been explicitly set.
  var hasAudience: Bool {return self._audience != nil}
  /// Clears the value of `audience`. Subsequent reads from it will return its default value.
  mutating func clearAudience() {self._audience = nil}

  /// ExpirationSeconds is the requested duration of validity of the service
  /// account token. As the token approaches expiration, the kubelet volume
  /// plugin will proactively rotate the service account token. The kubelet will
  /// start trying to rotate the token if the token is older than 80 percent of
  /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
  /// and must be at least 10 minutes.
  /// +optional
  var expirationSeconds: Int64 {
    get {return _expirationSeconds ?? 0}
    set {_expirationSeconds = newValue}
  }
  /// Returns true if `expirationSeconds` has been explicitly set.
  var hasExpirationSeconds: Bool {return self._expirationSeconds != nil}
  /// Clears the value of `expirationSeconds`. Subsequent reads from it will return its default value.
  mutating func clearExpirationSeconds() {self._expirationSeconds = nil}

  /// Path is the path relative to the mount point of the file to project the
  /// token into.
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audience: String? = nil
  fileprivate var _expirationSeconds: Int64? = nil
  fileprivate var _path: String? = nil
}

/// ServiceList holds a list of services.
struct K8s_Io_Api_Core_V1_ServiceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// List of services
  var items: [K8s_Io_Api_Core_V1_Service] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServicePort contains information on service's port.
struct K8s_Io_Api_Core_V1_ServicePort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this port within the service. This must be a DNS_LABEL.
  /// All ports within a ServiceSpec must have unique names. When considering
  /// the endpoints for a Service, this must match the 'name' field in the
  /// EndpointPort.
  /// Optional if only one ServicePort is defined on this service.
  /// +optional
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  /// Default is TCP.
  /// +optional
  var `protocol`: String {
    get {return _storage._protocol ?? String()}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return _storage._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {_uniqueStorage()._protocol = nil}

  /// The port that will be exposed by this service.
  var port: Int32 {
    get {return _storage._port ?? 0}
    set {_uniqueStorage()._port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return _storage._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {_uniqueStorage()._port = nil}

  /// Number or name of the port to access on the pods targeted by the service.
  /// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  /// If this is a string, it will be looked up as a named port in the
  /// target Pod's container ports. If this is not specified, the value
  /// of the 'port' field is used (an identity map).
  /// This field is ignored for services with clusterIP=None, and should be
  /// omitted or set equal to the 'port' field.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  /// +optional
  var targetPort: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._targetPort ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._targetPort = newValue}
  }
  /// Returns true if `targetPort` has been explicitly set.
  var hasTargetPort: Bool {return _storage._targetPort != nil}
  /// Clears the value of `targetPort`. Subsequent reads from it will return its default value.
  mutating func clearTargetPort() {_uniqueStorage()._targetPort = nil}

  /// The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
  /// Usually assigned by the system. If specified, it will be allocated to the service
  /// if unused or else creation of the service will fail.
  /// Default is to auto-allocate a port if the ServiceType of this Service requires one.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  /// +optional
  var nodePort: Int32 {
    get {return _storage._nodePort ?? 0}
    set {_uniqueStorage()._nodePort = newValue}
  }
  /// Returns true if `nodePort` has been explicitly set.
  var hasNodePort: Bool {return _storage._nodePort != nil}
  /// Clears the value of `nodePort`. Subsequent reads from it will return its default value.
  mutating func clearNodePort() {_uniqueStorage()._nodePort = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceProxyOptions is the query options to a Service's proxy call.
struct K8s_Io_Api_Core_V1_ServiceProxyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path is the part of URLs that include service endpoints, suffixes,
  /// and parameters to use for the current proxy request to service.
  /// For example, the whole request URL is
  /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
  /// Path is _search?q=user:kimchy.
  /// +optional
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
}

/// ServiceSpec describes the attributes that a user creates on a service.
struct K8s_Io_Api_Core_V1_ServiceSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of ports that are exposed by this service.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +patchMergeKey=port
  /// +patchStrategy=merge
  /// +listType=map
  /// +listMapKey=port
  /// +listMapKey=protocol
  var ports: [K8s_Io_Api_Core_V1_ServicePort] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  /// Route service traffic to pods with label keys and values matching this
  /// selector. If empty or not present, the service is assumed to have an
  /// external process managing its endpoints, which Kubernetes will not
  /// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
  /// Ignored if type is ExternalName.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
  /// +optional
  var selector: Dictionary<String,String> {
    get {return _storage._selector}
    set {_uniqueStorage()._selector = newValue}
  }

  /// clusterIP is the IP address of the service and is usually assigned
  /// randomly by the master. If an address is specified manually and is not in
  /// use by others, it will be allocated to the service; otherwise, creation
  /// of the service will fail. This field can not be changed through updates.
  /// Valid values are "None", empty string (""), or a valid IP address. "None"
  /// can be specified for headless services when proxying is not required.
  /// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
  /// type is ExternalName.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +optional
  var clusterIp: String {
    get {return _storage._clusterIp ?? String()}
    set {_uniqueStorage()._clusterIp = newValue}
  }
  /// Returns true if `clusterIp` has been explicitly set.
  var hasClusterIp: Bool {return _storage._clusterIp != nil}
  /// Clears the value of `clusterIp`. Subsequent reads from it will return its default value.
  mutating func clearClusterIp() {_uniqueStorage()._clusterIp = nil}

  /// type determines how the Service is exposed. Defaults to ClusterIP. Valid
  /// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  /// "ExternalName" maps to the specified externalName.
  /// "ClusterIP" allocates a cluster-internal IP address for load-balancing to
  /// endpoints. Endpoints are determined by the selector or if that is not
  /// specified, by manual construction of an Endpoints object. If clusterIP is
  /// "None", no virtual IP is allocated and the endpoints are published as a
  /// set of endpoints rather than a stable IP.
  /// "NodePort" builds on ClusterIP and allocates a port on every node which
  /// routes to the clusterIP.
  /// "LoadBalancer" builds on NodePort and creates an
  /// external load-balancer (if supported in the current cloud) which routes
  /// to the clusterIP.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// externalIPs is a list of IP addresses for which nodes in the cluster
  /// will also accept traffic for this service.  These IPs are not managed by
  /// Kubernetes.  The user is responsible for ensuring that traffic arrives
  /// at a node with this IP.  A common example is external load-balancers
  /// that are not part of the Kubernetes system.
  /// +optional
  var externalIps: [String] {
    get {return _storage._externalIps}
    set {_uniqueStorage()._externalIps = newValue}
  }

  /// Supports "ClientIP" and "None". Used to maintain session affinity.
  /// Enable client IP based session affinity.
  /// Must be ClientIP or None.
  /// Defaults to None.
  /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  /// +optional
  var sessionAffinity: String {
    get {return _storage._sessionAffinity ?? String()}
    set {_uniqueStorage()._sessionAffinity = newValue}
  }
  /// Returns true if `sessionAffinity` has been explicitly set.
  var hasSessionAffinity: Bool {return _storage._sessionAffinity != nil}
  /// Clears the value of `sessionAffinity`. Subsequent reads from it will return its default value.
  mutating func clearSessionAffinity() {_uniqueStorage()._sessionAffinity = nil}

  /// Only applies to Service Type: LoadBalancer
  /// LoadBalancer will get created with the IP specified in this field.
  /// This feature depends on whether the underlying cloud-provider supports specifying
  /// the loadBalancerIP when a load balancer is created.
  /// This field will be ignored if the cloud-provider does not support the feature.
  /// +optional
  var loadBalancerIp: String {
    get {return _storage._loadBalancerIp ?? String()}
    set {_uniqueStorage()._loadBalancerIp = newValue}
  }
  /// Returns true if `loadBalancerIp` has been explicitly set.
  var hasLoadBalancerIp: Bool {return _storage._loadBalancerIp != nil}
  /// Clears the value of `loadBalancerIp`. Subsequent reads from it will return its default value.
  mutating func clearLoadBalancerIp() {_uniqueStorage()._loadBalancerIp = nil}

  /// If specified and supported by the platform, this will restrict traffic through the cloud-provider
  /// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
  /// cloud-provider does not support the feature."
  /// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  /// +optional
  var loadBalancerSourceRanges: [String] {
    get {return _storage._loadBalancerSourceRanges}
    set {_uniqueStorage()._loadBalancerSourceRanges = newValue}
  }

  /// externalName is the external reference that kubedns or equivalent will
  /// return as a CNAME record for this service. No proxying will be involved.
  /// Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
  /// and requires Type to be ExternalName.
  /// +optional
  var externalName: String {
    get {return _storage._externalName ?? String()}
    set {_uniqueStorage()._externalName = newValue}
  }
  /// Returns true if `externalName` has been explicitly set.
  var hasExternalName: Bool {return _storage._externalName != nil}
  /// Clears the value of `externalName`. Subsequent reads from it will return its default value.
  mutating func clearExternalName() {_uniqueStorage()._externalName = nil}

  /// externalTrafficPolicy denotes if this Service desires to route external
  /// traffic to node-local or cluster-wide endpoints. "Local" preserves the
  /// client source IP and avoids a second hop for LoadBalancer and Nodeport
  /// type services, but risks potentially imbalanced traffic spreading.
  /// "Cluster" obscures the client source IP and may cause a second hop to
  /// another node, but should have good overall load-spreading.
  /// +optional
  var externalTrafficPolicy: String {
    get {return _storage._externalTrafficPolicy ?? String()}
    set {_uniqueStorage()._externalTrafficPolicy = newValue}
  }
  /// Returns true if `externalTrafficPolicy` has been explicitly set.
  var hasExternalTrafficPolicy: Bool {return _storage._externalTrafficPolicy != nil}
  /// Clears the value of `externalTrafficPolicy`. Subsequent reads from it will return its default value.
  mutating func clearExternalTrafficPolicy() {_uniqueStorage()._externalTrafficPolicy = nil}

  /// healthCheckNodePort specifies the healthcheck nodePort for the service.
  /// If not specified, HealthCheckNodePort is created by the service api
  /// backend with the allocated nodePort. Will use user-specified nodePort value
  /// if specified by the client. Only effects when Type is set to LoadBalancer
  /// and ExternalTrafficPolicy is set to Local.
  /// +optional
  var healthCheckNodePort: Int32 {
    get {return _storage._healthCheckNodePort ?? 0}
    set {_uniqueStorage()._healthCheckNodePort = newValue}
  }
  /// Returns true if `healthCheckNodePort` has been explicitly set.
  var hasHealthCheckNodePort: Bool {return _storage._healthCheckNodePort != nil}
  /// Clears the value of `healthCheckNodePort`. Subsequent reads from it will return its default value.
  mutating func clearHealthCheckNodePort() {_uniqueStorage()._healthCheckNodePort = nil}

  /// publishNotReadyAddresses, when set to true, indicates that DNS implementations
  /// must publish the notReadyAddresses of subsets for the Endpoints associated with
  /// the Service. The default value is false.
  /// The primary use case for setting this field is to use a StatefulSet's Headless Service
  /// to propagate SRV records for its Pods without respect to their readiness for purpose
  /// of peer discovery.
  /// +optional
  var publishNotReadyAddresses: Bool {
    get {return _storage._publishNotReadyAddresses ?? false}
    set {_uniqueStorage()._publishNotReadyAddresses = newValue}
  }
  /// Returns true if `publishNotReadyAddresses` has been explicitly set.
  var hasPublishNotReadyAddresses: Bool {return _storage._publishNotReadyAddresses != nil}
  /// Clears the value of `publishNotReadyAddresses`. Subsequent reads from it will return its default value.
  mutating func clearPublishNotReadyAddresses() {_uniqueStorage()._publishNotReadyAddresses = nil}

  /// sessionAffinityConfig contains the configurations of session affinity.
  /// +optional
  var sessionAffinityConfig: K8s_Io_Api_Core_V1_SessionAffinityConfig {
    get {return _storage._sessionAffinityConfig ?? K8s_Io_Api_Core_V1_SessionAffinityConfig()}
    set {_uniqueStorage()._sessionAffinityConfig = newValue}
  }
  /// Returns true if `sessionAffinityConfig` has been explicitly set.
  var hasSessionAffinityConfig: Bool {return _storage._sessionAffinityConfig != nil}
  /// Clears the value of `sessionAffinityConfig`. Subsequent reads from it will return its default value.
  mutating func clearSessionAffinityConfig() {_uniqueStorage()._sessionAffinityConfig = nil}

  /// ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs.
  /// IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is
  /// available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used.
  /// Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which
  /// allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of
  /// this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the
  /// cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
  /// +optional
  var ipFamily: String {
    get {return _storage._ipFamily ?? String()}
    set {_uniqueStorage()._ipFamily = newValue}
  }
  /// Returns true if `ipFamily` has been explicitly set.
  var hasIpFamily: Bool {return _storage._ipFamily != nil}
  /// Clears the value of `ipFamily`. Subsequent reads from it will return its default value.
  mutating func clearIpFamily() {_uniqueStorage()._ipFamily = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ServiceStatus represents the current status of a service.
struct K8s_Io_Api_Core_V1_ServiceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LoadBalancer contains the current status of the load-balancer,
  /// if one is present.
  /// +optional
  var loadBalancer: K8s_Io_Api_Core_V1_LoadBalancerStatus {
    get {return _storage._loadBalancer ?? K8s_Io_Api_Core_V1_LoadBalancerStatus()}
    set {_uniqueStorage()._loadBalancer = newValue}
  }
  /// Returns true if `loadBalancer` has been explicitly set.
  var hasLoadBalancer: Bool {return _storage._loadBalancer != nil}
  /// Clears the value of `loadBalancer`. Subsequent reads from it will return its default value.
  mutating func clearLoadBalancer() {_uniqueStorage()._loadBalancer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionAffinityConfig represents the configurations of session affinity.
struct K8s_Io_Api_Core_V1_SessionAffinityConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// clientIP contains the configurations of Client IP based session affinity.
  /// +optional
  var clientIp: K8s_Io_Api_Core_V1_ClientIPConfig {
    get {return _storage._clientIp ?? K8s_Io_Api_Core_V1_ClientIPConfig()}
    set {_uniqueStorage()._clientIp = newValue}
  }
  /// Returns true if `clientIp` has been explicitly set.
  var hasClientIp: Bool {return _storage._clientIp != nil}
  /// Clears the value of `clientIp`. Subsequent reads from it will return its default value.
  mutating func clearClientIp() {_uniqueStorage()._clientIp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a StorageOS persistent volume resource.
struct K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VolumeName is the human-readable name of the StorageOS volume.  Volume
  /// names are only unique within a namespace.
  var volumeName: String {
    get {return _storage._volumeName ?? String()}
    set {_uniqueStorage()._volumeName = newValue}
  }
  /// Returns true if `volumeName` has been explicitly set.
  var hasVolumeName: Bool {return _storage._volumeName != nil}
  /// Clears the value of `volumeName`. Subsequent reads from it will return its default value.
  mutating func clearVolumeName() {_uniqueStorage()._volumeName = nil}

  /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
  /// namespace is specified then the Pod's namespace will be used.  This allows the
  /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  /// Set VolumeName to any name to override the default behaviour.
  /// Set to "default" if you are not using namespaces within StorageOS.
  /// Namespaces that do not pre-exist within StorageOS will be created.
  /// +optional
  var volumeNamespace: String {
    get {return _storage._volumeNamespace ?? String()}
    set {_uniqueStorage()._volumeNamespace = newValue}
  }
  /// Returns true if `volumeNamespace` has been explicitly set.
  var hasVolumeNamespace: Bool {return _storage._volumeNamespace != nil}
  /// Clears the value of `volumeNamespace`. Subsequent reads from it will return its default value.
  mutating func clearVolumeNamespace() {_uniqueStorage()._volumeNamespace = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// SecretRef specifies the secret to use for obtaining the StorageOS API
  /// credentials.  If not specified, default values will be attempted.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_ObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_ObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a StorageOS persistent volume resource.
struct K8s_Io_Api_Core_V1_StorageOSVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// VolumeName is the human-readable name of the StorageOS volume.  Volume
  /// names are only unique within a namespace.
  var volumeName: String {
    get {return _storage._volumeName ?? String()}
    set {_uniqueStorage()._volumeName = newValue}
  }
  /// Returns true if `volumeName` has been explicitly set.
  var hasVolumeName: Bool {return _storage._volumeName != nil}
  /// Clears the value of `volumeName`. Subsequent reads from it will return its default value.
  mutating func clearVolumeName() {_uniqueStorage()._volumeName = nil}

  /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
  /// namespace is specified then the Pod's namespace will be used.  This allows the
  /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  /// Set VolumeName to any name to override the default behaviour.
  /// Set to "default" if you are not using namespaces within StorageOS.
  /// Namespaces that do not pre-exist within StorageOS will be created.
  /// +optional
  var volumeNamespace: String {
    get {return _storage._volumeNamespace ?? String()}
    set {_uniqueStorage()._volumeNamespace = newValue}
  }
  /// Returns true if `volumeNamespace` has been explicitly set.
  var hasVolumeNamespace: Bool {return _storage._volumeNamespace != nil}
  /// Clears the value of `volumeNamespace`. Subsequent reads from it will return its default value.
  mutating func clearVolumeNamespace() {_uniqueStorage()._volumeNamespace = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  var fsType: String {
    get {return _storage._fsType ?? String()}
    set {_uniqueStorage()._fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return _storage._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {_uniqueStorage()._fsType = nil}

  /// Defaults to false (read/write). ReadOnly here will force
  /// the ReadOnly setting in VolumeMounts.
  /// +optional
  var readOnly: Bool {
    get {return _storage._readOnly ?? false}
    set {_uniqueStorage()._readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return _storage._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {_uniqueStorage()._readOnly = nil}

  /// SecretRef specifies the secret to use for obtaining the StorageOS API
  /// credentials.  If not specified, default values will be attempted.
  /// +optional
  var secretRef: K8s_Io_Api_Core_V1_LocalObjectReference {
    get {return _storage._secretRef ?? K8s_Io_Api_Core_V1_LocalObjectReference()}
    set {_uniqueStorage()._secretRef = newValue}
  }
  /// Returns true if `secretRef` has been explicitly set.
  var hasSecretRef: Bool {return _storage._secretRef != nil}
  /// Clears the value of `secretRef`. Subsequent reads from it will return its default value.
  mutating func clearSecretRef() {_uniqueStorage()._secretRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Sysctl defines a kernel parameter to be set
struct K8s_Io_Api_Core_V1_Sysctl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of a property to set
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Value of a property to set
  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: String? = nil
}

/// TCPSocketAction describes an action based on opening a socket
struct K8s_Io_Api_Core_V1_TCPSocketAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number or name of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  /// Name must be an IANA_SVC_NAME.
  var port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._port ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return _storage._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {_uniqueStorage()._port = nil}

  /// Optional: Host name to connect to, defaults to the pod IP.
  /// +optional
  var host: String {
    get {return _storage._host ?? String()}
    set {_uniqueStorage()._host = newValue}
  }
  /// Returns true if `host` has been explicitly set.
  var hasHost: Bool {return _storage._host != nil}
  /// Clears the value of `host`. Subsequent reads from it will return its default value.
  mutating func clearHost() {_uniqueStorage()._host = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The node this Taint is attached to has the "effect" on
/// any pod that does not tolerate the Taint.
struct K8s_Io_Api_Core_V1_Taint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The taint key to be applied to a node.
  var key: String {
    get {return _storage._key ?? String()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Required. The taint value corresponding to the taint key.
  /// +optional
  var value: String {
    get {return _storage._value ?? String()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  /// Required. The effect of the taint on pods
  /// that do not tolerate the taint.
  /// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
  var effect: String {
    get {return _storage._effect ?? String()}
    set {_uniqueStorage()._effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  var hasEffect: Bool {return _storage._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  mutating func clearEffect() {_uniqueStorage()._effect = nil}

  /// TimeAdded represents the time at which the taint was added.
  /// It is only written for NoExecute taints.
  /// +optional
  var timeAdded: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._timeAdded ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._timeAdded = newValue}
  }
  /// Returns true if `timeAdded` has been explicitly set.
  var hasTimeAdded: Bool {return _storage._timeAdded != nil}
  /// Clears the value of `timeAdded`. Subsequent reads from it will return its default value.
  mutating func clearTimeAdded() {_uniqueStorage()._timeAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The pod this Toleration is attached to tolerates any taint that matches
/// the triple <key,value,effect> using the matching operator <operator>.
struct K8s_Io_Api_Core_V1_Toleration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
  /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  /// +optional
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// Operator represents a key's relationship to the value.
  /// Valid operators are Exists and Equal. Defaults to Equal.
  /// Exists is equivalent to wildcard for value, so that a pod can
  /// tolerate all taints of a particular category.
  /// +optional
  var `operator`: String {
    get {return _operator ?? String()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  /// Value is the taint value the toleration matches to.
  /// If the operator is Exists, the value should be empty, otherwise just a regular string.
  /// +optional
  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  /// Effect indicates the taint effect to match. Empty means match all taint effects.
  /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  /// +optional
  var effect: String {
    get {return _effect ?? String()}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  mutating func clearEffect() {self._effect = nil}

  /// TolerationSeconds represents the period of time the toleration (which must be
  /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  /// it is not set, which means tolerate the taint forever (do not evict). Zero and
  /// negative values will be treated as 0 (evict immediately) by the system.
  /// +optional
  var tolerationSeconds: Int64 {
    get {return _tolerationSeconds ?? 0}
    set {_tolerationSeconds = newValue}
  }
  /// Returns true if `tolerationSeconds` has been explicitly set.
  var hasTolerationSeconds: Bool {return self._tolerationSeconds != nil}
  /// Clears the value of `tolerationSeconds`. Subsequent reads from it will return its default value.
  mutating func clearTolerationSeconds() {self._tolerationSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _operator: String? = nil
  fileprivate var _value: String? = nil
  fileprivate var _effect: String? = nil
  fileprivate var _tolerationSeconds: Int64? = nil
}

/// A topology selector requirement is a selector that matches given label.
/// This is an alpha feature and may change in the future.
struct K8s_Io_Api_Core_V1_TopologySelectorLabelRequirement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label key that the selector applies to.
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// An array of string values. One value must match the label to be selected.
  /// Each entry in Values is ORed.
  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
}

/// A topology selector term represents the result of label queries.
/// A null or empty topology selector term matches no objects.
/// The requirements of them are ANDed.
/// It provides a subset of functionality as NodeSelectorTerm.
/// This is an alpha feature and may change in the future.
struct K8s_Io_Api_Core_V1_TopologySelectorTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of topology selector requirements by labels.
  /// +optional
  var matchLabelExpressions: [K8s_Io_Api_Core_V1_TopologySelectorLabelRequirement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
struct K8s_Io_Api_Core_V1_TopologySpreadConstraint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MaxSkew describes the degree to which pods may be unevenly distributed.
  /// It's the maximum permitted difference between the number of matching pods in
  /// any two topology domains of a given topology type.
  /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  /// labelSelector spread as 1/1/0:
  /// +-------+-------+-------+
  /// | zone1 | zone2 | zone3 |
  /// +-------+-------+-------+
  /// |   P   |   P   |       |
  /// +-------+-------+-------+
  /// - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
  /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
  /// violate MaxSkew(1).
  /// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
  /// It's a required field. Default value is 1 and 0 is not allowed.
  var maxSkew: Int32 {
    get {return _storage._maxSkew ?? 0}
    set {_uniqueStorage()._maxSkew = newValue}
  }
  /// Returns true if `maxSkew` has been explicitly set.
  var hasMaxSkew: Bool {return _storage._maxSkew != nil}
  /// Clears the value of `maxSkew`. Subsequent reads from it will return its default value.
  mutating func clearMaxSkew() {_uniqueStorage()._maxSkew = nil}

  /// TopologyKey is the key of node labels. Nodes that have a label with this key
  /// and identical values are considered to be in the same topology.
  /// We consider each <key, value> as a "bucket", and try to put balanced number
  /// of pods into each bucket.
  /// It's a required field.
  var topologyKey: String {
    get {return _storage._topologyKey ?? String()}
    set {_uniqueStorage()._topologyKey = newValue}
  }
  /// Returns true if `topologyKey` has been explicitly set.
  var hasTopologyKey: Bool {return _storage._topologyKey != nil}
  /// Clears the value of `topologyKey`. Subsequent reads from it will return its default value.
  mutating func clearTopologyKey() {_uniqueStorage()._topologyKey = nil}

  /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
  /// the spread constraint.
  /// - DoNotSchedule (default) tells the scheduler not to schedule it
  /// - ScheduleAnyway tells the scheduler to still schedule it
  /// It's considered as "Unsatisfiable" if and only if placing incoming pod on any
  /// topology violates "MaxSkew".
  /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  /// labelSelector spread as 3/1/1:
  /// +-------+-------+-------+
  /// | zone1 | zone2 | zone3 |
  /// +-------+-------+-------+
  /// | P P P |   P   |   P   |
  /// +-------+-------+-------+
  /// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
  /// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
  /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
  /// won't make it *more* imbalanced.
  /// It's a required field.
  var whenUnsatisfiable: String {
    get {return _storage._whenUnsatisfiable ?? String()}
    set {_uniqueStorage()._whenUnsatisfiable = newValue}
  }
  /// Returns true if `whenUnsatisfiable` has been explicitly set.
  var hasWhenUnsatisfiable: Bool {return _storage._whenUnsatisfiable != nil}
  /// Clears the value of `whenUnsatisfiable`. Subsequent reads from it will return its default value.
  mutating func clearWhenUnsatisfiable() {_uniqueStorage()._whenUnsatisfiable = nil}

  /// LabelSelector is used to find matching pods.
  /// Pods that match this label selector are counted to determine the number of pods
  /// in their corresponding topology domain.
  /// +optional
  var labelSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._labelSelector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._labelSelector = newValue}
  }
  /// Returns true if `labelSelector` has been explicitly set.
  var hasLabelSelector: Bool {return _storage._labelSelector != nil}
  /// Clears the value of `labelSelector`. Subsequent reads from it will return its default value.
  mutating func clearLabelSelector() {_uniqueStorage()._labelSelector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TypedLocalObjectReference contains enough information to let you locate the
/// typed referenced object inside the same namespace.
struct K8s_Io_Api_Core_V1_TypedLocalObjectReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// APIGroup is the group for the resource being referenced.
  /// If APIGroup is not specified, the specified Kind must be in the core API group.
  /// For any other third-party types, APIGroup is required.
  /// +optional
  var apiGroup: String {
    get {return _apiGroup ?? String()}
    set {_apiGroup = newValue}
  }
  /// Returns true if `apiGroup` has been explicitly set.
  var hasApiGroup: Bool {return self._apiGroup != nil}
  /// Clears the value of `apiGroup`. Subsequent reads from it will return its default value.
  mutating func clearApiGroup() {self._apiGroup = nil}

  /// Kind is the type of resource being referenced
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// Name is the name of resource being referenced
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _apiGroup: String? = nil
  fileprivate var _kind: String? = nil
  fileprivate var _name: String? = nil
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
struct K8s_Io_Api_Core_V1_Volume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Volume's name.
  /// Must be a DNS_LABEL and unique within the pod.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// VolumeSource represents the location and type of the mounted volume.
  /// If not specified, the Volume is implied to be an EmptyDir.
  /// This implied behavior is deprecated and will be removed in a future version.
  var volumeSource: K8s_Io_Api_Core_V1_VolumeSource {
    get {return _storage._volumeSource ?? K8s_Io_Api_Core_V1_VolumeSource()}
    set {_uniqueStorage()._volumeSource = newValue}
  }
  /// Returns true if `volumeSource` has been explicitly set.
  var hasVolumeSource: Bool {return _storage._volumeSource != nil}
  /// Clears the value of `volumeSource`. Subsequent reads from it will return its default value.
  mutating func clearVolumeSource() {_uniqueStorage()._volumeSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// volumeDevice describes a mapping of a raw block device within a container.
struct K8s_Io_Api_Core_V1_VolumeDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name must match the name of a persistentVolumeClaim in the pod
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// devicePath is the path inside of the container that the device will be mapped to.
  var devicePath: String {
    get {return _devicePath ?? String()}
    set {_devicePath = newValue}
  }
  /// Returns true if `devicePath` has been explicitly set.
  var hasDevicePath: Bool {return self._devicePath != nil}
  /// Clears the value of `devicePath`. Subsequent reads from it will return its default value.
  mutating func clearDevicePath() {self._devicePath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _devicePath: String? = nil
}

/// VolumeMount describes a mounting of a Volume within a container.
struct K8s_Io_Api_Core_V1_VolumeMount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This must match the Name of a Volume.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Mounted read-only if true, read-write otherwise (false or unspecified).
  /// Defaults to false.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  /// Path within the container at which the volume should be mounted.  Must
  /// not contain ':'.
  var mountPath: String {
    get {return _mountPath ?? String()}
    set {_mountPath = newValue}
  }
  /// Returns true if `mountPath` has been explicitly set.
  var hasMountPath: Bool {return self._mountPath != nil}
  /// Clears the value of `mountPath`. Subsequent reads from it will return its default value.
  mutating func clearMountPath() {self._mountPath = nil}

  /// Path within the volume from which the container's volume should be mounted.
  /// Defaults to "" (volume's root).
  /// +optional
  var subPath: String {
    get {return _subPath ?? String()}
    set {_subPath = newValue}
  }
  /// Returns true if `subPath` has been explicitly set.
  var hasSubPath: Bool {return self._subPath != nil}
  /// Clears the value of `subPath`. Subsequent reads from it will return its default value.
  mutating func clearSubPath() {self._subPath = nil}

  /// mountPropagation determines how mounts are propagated from the host
  /// to container and the other way around.
  /// When not set, MountPropagationNone is used.
  /// This field is beta in 1.10.
  /// +optional
  var mountPropagation: String {
    get {return _mountPropagation ?? String()}
    set {_mountPropagation = newValue}
  }
  /// Returns true if `mountPropagation` has been explicitly set.
  var hasMountPropagation: Bool {return self._mountPropagation != nil}
  /// Clears the value of `mountPropagation`. Subsequent reads from it will return its default value.
  mutating func clearMountPropagation() {self._mountPropagation = nil}

  /// Expanded path within the volume from which the container's volume should be mounted.
  /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  /// Defaults to "" (volume's root).
  /// SubPathExpr and SubPath are mutually exclusive.
  /// +optional
  var subPathExpr: String {
    get {return _subPathExpr ?? String()}
    set {_subPathExpr = newValue}
  }
  /// Returns true if `subPathExpr` has been explicitly set.
  var hasSubPathExpr: Bool {return self._subPathExpr != nil}
  /// Clears the value of `subPathExpr`. Subsequent reads from it will return its default value.
  mutating func clearSubPathExpr() {self._subPathExpr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _readOnly: Bool? = nil
  fileprivate var _mountPath: String? = nil
  fileprivate var _subPath: String? = nil
  fileprivate var _mountPropagation: String? = nil
  fileprivate var _subPathExpr: String? = nil
}

/// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
struct K8s_Io_Api_Core_V1_VolumeNodeAffinity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required specifies hard node constraints that must be met.
  var required: K8s_Io_Api_Core_V1_NodeSelector {
    get {return _storage._required ?? K8s_Io_Api_Core_V1_NodeSelector()}
    set {_uniqueStorage()._required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Bool {return _storage._required != nil}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating func clearRequired() {_uniqueStorage()._required = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Projection that may be projected along with other supported volume types
struct K8s_Io_Api_Core_V1_VolumeProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// information about the secret data to project
  /// +optional
  var secret: K8s_Io_Api_Core_V1_SecretProjection {
    get {return _storage._secret ?? K8s_Io_Api_Core_V1_SecretProjection()}
    set {_uniqueStorage()._secret = newValue}
  }
  /// Returns true if `secret` has been explicitly set.
  var hasSecret: Bool {return _storage._secret != nil}
  /// Clears the value of `secret`. Subsequent reads from it will return its default value.
  mutating func clearSecret() {_uniqueStorage()._secret = nil}

  /// information about the downwardAPI data to project
  /// +optional
  var downwardApi: K8s_Io_Api_Core_V1_DownwardAPIProjection {
    get {return _storage._downwardApi ?? K8s_Io_Api_Core_V1_DownwardAPIProjection()}
    set {_uniqueStorage()._downwardApi = newValue}
  }
  /// Returns true if `downwardApi` has been explicitly set.
  var hasDownwardApi: Bool {return _storage._downwardApi != nil}
  /// Clears the value of `downwardApi`. Subsequent reads from it will return its default value.
  mutating func clearDownwardApi() {_uniqueStorage()._downwardApi = nil}

  /// information about the configMap data to project
  /// +optional
  var configMap: K8s_Io_Api_Core_V1_ConfigMapProjection {
    get {return _storage._configMap ?? K8s_Io_Api_Core_V1_ConfigMapProjection()}
    set {_uniqueStorage()._configMap = newValue}
  }
  /// Returns true if `configMap` has been explicitly set.
  var hasConfigMap: Bool {return _storage._configMap != nil}
  /// Clears the value of `configMap`. Subsequent reads from it will return its default value.
  mutating func clearConfigMap() {_uniqueStorage()._configMap = nil}

  /// information about the serviceAccountToken data to project
  /// +optional
  var serviceAccountToken: K8s_Io_Api_Core_V1_ServiceAccountTokenProjection {
    get {return _storage._serviceAccountToken ?? K8s_Io_Api_Core_V1_ServiceAccountTokenProjection()}
    set {_uniqueStorage()._serviceAccountToken = newValue}
  }
  /// Returns true if `serviceAccountToken` has been explicitly set.
  var hasServiceAccountToken: Bool {return _storage._serviceAccountToken != nil}
  /// Clears the value of `serviceAccountToken`. Subsequent reads from it will return its default value.
  mutating func clearServiceAccountToken() {_uniqueStorage()._serviceAccountToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the source of a volume to mount.
/// Only one of its members may be specified.
struct K8s_Io_Api_Core_V1_VolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostPath represents a pre-existing file or directory on the host
  /// machine that is directly exposed to the container. This is generally
  /// used for system agents or other privileged things that are allowed
  /// to see the host machine. Most containers will NOT need this.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  /// ---
  /// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  /// mount host directories as read/write.
  /// +optional
  var hostPath: K8s_Io_Api_Core_V1_HostPathVolumeSource {
    get {return _storage._hostPath ?? K8s_Io_Api_Core_V1_HostPathVolumeSource()}
    set {_uniqueStorage()._hostPath = newValue}
  }
  /// Returns true if `hostPath` has been explicitly set.
  var hasHostPath: Bool {return _storage._hostPath != nil}
  /// Clears the value of `hostPath`. Subsequent reads from it will return its default value.
  mutating func clearHostPath() {_uniqueStorage()._hostPath = nil}

  /// EmptyDir represents a temporary directory that shares a pod's lifetime.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  /// +optional
  var emptyDir: K8s_Io_Api_Core_V1_EmptyDirVolumeSource {
    get {return _storage._emptyDir ?? K8s_Io_Api_Core_V1_EmptyDirVolumeSource()}
    set {_uniqueStorage()._emptyDir = newValue}
  }
  /// Returns true if `emptyDir` has been explicitly set.
  var hasEmptyDir: Bool {return _storage._emptyDir != nil}
  /// Clears the value of `emptyDir`. Subsequent reads from it will return its default value.
  mutating func clearEmptyDir() {_uniqueStorage()._emptyDir = nil}

  /// GCEPersistentDisk represents a GCE Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  /// +optional
  var gcePersistentDisk: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource {
    get {return _storage._gcePersistentDisk ?? K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource()}
    set {_uniqueStorage()._gcePersistentDisk = newValue}
  }
  /// Returns true if `gcePersistentDisk` has been explicitly set.
  var hasGcePersistentDisk: Bool {return _storage._gcePersistentDisk != nil}
  /// Clears the value of `gcePersistentDisk`. Subsequent reads from it will return its default value.
  mutating func clearGcePersistentDisk() {_uniqueStorage()._gcePersistentDisk = nil}

  /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  /// +optional
  var awsElasticBlockStore: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource {
    get {return _storage._awsElasticBlockStore ?? K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource()}
    set {_uniqueStorage()._awsElasticBlockStore = newValue}
  }
  /// Returns true if `awsElasticBlockStore` has been explicitly set.
  var hasAwsElasticBlockStore: Bool {return _storage._awsElasticBlockStore != nil}
  /// Clears the value of `awsElasticBlockStore`. Subsequent reads from it will return its default value.
  mutating func clearAwsElasticBlockStore() {_uniqueStorage()._awsElasticBlockStore = nil}

  /// GitRepo represents a git repository at a particular revision.
  /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  /// into the Pod's container.
  /// +optional
  var gitRepo: K8s_Io_Api_Core_V1_GitRepoVolumeSource {
    get {return _storage._gitRepo ?? K8s_Io_Api_Core_V1_GitRepoVolumeSource()}
    set {_uniqueStorage()._gitRepo = newValue}
  }
  /// Returns true if `gitRepo` has been explicitly set.
  var hasGitRepo: Bool {return _storage._gitRepo != nil}
  /// Clears the value of `gitRepo`. Subsequent reads from it will return its default value.
  mutating func clearGitRepo() {_uniqueStorage()._gitRepo = nil}

  /// Secret represents a secret that should populate this volume.
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  /// +optional
  var secret: K8s_Io_Api_Core_V1_SecretVolumeSource {
    get {return _storage._secret ?? K8s_Io_Api_Core_V1_SecretVolumeSource()}
    set {_uniqueStorage()._secret = newValue}
  }
  /// Returns true if `secret` has been explicitly set.
  var hasSecret: Bool {return _storage._secret != nil}
  /// Clears the value of `secret`. Subsequent reads from it will return its default value.
  mutating func clearSecret() {_uniqueStorage()._secret = nil}

  /// NFS represents an NFS mount on the host that shares a pod's lifetime
  /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  /// +optional
  var nfs: K8s_Io_Api_Core_V1_NFSVolumeSource {
    get {return _storage._nfs ?? K8s_Io_Api_Core_V1_NFSVolumeSource()}
    set {_uniqueStorage()._nfs = newValue}
  }
  /// Returns true if `nfs` has been explicitly set.
  var hasNfs: Bool {return _storage._nfs != nil}
  /// Clears the value of `nfs`. Subsequent reads from it will return its default value.
  mutating func clearNfs() {_uniqueStorage()._nfs = nil}

  /// ISCSI represents an ISCSI Disk resource that is attached to a
  /// kubelet's host machine and then exposed to the pod.
  /// More info: https://examples.k8s.io/volumes/iscsi/README.md
  /// +optional
  var iscsi: K8s_Io_Api_Core_V1_ISCSIVolumeSource {
    get {return _storage._iscsi ?? K8s_Io_Api_Core_V1_ISCSIVolumeSource()}
    set {_uniqueStorage()._iscsi = newValue}
  }
  /// Returns true if `iscsi` has been explicitly set.
  var hasIscsi: Bool {return _storage._iscsi != nil}
  /// Clears the value of `iscsi`. Subsequent reads from it will return its default value.
  mutating func clearIscsi() {_uniqueStorage()._iscsi = nil}

  /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
  /// +optional
  var glusterfs: K8s_Io_Api_Core_V1_GlusterfsVolumeSource {
    get {return _storage._glusterfs ?? K8s_Io_Api_Core_V1_GlusterfsVolumeSource()}
    set {_uniqueStorage()._glusterfs = newValue}
  }
  /// Returns true if `glusterfs` has been explicitly set.
  var hasGlusterfs: Bool {return _storage._glusterfs != nil}
  /// Clears the value of `glusterfs`. Subsequent reads from it will return its default value.
  mutating func clearGlusterfs() {_uniqueStorage()._glusterfs = nil}

  /// PersistentVolumeClaimVolumeSource represents a reference to a
  /// PersistentVolumeClaim in the same namespace.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  /// +optional
  var persistentVolumeClaim: K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource {
    get {return _storage._persistentVolumeClaim ?? K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource()}
    set {_uniqueStorage()._persistentVolumeClaim = newValue}
  }
  /// Returns true if `persistentVolumeClaim` has been explicitly set.
  var hasPersistentVolumeClaim: Bool {return _storage._persistentVolumeClaim != nil}
  /// Clears the value of `persistentVolumeClaim`. Subsequent reads from it will return its default value.
  mutating func clearPersistentVolumeClaim() {_uniqueStorage()._persistentVolumeClaim = nil}

  /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  /// More info: https://examples.k8s.io/volumes/rbd/README.md
  /// +optional
  var rbd: K8s_Io_Api_Core_V1_RBDVolumeSource {
    get {return _storage._rbd ?? K8s_Io_Api_Core_V1_RBDVolumeSource()}
    set {_uniqueStorage()._rbd = newValue}
  }
  /// Returns true if `rbd` has been explicitly set.
  var hasRbd: Bool {return _storage._rbd != nil}
  /// Clears the value of `rbd`. Subsequent reads from it will return its default value.
  mutating func clearRbd() {_uniqueStorage()._rbd = nil}

  /// FlexVolume represents a generic volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// +optional
  var flexVolume: K8s_Io_Api_Core_V1_FlexVolumeSource {
    get {return _storage._flexVolume ?? K8s_Io_Api_Core_V1_FlexVolumeSource()}
    set {_uniqueStorage()._flexVolume = newValue}
  }
  /// Returns true if `flexVolume` has been explicitly set.
  var hasFlexVolume: Bool {return _storage._flexVolume != nil}
  /// Clears the value of `flexVolume`. Subsequent reads from it will return its default value.
  mutating func clearFlexVolume() {_uniqueStorage()._flexVolume = nil}

  /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
  /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  /// +optional
  var cinder: K8s_Io_Api_Core_V1_CinderVolumeSource {
    get {return _storage._cinder ?? K8s_Io_Api_Core_V1_CinderVolumeSource()}
    set {_uniqueStorage()._cinder = newValue}
  }
  /// Returns true if `cinder` has been explicitly set.
  var hasCinder: Bool {return _storage._cinder != nil}
  /// Clears the value of `cinder`. Subsequent reads from it will return its default value.
  mutating func clearCinder() {_uniqueStorage()._cinder = nil}

  /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  /// +optional
  var cephfs: K8s_Io_Api_Core_V1_CephFSVolumeSource {
    get {return _storage._cephfs ?? K8s_Io_Api_Core_V1_CephFSVolumeSource()}
    set {_uniqueStorage()._cephfs = newValue}
  }
  /// Returns true if `cephfs` has been explicitly set.
  var hasCephfs: Bool {return _storage._cephfs != nil}
  /// Clears the value of `cephfs`. Subsequent reads from it will return its default value.
  mutating func clearCephfs() {_uniqueStorage()._cephfs = nil}

  /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  /// +optional
  var flocker: K8s_Io_Api_Core_V1_FlockerVolumeSource {
    get {return _storage._flocker ?? K8s_Io_Api_Core_V1_FlockerVolumeSource()}
    set {_uniqueStorage()._flocker = newValue}
  }
  /// Returns true if `flocker` has been explicitly set.
  var hasFlocker: Bool {return _storage._flocker != nil}
  /// Clears the value of `flocker`. Subsequent reads from it will return its default value.
  mutating func clearFlocker() {_uniqueStorage()._flocker = nil}

  /// DownwardAPI represents downward API about the pod that should populate this volume
  /// +optional
  var downwardApi: K8s_Io_Api_Core_V1_DownwardAPIVolumeSource {
    get {return _storage._downwardApi ?? K8s_Io_Api_Core_V1_DownwardAPIVolumeSource()}
    set {_uniqueStorage()._downwardApi = newValue}
  }
  /// Returns true if `downwardApi` has been explicitly set.
  var hasDownwardApi: Bool {return _storage._downwardApi != nil}
  /// Clears the value of `downwardApi`. Subsequent reads from it will return its default value.
  mutating func clearDownwardApi() {_uniqueStorage()._downwardApi = nil}

  /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  /// +optional
  var fc: K8s_Io_Api_Core_V1_FCVolumeSource {
    get {return _storage._fc ?? K8s_Io_Api_Core_V1_FCVolumeSource()}
    set {_uniqueStorage()._fc = newValue}
  }
  /// Returns true if `fc` has been explicitly set.
  var hasFc: Bool {return _storage._fc != nil}
  /// Clears the value of `fc`. Subsequent reads from it will return its default value.
  mutating func clearFc() {_uniqueStorage()._fc = nil}

  /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// +optional
  var azureFile: K8s_Io_Api_Core_V1_AzureFileVolumeSource {
    get {return _storage._azureFile ?? K8s_Io_Api_Core_V1_AzureFileVolumeSource()}
    set {_uniqueStorage()._azureFile = newValue}
  }
  /// Returns true if `azureFile` has been explicitly set.
  var hasAzureFile: Bool {return _storage._azureFile != nil}
  /// Clears the value of `azureFile`. Subsequent reads from it will return its default value.
  mutating func clearAzureFile() {_uniqueStorage()._azureFile = nil}

  /// ConfigMap represents a configMap that should populate this volume
  /// +optional
  var configMap: K8s_Io_Api_Core_V1_ConfigMapVolumeSource {
    get {return _storage._configMap ?? K8s_Io_Api_Core_V1_ConfigMapVolumeSource()}
    set {_uniqueStorage()._configMap = newValue}
  }
  /// Returns true if `configMap` has been explicitly set.
  var hasConfigMap: Bool {return _storage._configMap != nil}
  /// Clears the value of `configMap`. Subsequent reads from it will return its default value.
  mutating func clearConfigMap() {_uniqueStorage()._configMap = nil}

  /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  /// +optional
  var vsphereVolume: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource {
    get {return _storage._vsphereVolume ?? K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource()}
    set {_uniqueStorage()._vsphereVolume = newValue}
  }
  /// Returns true if `vsphereVolume` has been explicitly set.
  var hasVsphereVolume: Bool {return _storage._vsphereVolume != nil}
  /// Clears the value of `vsphereVolume`. Subsequent reads from it will return its default value.
  mutating func clearVsphereVolume() {_uniqueStorage()._vsphereVolume = nil}

  /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  /// +optional
  var quobyte: K8s_Io_Api_Core_V1_QuobyteVolumeSource {
    get {return _storage._quobyte ?? K8s_Io_Api_Core_V1_QuobyteVolumeSource()}
    set {_uniqueStorage()._quobyte = newValue}
  }
  /// Returns true if `quobyte` has been explicitly set.
  var hasQuobyte: Bool {return _storage._quobyte != nil}
  /// Clears the value of `quobyte`. Subsequent reads from it will return its default value.
  mutating func clearQuobyte() {_uniqueStorage()._quobyte = nil}

  /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  /// +optional
  var azureDisk: K8s_Io_Api_Core_V1_AzureDiskVolumeSource {
    get {return _storage._azureDisk ?? K8s_Io_Api_Core_V1_AzureDiskVolumeSource()}
    set {_uniqueStorage()._azureDisk = newValue}
  }
  /// Returns true if `azureDisk` has been explicitly set.
  var hasAzureDisk: Bool {return _storage._azureDisk != nil}
  /// Clears the value of `azureDisk`. Subsequent reads from it will return its default value.
  mutating func clearAzureDisk() {_uniqueStorage()._azureDisk = nil}

  /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  var photonPersistentDisk: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource {
    get {return _storage._photonPersistentDisk ?? K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource()}
    set {_uniqueStorage()._photonPersistentDisk = newValue}
  }
  /// Returns true if `photonPersistentDisk` has been explicitly set.
  var hasPhotonPersistentDisk: Bool {return _storage._photonPersistentDisk != nil}
  /// Clears the value of `photonPersistentDisk`. Subsequent reads from it will return its default value.
  mutating func clearPhotonPersistentDisk() {_uniqueStorage()._photonPersistentDisk = nil}

  /// Items for all in one resources secrets, configmaps, and downward API
  var projected: K8s_Io_Api_Core_V1_ProjectedVolumeSource {
    get {return _storage._projected ?? K8s_Io_Api_Core_V1_ProjectedVolumeSource()}
    set {_uniqueStorage()._projected = newValue}
  }
  /// Returns true if `projected` has been explicitly set.
  var hasProjected: Bool {return _storage._projected != nil}
  /// Clears the value of `projected`. Subsequent reads from it will return its default value.
  mutating func clearProjected() {_uniqueStorage()._projected = nil}

  /// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
  /// +optional
  var portworxVolume: K8s_Io_Api_Core_V1_PortworxVolumeSource {
    get {return _storage._portworxVolume ?? K8s_Io_Api_Core_V1_PortworxVolumeSource()}
    set {_uniqueStorage()._portworxVolume = newValue}
  }
  /// Returns true if `portworxVolume` has been explicitly set.
  var hasPortworxVolume: Bool {return _storage._portworxVolume != nil}
  /// Clears the value of `portworxVolume`. Subsequent reads from it will return its default value.
  mutating func clearPortworxVolume() {_uniqueStorage()._portworxVolume = nil}

  /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  /// +optional
  var scaleIo: K8s_Io_Api_Core_V1_ScaleIOVolumeSource {
    get {return _storage._scaleIo ?? K8s_Io_Api_Core_V1_ScaleIOVolumeSource()}
    set {_uniqueStorage()._scaleIo = newValue}
  }
  /// Returns true if `scaleIo` has been explicitly set.
  var hasScaleIo: Bool {return _storage._scaleIo != nil}
  /// Clears the value of `scaleIo`. Subsequent reads from it will return its default value.
  mutating func clearScaleIo() {_uniqueStorage()._scaleIo = nil}

  /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  /// +optional
  var storageos: K8s_Io_Api_Core_V1_StorageOSVolumeSource {
    get {return _storage._storageos ?? K8s_Io_Api_Core_V1_StorageOSVolumeSource()}
    set {_uniqueStorage()._storageos = newValue}
  }
  /// Returns true if `storageos` has been explicitly set.
  var hasStorageos: Bool {return _storage._storageos != nil}
  /// Clears the value of `storageos`. Subsequent reads from it will return its default value.
  mutating func clearStorageos() {_uniqueStorage()._storageos = nil}

  /// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
  /// +optional
  var csi: K8s_Io_Api_Core_V1_CSIVolumeSource {
    get {return _storage._csi ?? K8s_Io_Api_Core_V1_CSIVolumeSource()}
    set {_uniqueStorage()._csi = newValue}
  }
  /// Returns true if `csi` has been explicitly set.
  var hasCsi: Bool {return _storage._csi != nil}
  /// Clears the value of `csi`. Subsequent reads from it will return its default value.
  mutating func clearCsi() {_uniqueStorage()._csi = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a vSphere volume resource.
struct K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path that identifies vSphere volume vmdk
  var volumePath: String {
    get {return _volumePath ?? String()}
    set {_volumePath = newValue}
  }
  /// Returns true if `volumePath` has been explicitly set.
  var hasVolumePath: Bool {return self._volumePath != nil}
  /// Clears the value of `volumePath`. Subsequent reads from it will return its default value.
  mutating func clearVolumePath() {self._volumePath = nil}

  /// Filesystem type to mount.
  /// Must be a filesystem type supported by the host operating system.
  /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  /// +optional
  var fsType: String {
    get {return _fsType ?? String()}
    set {_fsType = newValue}
  }
  /// Returns true if `fsType` has been explicitly set.
  var hasFsType: Bool {return self._fsType != nil}
  /// Clears the value of `fsType`. Subsequent reads from it will return its default value.
  mutating func clearFsType() {self._fsType = nil}

  /// Storage Policy Based Management (SPBM) profile name.
  /// +optional
  var storagePolicyName: String {
    get {return _storagePolicyName ?? String()}
    set {_storagePolicyName = newValue}
  }
  /// Returns true if `storagePolicyName` has been explicitly set.
  var hasStoragePolicyName: Bool {return self._storagePolicyName != nil}
  /// Clears the value of `storagePolicyName`. Subsequent reads from it will return its default value.
  mutating func clearStoragePolicyName() {self._storagePolicyName = nil}

  /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  /// +optional
  var storagePolicyID: String {
    get {return _storagePolicyID ?? String()}
    set {_storagePolicyID = newValue}
  }
  /// Returns true if `storagePolicyID` has been explicitly set.
  var hasStoragePolicyID: Bool {return self._storagePolicyID != nil}
  /// Clears the value of `storagePolicyID`. Subsequent reads from it will return its default value.
  mutating func clearStoragePolicyID() {self._storagePolicyID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volumePath: String? = nil
  fileprivate var _fsType: String? = nil
  fileprivate var _storagePolicyName: String? = nil
  fileprivate var _storagePolicyID: String? = nil
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
struct K8s_Io_Api_Core_V1_WeightedPodAffinityTerm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// weight associated with matching the corresponding podAffinityTerm,
  /// in the range 1-100.
  var weight: Int32 {
    get {return _storage._weight ?? 0}
    set {_uniqueStorage()._weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  var hasWeight: Bool {return _storage._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  mutating func clearWeight() {_uniqueStorage()._weight = nil}

  /// Required. A pod affinity term, associated with the corresponding weight.
  var podAffinityTerm: K8s_Io_Api_Core_V1_PodAffinityTerm {
    get {return _storage._podAffinityTerm ?? K8s_Io_Api_Core_V1_PodAffinityTerm()}
    set {_uniqueStorage()._podAffinityTerm = newValue}
  }
  /// Returns true if `podAffinityTerm` has been explicitly set.
  var hasPodAffinityTerm: Bool {return _storage._podAffinityTerm != nil}
  /// Clears the value of `podAffinityTerm`. Subsequent reads from it will return its default value.
  mutating func clearPodAffinityTerm() {_uniqueStorage()._podAffinityTerm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsSecurityContextOptions contain Windows-specific options and credentials.
struct K8s_Io_Api_Core_V1_WindowsSecurityContextOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
  /// This field is alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
  /// +optional
  var gmsaCredentialSpecName: String {
    get {return _gmsaCredentialSpecName ?? String()}
    set {_gmsaCredentialSpecName = newValue}
  }
  /// Returns true if `gmsaCredentialSpecName` has been explicitly set.
  var hasGmsaCredentialSpecName: Bool {return self._gmsaCredentialSpecName != nil}
  /// Clears the value of `gmsaCredentialSpecName`. Subsequent reads from it will return its default value.
  mutating func clearGmsaCredentialSpecName() {self._gmsaCredentialSpecName = nil}

  /// GMSACredentialSpec is where the GMSA admission webhook
  /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
  /// GMSA credential spec named by the GMSACredentialSpecName field.
  /// This field is alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
  /// +optional
  var gmsaCredentialSpec: String {
    get {return _gmsaCredentialSpec ?? String()}
    set {_gmsaCredentialSpec = newValue}
  }
  /// Returns true if `gmsaCredentialSpec` has been explicitly set.
  var hasGmsaCredentialSpec: Bool {return self._gmsaCredentialSpec != nil}
  /// Clears the value of `gmsaCredentialSpec`. Subsequent reads from it will return its default value.
  mutating func clearGmsaCredentialSpec() {self._gmsaCredentialSpec = nil}

  /// The UserName in Windows to run the entrypoint of the container process.
  /// Defaults to the user specified in image metadata if unspecified.
  /// May also be set in PodSecurityContext. If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence.
  /// This field is alpha-level and it is only honored by servers that enable the WindowsRunAsUserName feature flag.
  /// +optional
  var runAsUserName: String {
    get {return _runAsUserName ?? String()}
    set {_runAsUserName = newValue}
  }
  /// Returns true if `runAsUserName` has been explicitly set.
  var hasRunAsUserName: Bool {return self._runAsUserName != nil}
  /// Clears the value of `runAsUserName`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUserName() {self._runAsUserName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gmsaCredentialSpecName: String? = nil
  fileprivate var _gmsaCredentialSpec: String? = nil
  fileprivate var _runAsUserName: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.core.v1"

extension K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSElasticBlockStoreVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeID"),
    2: .same(proto: "fsType"),
    3: .same(proto: "partition"),
    4: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._volumeID)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      case 3: try decoder.decodeSingularInt32Field(value: &self._partition)
      case 4: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._volumeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._partition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource, rhs: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource) -> Bool {
    if lhs._volumeID != rhs._volumeID {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._partition != rhs._partition {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Affinity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Affinity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAffinity"),
    2: .same(proto: "podAffinity"),
    3: .same(proto: "podAntiAffinity"),
  ]

  fileprivate class _StorageClass {
    var _nodeAffinity: K8s_Io_Api_Core_V1_NodeAffinity? = nil
    var _podAffinity: K8s_Io_Api_Core_V1_PodAffinity? = nil
    var _podAntiAffinity: K8s_Io_Api_Core_V1_PodAntiAffinity? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodeAffinity = source._nodeAffinity
      _podAffinity = source._podAffinity
      _podAntiAffinity = source._podAntiAffinity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nodeAffinity)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._podAffinity)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._podAntiAffinity)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nodeAffinity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._podAffinity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._podAntiAffinity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Affinity, rhs: K8s_Io_Api_Core_V1_Affinity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodeAffinity != rhs_storage._nodeAffinity {return false}
        if _storage._podAffinity != rhs_storage._podAffinity {return false}
        if _storage._podAntiAffinity != rhs_storage._podAntiAffinity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_AttachedVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachedVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "devicePath"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._devicePath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._devicePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AttachedVolume, rhs: K8s_Io_Api_Core_V1_AttachedVolume) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._devicePath != rhs._devicePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_AvoidPods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AvoidPods"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preferAvoidPods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.preferAvoidPods)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preferAvoidPods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preferAvoidPods, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AvoidPods, rhs: K8s_Io_Api_Core_V1_AvoidPods) -> Bool {
    if lhs.preferAvoidPods != rhs.preferAvoidPods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_AzureDiskVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureDiskVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diskName"),
    2: .same(proto: "diskURI"),
    3: .same(proto: "cachingMode"),
    4: .same(proto: "fsType"),
    5: .same(proto: "readOnly"),
    6: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._diskName)
      case 2: try decoder.decodeSingularStringField(value: &self._diskUri)
      case 3: try decoder.decodeSingularStringField(value: &self._cachingMode)
      case 4: try decoder.decodeSingularStringField(value: &self._fsType)
      case 5: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 6: try decoder.decodeSingularStringField(value: &self._kind)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._diskName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._diskUri {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._cachingMode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AzureDiskVolumeSource, rhs: K8s_Io_Api_Core_V1_AzureDiskVolumeSource) -> Bool {
    if lhs._diskName != rhs._diskName {return false}
    if lhs._diskUri != rhs._diskUri {return false}
    if lhs._cachingMode != rhs._cachingMode {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureFilePersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secretName"),
    2: .same(proto: "shareName"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "secretNamespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._secretName)
      case 2: try decoder.decodeSingularStringField(value: &self._shareName)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 4: try decoder.decodeSingularStringField(value: &self._secretNamespace)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._secretName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._shareName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._secretNamespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource) -> Bool {
    if lhs._secretName != rhs._secretName {return false}
    if lhs._shareName != rhs._shareName {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs._secretNamespace != rhs._secretNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_AzureFileVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureFileVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secretName"),
    2: .same(proto: "shareName"),
    3: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._secretName)
      case 2: try decoder.decodeSingularStringField(value: &self._shareName)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._secretName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._shareName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_AzureFileVolumeSource, rhs: K8s_Io_Api_Core_V1_AzureFileVolumeSource) -> Bool {
    if lhs._secretName != rhs._secretName {return false}
    if lhs._shareName != rhs._shareName {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Binding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Binding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "target"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _target: K8s_Io_Api_Core_V1_ObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _target = source._target
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._target)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Binding, rhs: K8s_Io_Api_Core_V1_Binding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._target != rhs_storage._target {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CSIPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CSIPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
    2: .same(proto: "volumeHandle"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "fsType"),
    5: .same(proto: "volumeAttributes"),
    6: .same(proto: "controllerPublishSecretRef"),
    7: .same(proto: "nodeStageSecretRef"),
    8: .same(proto: "nodePublishSecretRef"),
    9: .same(proto: "controllerExpandSecretRef"),
  ]

  fileprivate class _StorageClass {
    var _driver: String? = nil
    var _volumeHandle: String? = nil
    var _readOnly: Bool? = nil
    var _fsType: String? = nil
    var _volumeAttributes: Dictionary<String,String> = [:]
    var _controllerPublishSecretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _nodeStageSecretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _nodePublishSecretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _controllerExpandSecretRef: K8s_Io_Api_Core_V1_SecretReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _driver = source._driver
      _volumeHandle = source._volumeHandle
      _readOnly = source._readOnly
      _fsType = source._fsType
      _volumeAttributes = source._volumeAttributes
      _controllerPublishSecretRef = source._controllerPublishSecretRef
      _nodeStageSecretRef = source._nodeStageSecretRef
      _nodePublishSecretRef = source._nodePublishSecretRef
      _controllerExpandSecretRef = source._controllerExpandSecretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._driver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._volumeHandle)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 4: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._volumeAttributes)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._controllerPublishSecretRef)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._nodeStageSecretRef)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._nodePublishSecretRef)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._controllerExpandSecretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._driver {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._volumeHandle {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._volumeAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._volumeAttributes, fieldNumber: 5)
      }
      if let v = _storage._controllerPublishSecretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._nodeStageSecretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._nodePublishSecretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._controllerExpandSecretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CSIPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_CSIPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._driver != rhs_storage._driver {return false}
        if _storage._volumeHandle != rhs_storage._volumeHandle {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._volumeAttributes != rhs_storage._volumeAttributes {return false}
        if _storage._controllerPublishSecretRef != rhs_storage._controllerPublishSecretRef {return false}
        if _storage._nodeStageSecretRef != rhs_storage._nodeStageSecretRef {return false}
        if _storage._nodePublishSecretRef != rhs_storage._nodePublishSecretRef {return false}
        if _storage._controllerExpandSecretRef != rhs_storage._controllerExpandSecretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CSIVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CSIVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
    2: .same(proto: "readOnly"),
    3: .same(proto: "fsType"),
    4: .same(proto: "volumeAttributes"),
    5: .same(proto: "nodePublishSecretRef"),
  ]

  fileprivate class _StorageClass {
    var _driver: String? = nil
    var _readOnly: Bool? = nil
    var _fsType: String? = nil
    var _volumeAttributes: Dictionary<String,String> = [:]
    var _nodePublishSecretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _driver = source._driver
      _readOnly = source._readOnly
      _fsType = source._fsType
      _volumeAttributes = source._volumeAttributes
      _nodePublishSecretRef = source._nodePublishSecretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._driver)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._volumeAttributes)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._nodePublishSecretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._driver {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._volumeAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._volumeAttributes, fieldNumber: 4)
      }
      if let v = _storage._nodePublishSecretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CSIVolumeSource, rhs: K8s_Io_Api_Core_V1_CSIVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._driver != rhs_storage._driver {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._volumeAttributes != rhs_storage._volumeAttributes {return false}
        if _storage._nodePublishSecretRef != rhs_storage._nodePublishSecretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "add"),
    2: .same(proto: "drop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.add)
      case 2: try decoder.decodeRepeatedStringField(value: &self.drop)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.add.isEmpty {
      try visitor.visitRepeatedStringField(value: self.add, fieldNumber: 1)
    }
    if !self.drop.isEmpty {
      try visitor.visitRepeatedStringField(value: self.drop, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Capabilities, rhs: K8s_Io_Api_Core_V1_Capabilities) -> Bool {
    if lhs.add != rhs.add {return false}
    if lhs.drop != rhs.drop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CephFSPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monitors"),
    2: .same(proto: "path"),
    3: .same(proto: "user"),
    4: .same(proto: "secretFile"),
    5: .same(proto: "secretRef"),
    6: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _monitors: [String] = []
    var _path: String? = nil
    var _user: String? = nil
    var _secretFile: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _monitors = source._monitors
      _path = source._path
      _user = source._user
      _secretFile = source._secretFile
      _secretRef = source._secretRef
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._monitors)
        case 2: try decoder.decodeSingularStringField(value: &_storage._path)
        case 3: try decoder.decodeSingularStringField(value: &_storage._user)
        case 4: try decoder.decodeSingularStringField(value: &_storage._secretFile)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._monitors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._monitors, fieldNumber: 1)
      }
      if let v = _storage._path {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._secretFile {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._monitors != rhs_storage._monitors {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._secretFile != rhs_storage._secretFile {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CephFSVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CephFSVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monitors"),
    2: .same(proto: "path"),
    3: .same(proto: "user"),
    4: .same(proto: "secretFile"),
    5: .same(proto: "secretRef"),
    6: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _monitors: [String] = []
    var _path: String? = nil
    var _user: String? = nil
    var _secretFile: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _monitors = source._monitors
      _path = source._path
      _user = source._user
      _secretFile = source._secretFile
      _secretRef = source._secretRef
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._monitors)
        case 2: try decoder.decodeSingularStringField(value: &_storage._path)
        case 3: try decoder.decodeSingularStringField(value: &_storage._user)
        case 4: try decoder.decodeSingularStringField(value: &_storage._secretFile)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._monitors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._monitors, fieldNumber: 1)
      }
      if let v = _storage._path {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._secretFile {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CephFSVolumeSource, rhs: K8s_Io_Api_Core_V1_CephFSVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._monitors != rhs_storage._monitors {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._secretFile != rhs_storage._secretFile {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CinderPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CinderPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeID"),
    2: .same(proto: "fsType"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "secretRef"),
  ]

  fileprivate class _StorageClass {
    var _volumeID: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volumeID = source._volumeID
      _fsType = source._fsType
      _readOnly = source._readOnly
      _secretRef = source._secretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._volumeID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._volumeID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CinderPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_CinderPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volumeID != rhs_storage._volumeID {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_CinderVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CinderVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeID"),
    2: .same(proto: "fsType"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "secretRef"),
  ]

  fileprivate class _StorageClass {
    var _volumeID: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volumeID = source._volumeID
      _fsType = source._fsType
      _readOnly = source._readOnly
      _secretRef = source._secretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._volumeID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._volumeID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_CinderVolumeSource, rhs: K8s_Io_Api_Core_V1_CinderVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volumeID != rhs_storage._volumeID {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ClientIPConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientIPConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeoutSeconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._timeoutSeconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timeoutSeconds {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ClientIPConfig, rhs: K8s_Io_Api_Core_V1_ClientIPConfig) -> Bool {
    if lhs._timeoutSeconds != rhs._timeoutSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ComponentCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "message"),
    4: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._type)
      case 2: try decoder.decodeSingularStringField(value: &self._status)
      case 3: try decoder.decodeSingularStringField(value: &self._message)
      case 4: try decoder.decodeSingularStringField(value: &self._error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ComponentCondition, rhs: K8s_Io_Api_Core_V1_ComponentCondition) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._status != rhs._status {return false}
    if lhs._message != rhs._message {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ComponentStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "conditions"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _conditions: [K8s_Io_Api_Core_V1_ComponentCondition] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _conditions = source._conditions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._conditions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ComponentStatus, rhs: K8s_Io_Api_Core_V1_ComponentStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ComponentStatusList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentStatusList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_ComponentStatus] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ComponentStatusList, rhs: K8s_Io_Api_Core_V1_ComponentStatusList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "data"),
    3: .same(proto: "binaryData"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _data: Dictionary<String,String> = [:]
    var _binaryData: Dictionary<String,Data> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _data = source._data
      _binaryData = source._binaryData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._data)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &_storage._binaryData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._data.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._data, fieldNumber: 2)
      }
      if !_storage._binaryData.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: _storage._binaryData, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMap, rhs: K8s_Io_Api_Core_V1_ConfigMap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._binaryData != rhs_storage._binaryData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapEnvSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapEnvSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapEnvSource, rhs: K8s_Io_Api_Core_V1_ConfigMapEnvSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapKeySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapKeySelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "key"),
    3: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _key: String? = nil
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _key = source._key
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapKeySelector, rhs: K8s_Io_Api_Core_V1_ConfigMapKeySelector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_ConfigMap] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapList, rhs: K8s_Io_Api_Core_V1_ConfigMapList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapNodeConfigSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "name"),
    3: .same(proto: "uid"),
    4: .same(proto: "resourceVersion"),
    5: .same(proto: "kubeletConfigKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._namespace)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      case 3: try decoder.decodeSingularStringField(value: &self._uid)
      case 4: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      case 5: try decoder.decodeSingularStringField(value: &self._kubeletConfigKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._kubeletConfigKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource, rhs: K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource) -> Bool {
    if lhs._namespace != rhs._namespace {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs._kubeletConfigKey != rhs._kubeletConfigKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapProjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "items"),
    4: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _items: [K8s_Io_Api_Core_V1_KeyToPath] = []
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _items = source._items
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapProjection, rhs: K8s_Io_Api_Core_V1_ConfigMapProjection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ConfigMapVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigMapVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "items"),
    3: .same(proto: "defaultMode"),
    4: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _items: [K8s_Io_Api_Core_V1_KeyToPath] = []
    var _defaultMode: Int32? = nil
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _items = source._items
      _defaultMode = source._defaultMode
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._defaultMode)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
      if let v = _storage._defaultMode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ConfigMapVolumeSource, rhs: K8s_Io_Api_Core_V1_ConfigMapVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._defaultMode != rhs_storage._defaultMode {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Container"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "image"),
    3: .same(proto: "command"),
    4: .same(proto: "args"),
    5: .same(proto: "workingDir"),
    6: .same(proto: "ports"),
    19: .same(proto: "envFrom"),
    7: .same(proto: "env"),
    8: .same(proto: "resources"),
    9: .same(proto: "volumeMounts"),
    21: .same(proto: "volumeDevices"),
    10: .same(proto: "livenessProbe"),
    11: .same(proto: "readinessProbe"),
    22: .same(proto: "startupProbe"),
    12: .same(proto: "lifecycle"),
    13: .same(proto: "terminationMessagePath"),
    20: .same(proto: "terminationMessagePolicy"),
    14: .same(proto: "imagePullPolicy"),
    15: .same(proto: "securityContext"),
    16: .same(proto: "stdin"),
    17: .same(proto: "stdinOnce"),
    18: .same(proto: "tty"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _image: String? = nil
    var _command: [String] = []
    var _args: [String] = []
    var _workingDir: String? = nil
    var _ports: [K8s_Io_Api_Core_V1_ContainerPort] = []
    var _envFrom: [K8s_Io_Api_Core_V1_EnvFromSource] = []
    var _env: [K8s_Io_Api_Core_V1_EnvVar] = []
    var _resources: K8s_Io_Api_Core_V1_ResourceRequirements? = nil
    var _volumeMounts: [K8s_Io_Api_Core_V1_VolumeMount] = []
    var _volumeDevices: [K8s_Io_Api_Core_V1_VolumeDevice] = []
    var _livenessProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _readinessProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _startupProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _lifecycle: K8s_Io_Api_Core_V1_Lifecycle? = nil
    var _terminationMessagePath: String? = nil
    var _terminationMessagePolicy: String? = nil
    var _imagePullPolicy: String? = nil
    var _securityContext: K8s_Io_Api_Core_V1_SecurityContext? = nil
    var _stdin: Bool? = nil
    var _stdinOnce: Bool? = nil
    var _tty: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _image = source._image
      _command = source._command
      _args = source._args
      _workingDir = source._workingDir
      _ports = source._ports
      _envFrom = source._envFrom
      _env = source._env
      _resources = source._resources
      _volumeMounts = source._volumeMounts
      _volumeDevices = source._volumeDevices
      _livenessProbe = source._livenessProbe
      _readinessProbe = source._readinessProbe
      _startupProbe = source._startupProbe
      _lifecycle = source._lifecycle
      _terminationMessagePath = source._terminationMessagePath
      _terminationMessagePolicy = source._terminationMessagePolicy
      _imagePullPolicy = source._imagePullPolicy
      _securityContext = source._securityContext
      _stdin = source._stdin
      _stdinOnce = source._stdinOnce
      _tty = source._tty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._image)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._command)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._args)
        case 5: try decoder.decodeSingularStringField(value: &_storage._workingDir)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._ports)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._env)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._resources)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._volumeMounts)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._livenessProbe)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._readinessProbe)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._lifecycle)
        case 13: try decoder.decodeSingularStringField(value: &_storage._terminationMessagePath)
        case 14: try decoder.decodeSingularStringField(value: &_storage._imagePullPolicy)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._securityContext)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._stdin)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._stdinOnce)
        case 18: try decoder.decodeSingularBoolField(value: &_storage._tty)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._envFrom)
        case 20: try decoder.decodeSingularStringField(value: &_storage._terminationMessagePolicy)
        case 21: try decoder.decodeRepeatedMessageField(value: &_storage._volumeDevices)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._startupProbe)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if !_storage._command.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._command, fieldNumber: 3)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 4)
      }
      if let v = _storage._workingDir {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 6)
      }
      if !_storage._env.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._env, fieldNumber: 7)
      }
      if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._volumeMounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumeMounts, fieldNumber: 9)
      }
      if let v = _storage._livenessProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._readinessProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._lifecycle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._terminationMessagePath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }
      if let v = _storage._imagePullPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._securityContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._stdin {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._stdinOnce {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._tty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }
      if !_storage._envFrom.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._envFrom, fieldNumber: 19)
      }
      if let v = _storage._terminationMessagePolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      }
      if !_storage._volumeDevices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumeDevices, fieldNumber: 21)
      }
      if let v = _storage._startupProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Container, rhs: K8s_Io_Api_Core_V1_Container) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._workingDir != rhs_storage._workingDir {return false}
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._envFrom != rhs_storage._envFrom {return false}
        if _storage._env != rhs_storage._env {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._volumeMounts != rhs_storage._volumeMounts {return false}
        if _storage._volumeDevices != rhs_storage._volumeDevices {return false}
        if _storage._livenessProbe != rhs_storage._livenessProbe {return false}
        if _storage._readinessProbe != rhs_storage._readinessProbe {return false}
        if _storage._startupProbe != rhs_storage._startupProbe {return false}
        if _storage._lifecycle != rhs_storage._lifecycle {return false}
        if _storage._terminationMessagePath != rhs_storage._terminationMessagePath {return false}
        if _storage._terminationMessagePolicy != rhs_storage._terminationMessagePolicy {return false}
        if _storage._imagePullPolicy != rhs_storage._imagePullPolicy {return false}
        if _storage._securityContext != rhs_storage._securityContext {return false}
        if _storage._stdin != rhs_storage._stdin {return false}
        if _storage._stdinOnce != rhs_storage._stdinOnce {return false}
        if _storage._tty != rhs_storage._tty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .same(proto: "sizeBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.names)
      case 2: try decoder.decodeSingularInt64Field(value: &self._sizeBytes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    if let v = self._sizeBytes {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerImage, rhs: K8s_Io_Api_Core_V1_ContainerImage) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs._sizeBytes != rhs._sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerPort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "hostPort"),
    3: .same(proto: "containerPort"),
    4: .same(proto: "protocol"),
    5: .same(proto: "hostIP"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularInt32Field(value: &self._hostPort)
      case 3: try decoder.decodeSingularInt32Field(value: &self._containerPort)
      case 4: try decoder.decodeSingularStringField(value: &self._protocol)
      case 5: try decoder.decodeSingularStringField(value: &self._hostIp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._hostPort {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._containerPort {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._protocol {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._hostIp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerPort, rhs: K8s_Io_Api_Core_V1_ContainerPort) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._hostPort != rhs._hostPort {return false}
    if lhs._containerPort != rhs._containerPort {return false}
    if lhs._protocol != rhs._protocol {return false}
    if lhs._hostIp != rhs._hostIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "waiting"),
    2: .same(proto: "running"),
    3: .same(proto: "terminated"),
  ]

  fileprivate class _StorageClass {
    var _waiting: K8s_Io_Api_Core_V1_ContainerStateWaiting? = nil
    var _running: K8s_Io_Api_Core_V1_ContainerStateRunning? = nil
    var _terminated: K8s_Io_Api_Core_V1_ContainerStateTerminated? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _waiting = source._waiting
      _running = source._running
      _terminated = source._terminated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._waiting)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._running)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._terminated)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._waiting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._running {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._terminated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerState, rhs: K8s_Io_Api_Core_V1_ContainerState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._waiting != rhs_storage._waiting {return false}
        if _storage._running != rhs_storage._running {return false}
        if _storage._terminated != rhs_storage._terminated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerStateRunning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStateRunning"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startedAt"),
  ]

  fileprivate class _StorageClass {
    var _startedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startedAt = source._startedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._startedAt)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._startedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerStateRunning, rhs: K8s_Io_Api_Core_V1_ContainerStateRunning) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startedAt != rhs_storage._startedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerStateTerminated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStateTerminated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exitCode"),
    2: .same(proto: "signal"),
    3: .same(proto: "reason"),
    4: .same(proto: "message"),
    5: .same(proto: "startedAt"),
    6: .same(proto: "finishedAt"),
    7: .same(proto: "containerID"),
  ]

  fileprivate class _StorageClass {
    var _exitCode: Int32? = nil
    var _signal: Int32? = nil
    var _reason: String? = nil
    var _message: String? = nil
    var _startedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _finishedAt: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _containerID: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _exitCode = source._exitCode
      _signal = source._signal
      _reason = source._reason
      _message = source._message
      _startedAt = source._startedAt
      _finishedAt = source._finishedAt
      _containerID = source._containerID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._signal)
        case 3: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._startedAt)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._finishedAt)
        case 7: try decoder.decodeSingularStringField(value: &_storage._containerID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._exitCode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._signal {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._startedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._finishedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._containerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerStateTerminated, rhs: K8s_Io_Api_Core_V1_ContainerStateTerminated) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._signal != rhs_storage._signal {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._startedAt != rhs_storage._startedAt {return false}
        if _storage._finishedAt != rhs_storage._finishedAt {return false}
        if _storage._containerID != rhs_storage._containerID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerStateWaiting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStateWaiting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._reason)
      case 2: try decoder.decodeSingularStringField(value: &self._message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerStateWaiting, rhs: K8s_Io_Api_Core_V1_ContainerStateWaiting) -> Bool {
    if lhs._reason != rhs._reason {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ContainerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "state"),
    3: .same(proto: "lastState"),
    4: .same(proto: "ready"),
    5: .same(proto: "restartCount"),
    6: .same(proto: "image"),
    7: .same(proto: "imageID"),
    8: .same(proto: "containerID"),
    9: .same(proto: "started"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _state: K8s_Io_Api_Core_V1_ContainerState? = nil
    var _lastState: K8s_Io_Api_Core_V1_ContainerState? = nil
    var _ready: Bool? = nil
    var _restartCount: Int32? = nil
    var _image: String? = nil
    var _imageID: String? = nil
    var _containerID: String? = nil
    var _started: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _state = source._state
      _lastState = source._lastState
      _ready = source._ready
      _restartCount = source._restartCount
      _image = source._image
      _imageID = source._imageID
      _containerID = source._containerID
      _started = source._started
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastState)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._ready)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._restartCount)
        case 6: try decoder.decodeSingularStringField(value: &_storage._image)
        case 7: try decoder.decodeSingularStringField(value: &_storage._imageID)
        case 8: try decoder.decodeSingularStringField(value: &_storage._containerID)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._started)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._ready {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._restartCount {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._imageID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._containerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._started {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ContainerStatus, rhs: K8s_Io_Api_Core_V1_ContainerStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._lastState != rhs_storage._lastState {return false}
        if _storage._ready != rhs_storage._ready {return false}
        if _storage._restartCount != rhs_storage._restartCount {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._imageID != rhs_storage._imageID {return false}
        if _storage._containerID != rhs_storage._containerID {return false}
        if _storage._started != rhs_storage._started {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_DaemonEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonEndpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._port)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._port {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_DaemonEndpoint, rhs: K8s_Io_Api_Core_V1_DaemonEndpoint) -> Bool {
    if lhs._port != rhs._port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_DownwardAPIProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownwardAPIProjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_DownwardAPIProjection, rhs: K8s_Io_Api_Core_V1_DownwardAPIProjection) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_DownwardAPIVolumeFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownwardAPIVolumeFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "fieldRef"),
    3: .same(proto: "resourceFieldRef"),
    4: .same(proto: "mode"),
  ]

  fileprivate class _StorageClass {
    var _path: String? = nil
    var _fieldRef: K8s_Io_Api_Core_V1_ObjectFieldSelector? = nil
    var _resourceFieldRef: K8s_Io_Api_Core_V1_ResourceFieldSelector? = nil
    var _mode: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _fieldRef = source._fieldRef
      _resourceFieldRef = source._resourceFieldRef
      _mode = source._mode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fieldRef)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._resourceFieldRef)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._mode)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._path {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fieldRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._resourceFieldRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._mode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_DownwardAPIVolumeFile, rhs: K8s_Io_Api_Core_V1_DownwardAPIVolumeFile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._fieldRef != rhs_storage._fieldRef {return false}
        if _storage._resourceFieldRef != rhs_storage._resourceFieldRef {return false}
        if _storage._mode != rhs_storage._mode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_DownwardAPIVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownwardAPIVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .same(proto: "defaultMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      case 2: try decoder.decodeSingularInt32Field(value: &self._defaultMode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if let v = self._defaultMode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_DownwardAPIVolumeSource, rhs: K8s_Io_Api_Core_V1_DownwardAPIVolumeSource) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._defaultMode != rhs._defaultMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EmptyDirVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyDirVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medium"),
    2: .same(proto: "sizeLimit"),
  ]

  fileprivate class _StorageClass {
    var _medium: String? = nil
    var _sizeLimit: K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _medium = source._medium
      _sizeLimit = source._sizeLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._medium)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sizeLimit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._medium {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sizeLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EmptyDirVolumeSource, rhs: K8s_Io_Api_Core_V1_EmptyDirVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._medium != rhs_storage._medium {return false}
        if _storage._sizeLimit != rhs_storage._sizeLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EndpointAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EndpointAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    3: .same(proto: "hostname"),
    4: .same(proto: "nodeName"),
    2: .same(proto: "targetRef"),
  ]

  fileprivate class _StorageClass {
    var _ip: String? = nil
    var _hostname: String? = nil
    var _nodeName: String? = nil
    var _targetRef: K8s_Io_Api_Core_V1_ObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ip = source._ip
      _hostname = source._hostname
      _nodeName = source._nodeName
      _targetRef = source._targetRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._ip)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._targetRef)
        case 3: try decoder.decodeSingularStringField(value: &_storage._hostname)
        case 4: try decoder.decodeSingularStringField(value: &_storage._nodeName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ip {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._targetRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._hostname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._nodeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EndpointAddress, rhs: K8s_Io_Api_Core_V1_EndpointAddress) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._nodeName != rhs_storage._nodeName {return false}
        if _storage._targetRef != rhs_storage._targetRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EndpointPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EndpointPort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "port"),
    3: .same(proto: "protocol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularInt32Field(value: &self._port)
      case 3: try decoder.decodeSingularStringField(value: &self._protocol)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._port {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._protocol {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EndpointPort, rhs: K8s_Io_Api_Core_V1_EndpointPort) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._port != rhs._port {return false}
    if lhs._protocol != rhs._protocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EndpointSubset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EndpointSubset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "notReadyAddresses"),
    3: .same(proto: "ports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.addresses)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.notReadyAddresses)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.ports)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
    }
    if !self.notReadyAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notReadyAddresses, fieldNumber: 2)
    }
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EndpointSubset, rhs: K8s_Io_Api_Core_V1_EndpointSubset) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.notReadyAddresses != rhs.notReadyAddresses {return false}
    if lhs.ports != rhs.ports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Endpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Endpoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "subsets"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _subsets: [K8s_Io_Api_Core_V1_EndpointSubset] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _subsets = source._subsets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._subsets)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._subsets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subsets, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Endpoints, rhs: K8s_Io_Api_Core_V1_Endpoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._subsets != rhs_storage._subsets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EndpointsList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EndpointsList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Endpoints] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EndpointsList, rhs: K8s_Io_Api_Core_V1_EndpointsList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EnvFromSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvFromSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "configMapRef"),
    3: .same(proto: "secretRef"),
  ]

  fileprivate class _StorageClass {
    var _prefix: String? = nil
    var _configMapRef: K8s_Io_Api_Core_V1_ConfigMapEnvSource? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretEnvSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _prefix = source._prefix
      _configMapRef = source._configMapRef
      _secretRef = source._secretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._prefix)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configMapRef)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._prefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._configMapRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EnvFromSource, rhs: K8s_Io_Api_Core_V1_EnvFromSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._prefix != rhs_storage._prefix {return false}
        if _storage._configMapRef != rhs_storage._configMapRef {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EnvVar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvVar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "valueFrom"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _value: String? = nil
    var _valueFrom: K8s_Io_Api_Core_V1_EnvVarSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
      _valueFrom = source._valueFrom
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._value)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._valueFrom)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._valueFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EnvVar, rhs: K8s_Io_Api_Core_V1_EnvVar) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._valueFrom != rhs_storage._valueFrom {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EnvVarSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvVarSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fieldRef"),
    2: .same(proto: "resourceFieldRef"),
    3: .same(proto: "configMapKeyRef"),
    4: .same(proto: "secretKeyRef"),
  ]

  fileprivate class _StorageClass {
    var _fieldRef: K8s_Io_Api_Core_V1_ObjectFieldSelector? = nil
    var _resourceFieldRef: K8s_Io_Api_Core_V1_ResourceFieldSelector? = nil
    var _configMapKeyRef: K8s_Io_Api_Core_V1_ConfigMapKeySelector? = nil
    var _secretKeyRef: K8s_Io_Api_Core_V1_SecretKeySelector? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fieldRef = source._fieldRef
      _resourceFieldRef = source._resourceFieldRef
      _configMapKeyRef = source._configMapKeyRef
      _secretKeyRef = source._secretKeyRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._fieldRef)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._resourceFieldRef)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configMapKeyRef)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._secretKeyRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fieldRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._resourceFieldRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._configMapKeyRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._secretKeyRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EnvVarSource, rhs: K8s_Io_Api_Core_V1_EnvVarSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fieldRef != rhs_storage._fieldRef {return false}
        if _storage._resourceFieldRef != rhs_storage._resourceFieldRef {return false}
        if _storage._configMapKeyRef != rhs_storage._configMapKeyRef {return false}
        if _storage._secretKeyRef != rhs_storage._secretKeyRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EphemeralContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EphemeralContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ephemeralContainerCommon"),
    2: .same(proto: "targetContainerName"),
  ]

  fileprivate class _StorageClass {
    var _ephemeralContainerCommon: K8s_Io_Api_Core_V1_EphemeralContainerCommon? = nil
    var _targetContainerName: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ephemeralContainerCommon = source._ephemeralContainerCommon
      _targetContainerName = source._targetContainerName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ephemeralContainerCommon)
        case 2: try decoder.decodeSingularStringField(value: &_storage._targetContainerName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ephemeralContainerCommon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._targetContainerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EphemeralContainer, rhs: K8s_Io_Api_Core_V1_EphemeralContainer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ephemeralContainerCommon != rhs_storage._ephemeralContainerCommon {return false}
        if _storage._targetContainerName != rhs_storage._targetContainerName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EphemeralContainerCommon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EphemeralContainerCommon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "image"),
    3: .same(proto: "command"),
    4: .same(proto: "args"),
    5: .same(proto: "workingDir"),
    6: .same(proto: "ports"),
    19: .same(proto: "envFrom"),
    7: .same(proto: "env"),
    8: .same(proto: "resources"),
    9: .same(proto: "volumeMounts"),
    21: .same(proto: "volumeDevices"),
    10: .same(proto: "livenessProbe"),
    11: .same(proto: "readinessProbe"),
    22: .same(proto: "startupProbe"),
    12: .same(proto: "lifecycle"),
    13: .same(proto: "terminationMessagePath"),
    20: .same(proto: "terminationMessagePolicy"),
    14: .same(proto: "imagePullPolicy"),
    15: .same(proto: "securityContext"),
    16: .same(proto: "stdin"),
    17: .same(proto: "stdinOnce"),
    18: .same(proto: "tty"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _image: String? = nil
    var _command: [String] = []
    var _args: [String] = []
    var _workingDir: String? = nil
    var _ports: [K8s_Io_Api_Core_V1_ContainerPort] = []
    var _envFrom: [K8s_Io_Api_Core_V1_EnvFromSource] = []
    var _env: [K8s_Io_Api_Core_V1_EnvVar] = []
    var _resources: K8s_Io_Api_Core_V1_ResourceRequirements? = nil
    var _volumeMounts: [K8s_Io_Api_Core_V1_VolumeMount] = []
    var _volumeDevices: [K8s_Io_Api_Core_V1_VolumeDevice] = []
    var _livenessProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _readinessProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _startupProbe: K8s_Io_Api_Core_V1_Probe? = nil
    var _lifecycle: K8s_Io_Api_Core_V1_Lifecycle? = nil
    var _terminationMessagePath: String? = nil
    var _terminationMessagePolicy: String? = nil
    var _imagePullPolicy: String? = nil
    var _securityContext: K8s_Io_Api_Core_V1_SecurityContext? = nil
    var _stdin: Bool? = nil
    var _stdinOnce: Bool? = nil
    var _tty: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _image = source._image
      _command = source._command
      _args = source._args
      _workingDir = source._workingDir
      _ports = source._ports
      _envFrom = source._envFrom
      _env = source._env
      _resources = source._resources
      _volumeMounts = source._volumeMounts
      _volumeDevices = source._volumeDevices
      _livenessProbe = source._livenessProbe
      _readinessProbe = source._readinessProbe
      _startupProbe = source._startupProbe
      _lifecycle = source._lifecycle
      _terminationMessagePath = source._terminationMessagePath
      _terminationMessagePolicy = source._terminationMessagePolicy
      _imagePullPolicy = source._imagePullPolicy
      _securityContext = source._securityContext
      _stdin = source._stdin
      _stdinOnce = source._stdinOnce
      _tty = source._tty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._image)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._command)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._args)
        case 5: try decoder.decodeSingularStringField(value: &_storage._workingDir)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._ports)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._env)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._resources)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._volumeMounts)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._livenessProbe)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._readinessProbe)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._lifecycle)
        case 13: try decoder.decodeSingularStringField(value: &_storage._terminationMessagePath)
        case 14: try decoder.decodeSingularStringField(value: &_storage._imagePullPolicy)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._securityContext)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._stdin)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._stdinOnce)
        case 18: try decoder.decodeSingularBoolField(value: &_storage._tty)
        case 19: try decoder.decodeRepeatedMessageField(value: &_storage._envFrom)
        case 20: try decoder.decodeSingularStringField(value: &_storage._terminationMessagePolicy)
        case 21: try decoder.decodeRepeatedMessageField(value: &_storage._volumeDevices)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._startupProbe)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if !_storage._command.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._command, fieldNumber: 3)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 4)
      }
      if let v = _storage._workingDir {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 6)
      }
      if !_storage._env.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._env, fieldNumber: 7)
      }
      if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._volumeMounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumeMounts, fieldNumber: 9)
      }
      if let v = _storage._livenessProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._readinessProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._lifecycle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._terminationMessagePath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }
      if let v = _storage._imagePullPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._securityContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._stdin {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._stdinOnce {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._tty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }
      if !_storage._envFrom.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._envFrom, fieldNumber: 19)
      }
      if let v = _storage._terminationMessagePolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      }
      if !_storage._volumeDevices.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumeDevices, fieldNumber: 21)
      }
      if let v = _storage._startupProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EphemeralContainerCommon, rhs: K8s_Io_Api_Core_V1_EphemeralContainerCommon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._workingDir != rhs_storage._workingDir {return false}
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._envFrom != rhs_storage._envFrom {return false}
        if _storage._env != rhs_storage._env {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._volumeMounts != rhs_storage._volumeMounts {return false}
        if _storage._volumeDevices != rhs_storage._volumeDevices {return false}
        if _storage._livenessProbe != rhs_storage._livenessProbe {return false}
        if _storage._readinessProbe != rhs_storage._readinessProbe {return false}
        if _storage._startupProbe != rhs_storage._startupProbe {return false}
        if _storage._lifecycle != rhs_storage._lifecycle {return false}
        if _storage._terminationMessagePath != rhs_storage._terminationMessagePath {return false}
        if _storage._terminationMessagePolicy != rhs_storage._terminationMessagePolicy {return false}
        if _storage._imagePullPolicy != rhs_storage._imagePullPolicy {return false}
        if _storage._securityContext != rhs_storage._securityContext {return false}
        if _storage._stdin != rhs_storage._stdin {return false}
        if _storage._stdinOnce != rhs_storage._stdinOnce {return false}
        if _storage._tty != rhs_storage._tty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EphemeralContainers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EphemeralContainers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "ephemeralContainers"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _ephemeralContainers: [K8s_Io_Api_Core_V1_EphemeralContainer] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _ephemeralContainers = source._ephemeralContainers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._ephemeralContainers)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ephemeralContainers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ephemeralContainers, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EphemeralContainers, rhs: K8s_Io_Api_Core_V1_EphemeralContainers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._ephemeralContainers != rhs_storage._ephemeralContainers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "involvedObject"),
    3: .same(proto: "reason"),
    4: .same(proto: "message"),
    5: .same(proto: "source"),
    6: .same(proto: "firstTimestamp"),
    7: .same(proto: "lastTimestamp"),
    8: .same(proto: "count"),
    9: .same(proto: "type"),
    10: .same(proto: "eventTime"),
    11: .same(proto: "series"),
    12: .same(proto: "action"),
    13: .same(proto: "related"),
    14: .same(proto: "reportingComponent"),
    15: .same(proto: "reportingInstance"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _involvedObject: K8s_Io_Api_Core_V1_ObjectReference? = nil
    var _reason: String? = nil
    var _message: String? = nil
    var _source: K8s_Io_Api_Core_V1_EventSource? = nil
    var _firstTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTimestamp: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _count: Int32? = nil
    var _type: String? = nil
    var _eventTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime? = nil
    var _series: K8s_Io_Api_Core_V1_EventSeries? = nil
    var _action: String? = nil
    var _related: K8s_Io_Api_Core_V1_ObjectReference? = nil
    var _reportingComponent: String? = nil
    var _reportingInstance: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _involvedObject = source._involvedObject
      _reason = source._reason
      _message = source._message
      _source = source._source
      _firstTimestamp = source._firstTimestamp
      _lastTimestamp = source._lastTimestamp
      _count = source._count
      _type = source._type
      _eventTime = source._eventTime
      _series = source._series
      _action = source._action
      _related = source._related
      _reportingComponent = source._reportingComponent
      _reportingInstance = source._reportingInstance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._involvedObject)
        case 3: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._source)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._firstTimestamp)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._lastTimestamp)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._count)
        case 9: try decoder.decodeSingularStringField(value: &_storage._type)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._eventTime)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._series)
        case 12: try decoder.decodeSingularStringField(value: &_storage._action)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._related)
        case 14: try decoder.decodeSingularStringField(value: &_storage._reportingComponent)
        case 15: try decoder.decodeSingularStringField(value: &_storage._reportingInstance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._involvedObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._firstTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._lastTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._count {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._eventTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._series {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._action {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._related {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._reportingComponent {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._reportingInstance {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Event, rhs: K8s_Io_Api_Core_V1_Event) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._involvedObject != rhs_storage._involvedObject {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._firstTimestamp != rhs_storage._firstTimestamp {return false}
        if _storage._lastTimestamp != rhs_storage._lastTimestamp {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._eventTime != rhs_storage._eventTime {return false}
        if _storage._series != rhs_storage._series {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._related != rhs_storage._related {return false}
        if _storage._reportingComponent != rhs_storage._reportingComponent {return false}
        if _storage._reportingInstance != rhs_storage._reportingInstance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EventList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Event] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EventList, rhs: K8s_Io_Api_Core_V1_EventList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EventSeries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSeries"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "lastObservedTime"),
    3: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _count: Int32? = nil
    var _lastObservedTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_MicroTime? = nil
    var _state: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _count = source._count
      _lastObservedTime = source._lastObservedTime
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._count)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._lastObservedTime)
        case 3: try decoder.decodeSingularStringField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._count {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._lastObservedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._state {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EventSeries, rhs: K8s_Io_Api_Core_V1_EventSeries) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._count != rhs_storage._count {return false}
        if _storage._lastObservedTime != rhs_storage._lastObservedTime {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_EventSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "component"),
    2: .same(proto: "host"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._component)
      case 2: try decoder.decodeSingularStringField(value: &self._host)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._component {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._host {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_EventSource, rhs: K8s_Io_Api_Core_V1_EventSource) -> Bool {
    if lhs._component != rhs._component {return false}
    if lhs._host != rhs._host {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ExecAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.command)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ExecAction, rhs: K8s_Io_Api_Core_V1_ExecAction) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_FCVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FCVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetWWNs"),
    2: .same(proto: "lun"),
    3: .same(proto: "fsType"),
    4: .same(proto: "readOnly"),
    5: .same(proto: "wwids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.targetWwns)
      case 2: try decoder.decodeSingularInt32Field(value: &self._lun)
      case 3: try decoder.decodeSingularStringField(value: &self._fsType)
      case 4: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 5: try decoder.decodeRepeatedStringField(value: &self.wwids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetWwns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetWwns, fieldNumber: 1)
    }
    if let v = self._lun {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.wwids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.wwids, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_FCVolumeSource, rhs: K8s_Io_Api_Core_V1_FCVolumeSource) -> Bool {
    if lhs.targetWwns != rhs.targetWwns {return false}
    if lhs._lun != rhs._lun {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.wwids != rhs.wwids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_FlexPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlexPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
    2: .same(proto: "fsType"),
    3: .same(proto: "secretRef"),
    4: .same(proto: "readOnly"),
    5: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _driver: String? = nil
    var _fsType: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _readOnly: Bool? = nil
    var _options: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _driver = source._driver
      _fsType = source._fsType
      _secretRef = source._secretRef
      _readOnly = source._readOnly
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._driver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._options)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._driver {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if !_storage._options.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._options, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_FlexPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_FlexPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._driver != rhs_storage._driver {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_FlexVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlexVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
    2: .same(proto: "fsType"),
    3: .same(proto: "secretRef"),
    4: .same(proto: "readOnly"),
    5: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _driver: String? = nil
    var _fsType: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _readOnly: Bool? = nil
    var _options: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _driver = source._driver
      _fsType = source._fsType
      _secretRef = source._secretRef
      _readOnly = source._readOnly
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._driver)
        case 2: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._options)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._driver {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if !_storage._options.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._options, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_FlexVolumeSource, rhs: K8s_Io_Api_Core_V1_FlexVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._driver != rhs_storage._driver {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_FlockerVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlockerVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datasetName"),
    2: .same(proto: "datasetUUID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._datasetName)
      case 2: try decoder.decodeSingularStringField(value: &self._datasetUuid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._datasetName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._datasetUuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_FlockerVolumeSource, rhs: K8s_Io_Api_Core_V1_FlockerVolumeSource) -> Bool {
    if lhs._datasetName != rhs._datasetName {return false}
    if lhs._datasetUuid != rhs._datasetUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GCEPersistentDiskVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pdName"),
    2: .same(proto: "fsType"),
    3: .same(proto: "partition"),
    4: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pdName)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      case 3: try decoder.decodeSingularInt32Field(value: &self._partition)
      case 4: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pdName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._partition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource, rhs: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource) -> Bool {
    if lhs._pdName != rhs._pdName {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._partition != rhs._partition {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_GitRepoVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GitRepoVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repository"),
    2: .same(proto: "revision"),
    3: .same(proto: "directory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._repository)
      case 2: try decoder.decodeSingularStringField(value: &self._revision)
      case 3: try decoder.decodeSingularStringField(value: &self._directory)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._repository {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._revision {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._directory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_GitRepoVolumeSource, rhs: K8s_Io_Api_Core_V1_GitRepoVolumeSource) -> Bool {
    if lhs._repository != rhs._repository {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs._directory != rhs._directory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlusterfsPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoints"),
    2: .same(proto: "path"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "endpointsNamespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._endpoints)
      case 2: try decoder.decodeSingularStringField(value: &self._path)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 4: try decoder.decodeSingularStringField(value: &self._endpointsNamespace)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endpoints {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._endpointsNamespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource) -> Bool {
    if lhs._endpoints != rhs._endpoints {return false}
    if lhs._path != rhs._path {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs._endpointsNamespace != rhs._endpointsNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_GlusterfsVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GlusterfsVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoints"),
    2: .same(proto: "path"),
    3: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._endpoints)
      case 2: try decoder.decodeSingularStringField(value: &self._path)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endpoints {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_GlusterfsVolumeSource, rhs: K8s_Io_Api_Core_V1_GlusterfsVolumeSource) -> Bool {
    if lhs._endpoints != rhs._endpoints {return false}
    if lhs._path != rhs._path {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_HTTPGetAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTTPGetAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "port"),
    3: .same(proto: "host"),
    4: .same(proto: "scheme"),
    5: .same(proto: "httpHeaders"),
  ]

  fileprivate class _StorageClass {
    var _path: String? = nil
    var _port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _host: String? = nil
    var _scheme: String? = nil
    var _httpHeaders: [K8s_Io_Api_Core_V1_HTTPHeader] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _port = source._port
      _host = source._host
      _scheme = source._scheme
      _httpHeaders = source._httpHeaders
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._port)
        case 3: try decoder.decodeSingularStringField(value: &_storage._host)
        case 4: try decoder.decodeSingularStringField(value: &_storage._scheme)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._httpHeaders)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._path {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._port {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._host {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._scheme {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._httpHeaders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._httpHeaders, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_HTTPGetAction, rhs: K8s_Io_Api_Core_V1_HTTPGetAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._scheme != rhs_storage._scheme {return false}
        if _storage._httpHeaders != rhs_storage._httpHeaders {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_HTTPHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HTTPHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_HTTPHeader, rhs: K8s_Io_Api_Core_V1_HTTPHeader) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Handler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Handler"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exec"),
    2: .same(proto: "httpGet"),
    3: .same(proto: "tcpSocket"),
  ]

  fileprivate class _StorageClass {
    var _exec: K8s_Io_Api_Core_V1_ExecAction? = nil
    var _httpGet: K8s_Io_Api_Core_V1_HTTPGetAction? = nil
    var _tcpSocket: K8s_Io_Api_Core_V1_TCPSocketAction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _exec = source._exec
      _httpGet = source._httpGet
      _tcpSocket = source._tcpSocket
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._exec)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._httpGet)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._tcpSocket)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._exec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._httpGet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._tcpSocket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Handler, rhs: K8s_Io_Api_Core_V1_Handler) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._exec != rhs_storage._exec {return false}
        if _storage._httpGet != rhs_storage._httpGet {return false}
        if _storage._tcpSocket != rhs_storage._tcpSocket {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_HostAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostAlias"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "hostnames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._ip)
      case 2: try decoder.decodeRepeatedStringField(value: &self.hostnames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.hostnames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hostnames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_HostAlias, rhs: K8s_Io_Api_Core_V1_HostAlias) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs.hostnames != rhs.hostnames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_HostPathVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostPathVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._path)
      case 2: try decoder.decodeSingularStringField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_HostPathVolumeSource, rhs: K8s_Io_Api_Core_V1_HostPathVolumeSource) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ISCSIPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetPortal"),
    2: .same(proto: "iqn"),
    3: .same(proto: "lun"),
    4: .same(proto: "iscsiInterface"),
    5: .same(proto: "fsType"),
    6: .same(proto: "readOnly"),
    7: .same(proto: "portals"),
    8: .same(proto: "chapAuthDiscovery"),
    11: .same(proto: "chapAuthSession"),
    10: .same(proto: "secretRef"),
    12: .same(proto: "initiatorName"),
  ]

  fileprivate class _StorageClass {
    var _targetPortal: String? = nil
    var _iqn: String? = nil
    var _lun: Int32? = nil
    var _iscsiInterface: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _portals: [String] = []
    var _chapAuthDiscovery: Bool? = nil
    var _chapAuthSession: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _initiatorName: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetPortal = source._targetPortal
      _iqn = source._iqn
      _lun = source._lun
      _iscsiInterface = source._iscsiInterface
      _fsType = source._fsType
      _readOnly = source._readOnly
      _portals = source._portals
      _chapAuthDiscovery = source._chapAuthDiscovery
      _chapAuthSession = source._chapAuthSession
      _secretRef = source._secretRef
      _initiatorName = source._initiatorName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._targetPortal)
        case 2: try decoder.decodeSingularStringField(value: &_storage._iqn)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._lun)
        case 4: try decoder.decodeSingularStringField(value: &_storage._iscsiInterface)
        case 5: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._portals)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._chapAuthDiscovery)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._chapAuthSession)
        case 12: try decoder.decodeSingularStringField(value: &_storage._initiatorName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetPortal {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._iqn {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lun {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._iscsiInterface {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if !_storage._portals.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._portals, fieldNumber: 7)
      }
      if let v = _storage._chapAuthDiscovery {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._chapAuthSession {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if let v = _storage._initiatorName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetPortal != rhs_storage._targetPortal {return false}
        if _storage._iqn != rhs_storage._iqn {return false}
        if _storage._lun != rhs_storage._lun {return false}
        if _storage._iscsiInterface != rhs_storage._iscsiInterface {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._portals != rhs_storage._portals {return false}
        if _storage._chapAuthDiscovery != rhs_storage._chapAuthDiscovery {return false}
        if _storage._chapAuthSession != rhs_storage._chapAuthSession {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._initiatorName != rhs_storage._initiatorName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ISCSIVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ISCSIVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetPortal"),
    2: .same(proto: "iqn"),
    3: .same(proto: "lun"),
    4: .same(proto: "iscsiInterface"),
    5: .same(proto: "fsType"),
    6: .same(proto: "readOnly"),
    7: .same(proto: "portals"),
    8: .same(proto: "chapAuthDiscovery"),
    11: .same(proto: "chapAuthSession"),
    10: .same(proto: "secretRef"),
    12: .same(proto: "initiatorName"),
  ]

  fileprivate class _StorageClass {
    var _targetPortal: String? = nil
    var _iqn: String? = nil
    var _lun: Int32? = nil
    var _iscsiInterface: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _portals: [String] = []
    var _chapAuthDiscovery: Bool? = nil
    var _chapAuthSession: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _initiatorName: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetPortal = source._targetPortal
      _iqn = source._iqn
      _lun = source._lun
      _iscsiInterface = source._iscsiInterface
      _fsType = source._fsType
      _readOnly = source._readOnly
      _portals = source._portals
      _chapAuthDiscovery = source._chapAuthDiscovery
      _chapAuthSession = source._chapAuthSession
      _secretRef = source._secretRef
      _initiatorName = source._initiatorName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._targetPortal)
        case 2: try decoder.decodeSingularStringField(value: &_storage._iqn)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._lun)
        case 4: try decoder.decodeSingularStringField(value: &_storage._iscsiInterface)
        case 5: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._portals)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._chapAuthDiscovery)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._chapAuthSession)
        case 12: try decoder.decodeSingularStringField(value: &_storage._initiatorName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetPortal {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._iqn {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lun {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._iscsiInterface {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if !_storage._portals.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._portals, fieldNumber: 7)
      }
      if let v = _storage._chapAuthDiscovery {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._chapAuthSession {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if let v = _storage._initiatorName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ISCSIVolumeSource, rhs: K8s_Io_Api_Core_V1_ISCSIVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetPortal != rhs_storage._targetPortal {return false}
        if _storage._iqn != rhs_storage._iqn {return false}
        if _storage._lun != rhs_storage._lun {return false}
        if _storage._iscsiInterface != rhs_storage._iscsiInterface {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._portals != rhs_storage._portals {return false}
        if _storage._chapAuthDiscovery != rhs_storage._chapAuthDiscovery {return false}
        if _storage._chapAuthSession != rhs_storage._chapAuthSession {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._initiatorName != rhs_storage._initiatorName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_KeyToPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyToPath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "path"),
    3: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeSingularStringField(value: &self._path)
      case 3: try decoder.decodeSingularInt32Field(value: &self._mode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._mode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_KeyToPath, rhs: K8s_Io_Api_Core_V1_KeyToPath) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._path != rhs._path {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Lifecycle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Lifecycle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "postStart"),
    2: .same(proto: "preStop"),
  ]

  fileprivate class _StorageClass {
    var _postStart: K8s_Io_Api_Core_V1_Handler? = nil
    var _preStop: K8s_Io_Api_Core_V1_Handler? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _postStart = source._postStart
      _preStop = source._preStop
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._postStart)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._preStop)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._postStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._preStop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Lifecycle, rhs: K8s_Io_Api_Core_V1_Lifecycle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._postStart != rhs_storage._postStart {return false}
        if _storage._preStop != rhs_storage._preStop {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LimitRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LimitRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_LimitRangeSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LimitRange, rhs: K8s_Io_Api_Core_V1_LimitRange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LimitRangeItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LimitRangeItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "max"),
    3: .same(proto: "min"),
    4: .same(proto: "default"),
    5: .same(proto: "defaultRequest"),
    6: .same(proto: "maxLimitRequestRatio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._type)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.max)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.min)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.`default`)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.defaultRequest)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.maxLimitRequestRatio)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.max.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.max, fieldNumber: 2)
    }
    if !self.min.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.min, fieldNumber: 3)
    }
    if !self.`default`.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.`default`, fieldNumber: 4)
    }
    if !self.defaultRequest.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.defaultRequest, fieldNumber: 5)
    }
    if !self.maxLimitRequestRatio.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.maxLimitRequestRatio, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LimitRangeItem, rhs: K8s_Io_Api_Core_V1_LimitRangeItem) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.max != rhs.max {return false}
    if lhs.min != rhs.min {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.defaultRequest != rhs.defaultRequest {return false}
    if lhs.maxLimitRequestRatio != rhs.maxLimitRequestRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LimitRangeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LimitRangeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_LimitRange] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LimitRangeList, rhs: K8s_Io_Api_Core_V1_LimitRangeList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LimitRangeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LimitRangeSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.limits)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.limits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.limits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LimitRangeSpec, rhs: K8s_Io_Api_Core_V1_LimitRangeSpec) -> Bool {
    if lhs.limits != rhs.limits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Apimachinery_Pkg_Runtime_RawExtension] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_List, rhs: K8s_Io_Api_Core_V1_List) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LoadBalancerIngress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerIngress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "hostname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._ip)
      case 2: try decoder.decodeSingularStringField(value: &self._hostname)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._hostname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LoadBalancerIngress, rhs: K8s_Io_Api_Core_V1_LoadBalancerIngress) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs._hostname != rhs._hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LoadBalancerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ingress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ingress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ingress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ingress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LoadBalancerStatus, rhs: K8s_Io_Api_Core_V1_LoadBalancerStatus) -> Bool {
    if lhs.ingress != rhs.ingress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LocalObjectReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalObjectReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LocalObjectReference, rhs: K8s_Io_Api_Core_V1_LocalObjectReference) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_LocalVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "fsType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._path)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_LocalVolumeSource, rhs: K8s_Io_Api_Core_V1_LocalVolumeSource) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NFSVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NFSVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "server"),
    2: .same(proto: "path"),
    3: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._server)
      case 2: try decoder.decodeSingularStringField(value: &self._path)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._server {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NFSVolumeSource, rhs: K8s_Io_Api_Core_V1_NFSVolumeSource) -> Bool {
    if lhs._server != rhs._server {return false}
    if lhs._path != rhs._path {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Namespace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_NamespaceSpec? = nil
    var _status: K8s_Io_Api_Core_V1_NamespaceStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Namespace, rhs: K8s_Io_Api_Core_V1_Namespace) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NamespaceCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    4: .same(proto: "lastTransitionTime"),
    5: .same(proto: "reason"),
    6: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 5: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 6: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NamespaceCondition, rhs: K8s_Io_Api_Core_V1_NamespaceCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NamespaceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Namespace] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NamespaceList, rhs: K8s_Io_Api_Core_V1_NamespaceList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NamespaceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finalizers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.finalizers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.finalizers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.finalizers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NamespaceSpec, rhs: K8s_Io_Api_Core_V1_NamespaceSpec) -> Bool {
    if lhs.finalizers != rhs.finalizers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NamespaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phase"),
    2: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._phase)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._phase {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NamespaceStatus, rhs: K8s_Io_Api_Core_V1_NamespaceStatus) -> Bool {
    if lhs._phase != rhs._phase {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_NodeSpec? = nil
    var _status: K8s_Io_Api_Core_V1_NodeStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Node, rhs: K8s_Io_Api_Core_V1_Node) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._type)
      case 2: try decoder.decodeSingularStringField(value: &self._address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeAddress, rhs: K8s_Io_Api_Core_V1_NodeAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeAffinity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeAffinity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requiredDuringSchedulingIgnoredDuringExecution"),
    2: .same(proto: "preferredDuringSchedulingIgnoredDuringExecution"),
  ]

  fileprivate class _StorageClass {
    var _requiredDuringSchedulingIgnoredDuringExecution: K8s_Io_Api_Core_V1_NodeSelector? = nil
    var _preferredDuringSchedulingIgnoredDuringExecution: [K8s_Io_Api_Core_V1_PreferredSchedulingTerm] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requiredDuringSchedulingIgnoredDuringExecution = source._requiredDuringSchedulingIgnoredDuringExecution
      _preferredDuringSchedulingIgnoredDuringExecution = source._preferredDuringSchedulingIgnoredDuringExecution
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._requiredDuringSchedulingIgnoredDuringExecution)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._preferredDuringSchedulingIgnoredDuringExecution)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._requiredDuringSchedulingIgnoredDuringExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._preferredDuringSchedulingIgnoredDuringExecution.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preferredDuringSchedulingIgnoredDuringExecution, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeAffinity, rhs: K8s_Io_Api_Core_V1_NodeAffinity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requiredDuringSchedulingIgnoredDuringExecution != rhs_storage._requiredDuringSchedulingIgnoredDuringExecution {return false}
        if _storage._preferredDuringSchedulingIgnoredDuringExecution != rhs_storage._preferredDuringSchedulingIgnoredDuringExecution {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastHeartbeatTime"),
    4: .same(proto: "lastTransitionTime"),
    5: .same(proto: "reason"),
    6: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastHeartbeatTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastHeartbeatTime = source._lastHeartbeatTime
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastHeartbeatTime)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 5: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 6: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastHeartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeCondition, rhs: K8s_Io_Api_Core_V1_NodeCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastHeartbeatTime != rhs_storage._lastHeartbeatTime {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeConfigSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeConfigSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "configMap"),
  ]

  fileprivate class _StorageClass {
    var _configMap: K8s_Io_Api_Core_V1_ConfigMapNodeConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _configMap = source._configMap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configMap)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._configMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeConfigSource, rhs: K8s_Io_Api_Core_V1_NodeConfigSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._configMap != rhs_storage._configMap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeConfigStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeConfigStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assigned"),
    2: .same(proto: "active"),
    3: .same(proto: "lastKnownGood"),
    4: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _assigned: K8s_Io_Api_Core_V1_NodeConfigSource? = nil
    var _active: K8s_Io_Api_Core_V1_NodeConfigSource? = nil
    var _lastKnownGood: K8s_Io_Api_Core_V1_NodeConfigSource? = nil
    var _error: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assigned = source._assigned
      _active = source._active
      _lastKnownGood = source._lastKnownGood
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._assigned)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._active)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastKnownGood)
        case 4: try decoder.decodeSingularStringField(value: &_storage._error)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._assigned {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._active {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastKnownGood {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._error {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeConfigStatus, rhs: K8s_Io_Api_Core_V1_NodeConfigStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._assigned != rhs_storage._assigned {return false}
        if _storage._active != rhs_storage._active {return false}
        if _storage._lastKnownGood != rhs_storage._lastKnownGood {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeDaemonEndpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeDaemonEndpoints"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kubeletEndpoint"),
  ]

  fileprivate class _StorageClass {
    var _kubeletEndpoint: K8s_Io_Api_Core_V1_DaemonEndpoint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kubeletEndpoint = source._kubeletEndpoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._kubeletEndpoint)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._kubeletEndpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeDaemonEndpoints, rhs: K8s_Io_Api_Core_V1_NodeDaemonEndpoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kubeletEndpoint != rhs_storage._kubeletEndpoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Node] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeList, rhs: K8s_Io_Api_Core_V1_NodeList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeProxyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeProxyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeProxyOptions, rhs: K8s_Io_Api_Core_V1_NodeProxyOptions) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeResources"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capacity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.capacity)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.capacity.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.capacity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeResources, rhs: K8s_Io_Api_Core_V1_NodeResources) -> Bool {
    if lhs.capacity != rhs.capacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeSelectorTerms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodeSelectorTerms)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeSelectorTerms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeSelectorTerms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeSelector, rhs: K8s_Io_Api_Core_V1_NodeSelector) -> Bool {
    if lhs.nodeSelectorTerms != rhs.nodeSelectorTerms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeSelectorRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeSelectorRequirement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "operator"),
    3: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeSingularStringField(value: &self._operator)
      case 3: try decoder.decodeRepeatedStringField(value: &self.values)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._operator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeSelectorRequirement, rhs: K8s_Io_Api_Core_V1_NodeSelectorRequirement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeSelectorTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeSelectorTerm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matchExpressions"),
    2: .same(proto: "matchFields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matchExpressions)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.matchFields)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchExpressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchExpressions, fieldNumber: 1)
    }
    if !self.matchFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchFields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeSelectorTerm, rhs: K8s_Io_Api_Core_V1_NodeSelectorTerm) -> Bool {
    if lhs.matchExpressions != rhs.matchExpressions {return false}
    if lhs.matchFields != rhs.matchFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podCIDR"),
    7: .same(proto: "podCIDRs"),
    3: .same(proto: "providerID"),
    4: .same(proto: "unschedulable"),
    5: .same(proto: "taints"),
    6: .same(proto: "configSource"),
    2: .same(proto: "externalID"),
  ]

  fileprivate class _StorageClass {
    var _podCidr: String? = nil
    var _podCidrs: [String] = []
    var _providerID: String? = nil
    var _unschedulable: Bool? = nil
    var _taints: [K8s_Io_Api_Core_V1_Taint] = []
    var _configSource: K8s_Io_Api_Core_V1_NodeConfigSource? = nil
    var _externalID: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podCidr = source._podCidr
      _podCidrs = source._podCidrs
      _providerID = source._providerID
      _unschedulable = source._unschedulable
      _taints = source._taints
      _configSource = source._configSource
      _externalID = source._externalID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._podCidr)
        case 2: try decoder.decodeSingularStringField(value: &_storage._externalID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._providerID)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._unschedulable)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._taints)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._configSource)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._podCidrs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podCidr {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._externalID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._providerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._unschedulable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if !_storage._taints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._taints, fieldNumber: 5)
      }
      if let v = _storage._configSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._podCidrs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._podCidrs, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeSpec, rhs: K8s_Io_Api_Core_V1_NodeSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podCidr != rhs_storage._podCidr {return false}
        if _storage._podCidrs != rhs_storage._podCidrs {return false}
        if _storage._providerID != rhs_storage._providerID {return false}
        if _storage._unschedulable != rhs_storage._unschedulable {return false}
        if _storage._taints != rhs_storage._taints {return false}
        if _storage._configSource != rhs_storage._configSource {return false}
        if _storage._externalID != rhs_storage._externalID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capacity"),
    2: .same(proto: "allocatable"),
    3: .same(proto: "phase"),
    4: .same(proto: "conditions"),
    5: .same(proto: "addresses"),
    6: .same(proto: "daemonEndpoints"),
    7: .same(proto: "nodeInfo"),
    8: .same(proto: "images"),
    9: .same(proto: "volumesInUse"),
    10: .same(proto: "volumesAttached"),
    11: .same(proto: "config"),
  ]

  fileprivate class _StorageClass {
    var _capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]
    var _allocatable: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]
    var _phase: String? = nil
    var _conditions: [K8s_Io_Api_Core_V1_NodeCondition] = []
    var _addresses: [K8s_Io_Api_Core_V1_NodeAddress] = []
    var _daemonEndpoints: K8s_Io_Api_Core_V1_NodeDaemonEndpoints? = nil
    var _nodeInfo: K8s_Io_Api_Core_V1_NodeSystemInfo? = nil
    var _images: [K8s_Io_Api_Core_V1_ContainerImage] = []
    var _volumesInUse: [String] = []
    var _volumesAttached: [K8s_Io_Api_Core_V1_AttachedVolume] = []
    var _config: K8s_Io_Api_Core_V1_NodeConfigStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _capacity = source._capacity
      _allocatable = source._allocatable
      _phase = source._phase
      _conditions = source._conditions
      _addresses = source._addresses
      _daemonEndpoints = source._daemonEndpoints
      _nodeInfo = source._nodeInfo
      _images = source._images
      _volumesInUse = source._volumesInUse
      _volumesAttached = source._volumesAttached
      _config = source._config
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &_storage._capacity)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &_storage._allocatable)
        case 3: try decoder.decodeSingularStringField(value: &_storage._phase)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._conditions)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._addresses)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._daemonEndpoints)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._nodeInfo)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._images)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._volumesInUse)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._volumesAttached)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._config)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._capacity.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: _storage._capacity, fieldNumber: 1)
      }
      if !_storage._allocatable.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: _storage._allocatable, fieldNumber: 2)
      }
      if let v = _storage._phase {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 4)
      }
      if !_storage._addresses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addresses, fieldNumber: 5)
      }
      if let v = _storage._daemonEndpoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._nodeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._images, fieldNumber: 8)
      }
      if !_storage._volumesInUse.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._volumesInUse, fieldNumber: 9)
      }
      if !_storage._volumesAttached.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumesAttached, fieldNumber: 10)
      }
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeStatus, rhs: K8s_Io_Api_Core_V1_NodeStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._capacity != rhs_storage._capacity {return false}
        if _storage._allocatable != rhs_storage._allocatable {return false}
        if _storage._phase != rhs_storage._phase {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        if _storage._addresses != rhs_storage._addresses {return false}
        if _storage._daemonEndpoints != rhs_storage._daemonEndpoints {return false}
        if _storage._nodeInfo != rhs_storage._nodeInfo {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._volumesInUse != rhs_storage._volumesInUse {return false}
        if _storage._volumesAttached != rhs_storage._volumesAttached {return false}
        if _storage._config != rhs_storage._config {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_NodeSystemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeSystemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "machineID"),
    2: .same(proto: "systemUUID"),
    3: .same(proto: "bootID"),
    4: .same(proto: "kernelVersion"),
    5: .same(proto: "osImage"),
    6: .same(proto: "containerRuntimeVersion"),
    7: .same(proto: "kubeletVersion"),
    8: .same(proto: "kubeProxyVersion"),
    9: .same(proto: "operatingSystem"),
    10: .same(proto: "architecture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._machineID)
      case 2: try decoder.decodeSingularStringField(value: &self._systemUuid)
      case 3: try decoder.decodeSingularStringField(value: &self._bootID)
      case 4: try decoder.decodeSingularStringField(value: &self._kernelVersion)
      case 5: try decoder.decodeSingularStringField(value: &self._osImage)
      case 6: try decoder.decodeSingularStringField(value: &self._containerRuntimeVersion)
      case 7: try decoder.decodeSingularStringField(value: &self._kubeletVersion)
      case 8: try decoder.decodeSingularStringField(value: &self._kubeProxyVersion)
      case 9: try decoder.decodeSingularStringField(value: &self._operatingSystem)
      case 10: try decoder.decodeSingularStringField(value: &self._architecture)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._machineID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._systemUuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._bootID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._kernelVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._osImage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._containerRuntimeVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._kubeletVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._kubeProxyVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._operatingSystem {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if let v = self._architecture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_NodeSystemInfo, rhs: K8s_Io_Api_Core_V1_NodeSystemInfo) -> Bool {
    if lhs._machineID != rhs._machineID {return false}
    if lhs._systemUuid != rhs._systemUuid {return false}
    if lhs._bootID != rhs._bootID {return false}
    if lhs._kernelVersion != rhs._kernelVersion {return false}
    if lhs._osImage != rhs._osImage {return false}
    if lhs._containerRuntimeVersion != rhs._containerRuntimeVersion {return false}
    if lhs._kubeletVersion != rhs._kubeletVersion {return false}
    if lhs._kubeProxyVersion != rhs._kubeProxyVersion {return false}
    if lhs._operatingSystem != rhs._operatingSystem {return false}
    if lhs._architecture != rhs._architecture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ObjectFieldSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectFieldSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apiVersion"),
    2: .same(proto: "fieldPath"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._apiVersion)
      case 2: try decoder.decodeSingularStringField(value: &self._fieldPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._apiVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fieldPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ObjectFieldSelector, rhs: K8s_Io_Api_Core_V1_ObjectFieldSelector) -> Bool {
    if lhs._apiVersion != rhs._apiVersion {return false}
    if lhs._fieldPath != rhs._fieldPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ObjectReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "namespace"),
    3: .same(proto: "name"),
    4: .same(proto: "uid"),
    5: .same(proto: "apiVersion"),
    6: .same(proto: "resourceVersion"),
    7: .same(proto: "fieldPath"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._kind)
      case 2: try decoder.decodeSingularStringField(value: &self._namespace)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularStringField(value: &self._uid)
      case 5: try decoder.decodeSingularStringField(value: &self._apiVersion)
      case 6: try decoder.decodeSingularStringField(value: &self._resourceVersion)
      case 7: try decoder.decodeSingularStringField(value: &self._fieldPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._apiVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._resourceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._fieldPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ObjectReference, rhs: K8s_Io_Api_Core_V1_ObjectReference) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._namespace != rhs._namespace {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._apiVersion != rhs._apiVersion {return false}
    if lhs._resourceVersion != rhs._resourceVersion {return false}
    if lhs._fieldPath != rhs._fieldPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_PersistentVolumeSpec? = nil
    var _status: K8s_Io_Api_Core_V1_PersistentVolumeStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolume, rhs: K8s_Io_Api_Core_V1_PersistentVolume) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec? = nil
    var _status: K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaim, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaimCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaimCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastProbeTime"),
    4: .same(proto: "lastTransitionTime"),
    5: .same(proto: "reason"),
    6: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastProbeTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastProbeTime = source._lastProbeTime
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastProbeTime)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 5: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 6: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastProbeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimCondition, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastProbeTime != rhs_storage._lastProbeTime {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaimList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaimList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_PersistentVolumeClaim] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimList, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaimSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessModes"),
    4: .same(proto: "selector"),
    2: .same(proto: "resources"),
    3: .same(proto: "volumeName"),
    5: .same(proto: "storageClassName"),
    6: .same(proto: "volumeMode"),
    7: .same(proto: "dataSource"),
  ]

  fileprivate class _StorageClass {
    var _accessModes: [String] = []
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _resources: K8s_Io_Api_Core_V1_ResourceRequirements? = nil
    var _volumeName: String? = nil
    var _storageClassName: String? = nil
    var _volumeMode: String? = nil
    var _dataSource: K8s_Io_Api_Core_V1_TypedLocalObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accessModes = source._accessModes
      _selector = source._selector
      _resources = source._resources
      _volumeName = source._volumeName
      _storageClassName = source._storageClassName
      _volumeMode = source._volumeMode
      _dataSource = source._dataSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._accessModes)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._resources)
        case 3: try decoder.decodeSingularStringField(value: &_storage._volumeName)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 5: try decoder.decodeSingularStringField(value: &_storage._storageClassName)
        case 6: try decoder.decodeSingularStringField(value: &_storage._volumeMode)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._dataSource)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accessModes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accessModes, fieldNumber: 1)
      }
      if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._volumeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._storageClassName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._volumeMode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._dataSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accessModes != rhs_storage._accessModes {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._volumeName != rhs_storage._volumeName {return false}
        if _storage._storageClassName != rhs_storage._storageClassName {return false}
        if _storage._volumeMode != rhs_storage._volumeMode {return false}
        if _storage._dataSource != rhs_storage._dataSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaimStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phase"),
    2: .same(proto: "accessModes"),
    3: .same(proto: "capacity"),
    4: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._phase)
      case 2: try decoder.decodeRepeatedStringField(value: &self.accessModes)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.capacity)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._phase {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.accessModes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessModes, fieldNumber: 2)
    }
    if !self.capacity.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.capacity, fieldNumber: 3)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimStatus) -> Bool {
    if lhs._phase != rhs._phase {return false}
    if lhs.accessModes != rhs.accessModes {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeClaimVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "claimName"),
    2: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._claimName)
      case 2: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._claimName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource, rhs: K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource) -> Bool {
    if lhs._claimName != rhs._claimName {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_PersistentVolume] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeList, rhs: K8s_Io_Api_Core_V1_PersistentVolumeList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gcePersistentDisk"),
    2: .same(proto: "awsElasticBlockStore"),
    3: .same(proto: "hostPath"),
    4: .same(proto: "glusterfs"),
    5: .same(proto: "nfs"),
    6: .same(proto: "rbd"),
    7: .same(proto: "iscsi"),
    8: .same(proto: "cinder"),
    9: .same(proto: "cephfs"),
    10: .same(proto: "fc"),
    11: .same(proto: "flocker"),
    12: .same(proto: "flexVolume"),
    13: .same(proto: "azureFile"),
    14: .same(proto: "vsphereVolume"),
    15: .same(proto: "quobyte"),
    16: .same(proto: "azureDisk"),
    17: .same(proto: "photonPersistentDisk"),
    18: .same(proto: "portworxVolume"),
    19: .same(proto: "scaleIO"),
    20: .same(proto: "local"),
    21: .same(proto: "storageos"),
    22: .same(proto: "csi"),
  ]

  fileprivate class _StorageClass {
    var _gcePersistentDisk: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource? = nil
    var _awsElasticBlockStore: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource? = nil
    var _hostPath: K8s_Io_Api_Core_V1_HostPathVolumeSource? = nil
    var _glusterfs: K8s_Io_Api_Core_V1_GlusterfsPersistentVolumeSource? = nil
    var _nfs: K8s_Io_Api_Core_V1_NFSVolumeSource? = nil
    var _rbd: K8s_Io_Api_Core_V1_RBDPersistentVolumeSource? = nil
    var _iscsi: K8s_Io_Api_Core_V1_ISCSIPersistentVolumeSource? = nil
    var _cinder: K8s_Io_Api_Core_V1_CinderPersistentVolumeSource? = nil
    var _cephfs: K8s_Io_Api_Core_V1_CephFSPersistentVolumeSource? = nil
    var _fc: K8s_Io_Api_Core_V1_FCVolumeSource? = nil
    var _flocker: K8s_Io_Api_Core_V1_FlockerVolumeSource? = nil
    var _flexVolume: K8s_Io_Api_Core_V1_FlexPersistentVolumeSource? = nil
    var _azureFile: K8s_Io_Api_Core_V1_AzureFilePersistentVolumeSource? = nil
    var _vsphereVolume: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource? = nil
    var _quobyte: K8s_Io_Api_Core_V1_QuobyteVolumeSource? = nil
    var _azureDisk: K8s_Io_Api_Core_V1_AzureDiskVolumeSource? = nil
    var _photonPersistentDisk: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource? = nil
    var _portworxVolume: K8s_Io_Api_Core_V1_PortworxVolumeSource? = nil
    var _scaleIo: K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource? = nil
    var _local: K8s_Io_Api_Core_V1_LocalVolumeSource? = nil
    var _storageos: K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource? = nil
    var _csi: K8s_Io_Api_Core_V1_CSIPersistentVolumeSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gcePersistentDisk = source._gcePersistentDisk
      _awsElasticBlockStore = source._awsElasticBlockStore
      _hostPath = source._hostPath
      _glusterfs = source._glusterfs
      _nfs = source._nfs
      _rbd = source._rbd
      _iscsi = source._iscsi
      _cinder = source._cinder
      _cephfs = source._cephfs
      _fc = source._fc
      _flocker = source._flocker
      _flexVolume = source._flexVolume
      _azureFile = source._azureFile
      _vsphereVolume = source._vsphereVolume
      _quobyte = source._quobyte
      _azureDisk = source._azureDisk
      _photonPersistentDisk = source._photonPersistentDisk
      _portworxVolume = source._portworxVolume
      _scaleIo = source._scaleIo
      _local = source._local
      _storageos = source._storageos
      _csi = source._csi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gcePersistentDisk)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._awsElasticBlockStore)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._hostPath)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._glusterfs)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._nfs)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._rbd)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._iscsi)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._cinder)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._cephfs)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._fc)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._flocker)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._flexVolume)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._azureFile)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._vsphereVolume)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._quobyte)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._azureDisk)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._photonPersistentDisk)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._portworxVolume)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._scaleIo)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._local)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._storageos)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._csi)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gcePersistentDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._awsElasticBlockStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._hostPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._glusterfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._nfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._rbd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._iscsi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._cinder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._cephfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._fc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._flocker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._flexVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._azureFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._vsphereVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._quobyte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._azureDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._photonPersistentDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._portworxVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._scaleIo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._local {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._storageos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._csi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_PersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gcePersistentDisk != rhs_storage._gcePersistentDisk {return false}
        if _storage._awsElasticBlockStore != rhs_storage._awsElasticBlockStore {return false}
        if _storage._hostPath != rhs_storage._hostPath {return false}
        if _storage._glusterfs != rhs_storage._glusterfs {return false}
        if _storage._nfs != rhs_storage._nfs {return false}
        if _storage._rbd != rhs_storage._rbd {return false}
        if _storage._iscsi != rhs_storage._iscsi {return false}
        if _storage._cinder != rhs_storage._cinder {return false}
        if _storage._cephfs != rhs_storage._cephfs {return false}
        if _storage._fc != rhs_storage._fc {return false}
        if _storage._flocker != rhs_storage._flocker {return false}
        if _storage._flexVolume != rhs_storage._flexVolume {return false}
        if _storage._azureFile != rhs_storage._azureFile {return false}
        if _storage._vsphereVolume != rhs_storage._vsphereVolume {return false}
        if _storage._quobyte != rhs_storage._quobyte {return false}
        if _storage._azureDisk != rhs_storage._azureDisk {return false}
        if _storage._photonPersistentDisk != rhs_storage._photonPersistentDisk {return false}
        if _storage._portworxVolume != rhs_storage._portworxVolume {return false}
        if _storage._scaleIo != rhs_storage._scaleIo {return false}
        if _storage._local != rhs_storage._local {return false}
        if _storage._storageos != rhs_storage._storageos {return false}
        if _storage._csi != rhs_storage._csi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capacity"),
    2: .same(proto: "persistentVolumeSource"),
    3: .same(proto: "accessModes"),
    4: .same(proto: "claimRef"),
    5: .same(proto: "persistentVolumeReclaimPolicy"),
    6: .same(proto: "storageClassName"),
    7: .same(proto: "mountOptions"),
    8: .same(proto: "volumeMode"),
    9: .same(proto: "nodeAffinity"),
  ]

  fileprivate class _StorageClass {
    var _capacity: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]
    var _persistentVolumeSource: K8s_Io_Api_Core_V1_PersistentVolumeSource? = nil
    var _accessModes: [String] = []
    var _claimRef: K8s_Io_Api_Core_V1_ObjectReference? = nil
    var _persistentVolumeReclaimPolicy: String? = nil
    var _storageClassName: String? = nil
    var _mountOptions: [String] = []
    var _volumeMode: String? = nil
    var _nodeAffinity: K8s_Io_Api_Core_V1_VolumeNodeAffinity? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _capacity = source._capacity
      _persistentVolumeSource = source._persistentVolumeSource
      _accessModes = source._accessModes
      _claimRef = source._claimRef
      _persistentVolumeReclaimPolicy = source._persistentVolumeReclaimPolicy
      _storageClassName = source._storageClassName
      _mountOptions = source._mountOptions
      _volumeMode = source._volumeMode
      _nodeAffinity = source._nodeAffinity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &_storage._capacity)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._persistentVolumeSource)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._accessModes)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._claimRef)
        case 5: try decoder.decodeSingularStringField(value: &_storage._persistentVolumeReclaimPolicy)
        case 6: try decoder.decodeSingularStringField(value: &_storage._storageClassName)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._mountOptions)
        case 8: try decoder.decodeSingularStringField(value: &_storage._volumeMode)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._nodeAffinity)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._capacity.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: _storage._capacity, fieldNumber: 1)
      }
      if let v = _storage._persistentVolumeSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._accessModes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accessModes, fieldNumber: 3)
      }
      if let v = _storage._claimRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._persistentVolumeReclaimPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._storageClassName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if !_storage._mountOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._mountOptions, fieldNumber: 7)
      }
      if let v = _storage._volumeMode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._nodeAffinity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeSpec, rhs: K8s_Io_Api_Core_V1_PersistentVolumeSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._capacity != rhs_storage._capacity {return false}
        if _storage._persistentVolumeSource != rhs_storage._persistentVolumeSource {return false}
        if _storage._accessModes != rhs_storage._accessModes {return false}
        if _storage._claimRef != rhs_storage._claimRef {return false}
        if _storage._persistentVolumeReclaimPolicy != rhs_storage._persistentVolumeReclaimPolicy {return false}
        if _storage._storageClassName != rhs_storage._storageClassName {return false}
        if _storage._mountOptions != rhs_storage._mountOptions {return false}
        if _storage._volumeMode != rhs_storage._volumeMode {return false}
        if _storage._nodeAffinity != rhs_storage._nodeAffinity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PersistentVolumeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersistentVolumeStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phase"),
    2: .same(proto: "message"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._phase)
      case 2: try decoder.decodeSingularStringField(value: &self._message)
      case 3: try decoder.decodeSingularStringField(value: &self._reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._phase {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PersistentVolumeStatus, rhs: K8s_Io_Api_Core_V1_PersistentVolumeStatus) -> Bool {
    if lhs._phase != rhs._phase {return false}
    if lhs._message != rhs._message {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PhotonPersistentDiskVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pdID"),
    2: .same(proto: "fsType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pdID)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pdID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource, rhs: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource) -> Bool {
    if lhs._pdID != rhs._pdID {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Pod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_PodSpec? = nil
    var _status: K8s_Io_Api_Core_V1_PodStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Pod, rhs: K8s_Io_Api_Core_V1_Pod) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodAffinity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodAffinity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requiredDuringSchedulingIgnoredDuringExecution"),
    2: .same(proto: "preferredDuringSchedulingIgnoredDuringExecution"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.requiredDuringSchedulingIgnoredDuringExecution)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preferredDuringSchedulingIgnoredDuringExecution)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requiredDuringSchedulingIgnoredDuringExecution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requiredDuringSchedulingIgnoredDuringExecution, fieldNumber: 1)
    }
    if !self.preferredDuringSchedulingIgnoredDuringExecution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preferredDuringSchedulingIgnoredDuringExecution, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodAffinity, rhs: K8s_Io_Api_Core_V1_PodAffinity) -> Bool {
    if lhs.requiredDuringSchedulingIgnoredDuringExecution != rhs.requiredDuringSchedulingIgnoredDuringExecution {return false}
    if lhs.preferredDuringSchedulingIgnoredDuringExecution != rhs.preferredDuringSchedulingIgnoredDuringExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodAffinityTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodAffinityTerm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labelSelector"),
    2: .same(proto: "namespaces"),
    3: .same(proto: "topologyKey"),
  ]

  fileprivate class _StorageClass {
    var _labelSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _namespaces: [String] = []
    var _topologyKey: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _labelSelector = source._labelSelector
      _namespaces = source._namespaces
      _topologyKey = source._topologyKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._labelSelector)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._namespaces)
        case 3: try decoder.decodeSingularStringField(value: &_storage._topologyKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._labelSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._namespaces.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._namespaces, fieldNumber: 2)
      }
      if let v = _storage._topologyKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodAffinityTerm, rhs: K8s_Io_Api_Core_V1_PodAffinityTerm) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._labelSelector != rhs_storage._labelSelector {return false}
        if _storage._namespaces != rhs_storage._namespaces {return false}
        if _storage._topologyKey != rhs_storage._topologyKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodAntiAffinity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodAntiAffinity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requiredDuringSchedulingIgnoredDuringExecution"),
    2: .same(proto: "preferredDuringSchedulingIgnoredDuringExecution"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.requiredDuringSchedulingIgnoredDuringExecution)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.preferredDuringSchedulingIgnoredDuringExecution)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requiredDuringSchedulingIgnoredDuringExecution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requiredDuringSchedulingIgnoredDuringExecution, fieldNumber: 1)
    }
    if !self.preferredDuringSchedulingIgnoredDuringExecution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.preferredDuringSchedulingIgnoredDuringExecution, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodAntiAffinity, rhs: K8s_Io_Api_Core_V1_PodAntiAffinity) -> Bool {
    if lhs.requiredDuringSchedulingIgnoredDuringExecution != rhs.requiredDuringSchedulingIgnoredDuringExecution {return false}
    if lhs.preferredDuringSchedulingIgnoredDuringExecution != rhs.preferredDuringSchedulingIgnoredDuringExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodAttachOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodAttachOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdin"),
    2: .same(proto: "stdout"),
    3: .same(proto: "stderr"),
    4: .same(proto: "tty"),
    5: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._stdin)
      case 2: try decoder.decodeSingularBoolField(value: &self._stdout)
      case 3: try decoder.decodeSingularBoolField(value: &self._stderr)
      case 4: try decoder.decodeSingularBoolField(value: &self._tty)
      case 5: try decoder.decodeSingularStringField(value: &self._container)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stdin {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._stdout {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._stderr {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._tty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._container {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodAttachOptions, rhs: K8s_Io_Api_Core_V1_PodAttachOptions) -> Bool {
    if lhs._stdin != rhs._stdin {return false}
    if lhs._stdout != rhs._stdout {return false}
    if lhs._stderr != rhs._stderr {return false}
    if lhs._tty != rhs._tty {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastProbeTime"),
    4: .same(proto: "lastTransitionTime"),
    5: .same(proto: "reason"),
    6: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastProbeTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastProbeTime = source._lastProbeTime
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastProbeTime)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 5: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 6: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastProbeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodCondition, rhs: K8s_Io_Api_Core_V1_PodCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastProbeTime != rhs_storage._lastProbeTime {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodDNSConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDNSConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nameservers"),
    2: .same(proto: "searches"),
    3: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.nameservers)
      case 2: try decoder.decodeRepeatedStringField(value: &self.searches)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.options)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nameservers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nameservers, fieldNumber: 1)
    }
    if !self.searches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searches, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodDNSConfig, rhs: K8s_Io_Api_Core_V1_PodDNSConfig) -> Bool {
    if lhs.nameservers != rhs.nameservers {return false}
    if lhs.searches != rhs.searches {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodDNSConfigOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDNSConfigOption"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodDNSConfigOption, rhs: K8s_Io_Api_Core_V1_PodDNSConfigOption) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodExecOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodExecOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdin"),
    2: .same(proto: "stdout"),
    3: .same(proto: "stderr"),
    4: .same(proto: "tty"),
    5: .same(proto: "container"),
    6: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._stdin)
      case 2: try decoder.decodeSingularBoolField(value: &self._stdout)
      case 3: try decoder.decodeSingularBoolField(value: &self._stderr)
      case 4: try decoder.decodeSingularBoolField(value: &self._tty)
      case 5: try decoder.decodeSingularStringField(value: &self._container)
      case 6: try decoder.decodeRepeatedStringField(value: &self.command)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stdin {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._stdout {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._stderr {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._tty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._container {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodExecOptions, rhs: K8s_Io_Api_Core_V1_PodExecOptions) -> Bool {
    if lhs._stdin != rhs._stdin {return false}
    if lhs._stdout != rhs._stdout {return false}
    if lhs._stderr != rhs._stderr {return false}
    if lhs._tty != rhs._tty {return false}
    if lhs._container != rhs._container {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodIP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodIP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._ip)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodIP, rhs: K8s_Io_Api_Core_V1_PodIP) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Pod] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodList, rhs: K8s_Io_Api_Core_V1_PodList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodLogOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodLogOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "container"),
    2: .same(proto: "follow"),
    3: .same(proto: "previous"),
    4: .same(proto: "sinceSeconds"),
    5: .same(proto: "sinceTime"),
    6: .same(proto: "timestamps"),
    7: .same(proto: "tailLines"),
    8: .same(proto: "limitBytes"),
    9: .same(proto: "insecureSkipTLSVerifyBackend"),
  ]

  fileprivate class _StorageClass {
    var _container: String? = nil
    var _follow: Bool? = nil
    var _previous: Bool? = nil
    var _sinceSeconds: Int64? = nil
    var _sinceTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _timestamps: Bool? = nil
    var _tailLines: Int64? = nil
    var _limitBytes: Int64? = nil
    var _insecureSkipTlsverifyBackend: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _container = source._container
      _follow = source._follow
      _previous = source._previous
      _sinceSeconds = source._sinceSeconds
      _sinceTime = source._sinceTime
      _timestamps = source._timestamps
      _tailLines = source._tailLines
      _limitBytes = source._limitBytes
      _insecureSkipTlsverifyBackend = source._insecureSkipTlsverifyBackend
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._container)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._follow)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._previous)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._sinceSeconds)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._sinceTime)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._timestamps)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._tailLines)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._limitBytes)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._insecureSkipTlsverifyBackend)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._container {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._follow {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._previous {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._sinceSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._sinceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._timestamps {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tailLines {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._limitBytes {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._insecureSkipTlsverifyBackend {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodLogOptions, rhs: K8s_Io_Api_Core_V1_PodLogOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._container != rhs_storage._container {return false}
        if _storage._follow != rhs_storage._follow {return false}
        if _storage._previous != rhs_storage._previous {return false}
        if _storage._sinceSeconds != rhs_storage._sinceSeconds {return false}
        if _storage._sinceTime != rhs_storage._sinceTime {return false}
        if _storage._timestamps != rhs_storage._timestamps {return false}
        if _storage._tailLines != rhs_storage._tailLines {return false}
        if _storage._limitBytes != rhs_storage._limitBytes {return false}
        if _storage._insecureSkipTlsverifyBackend != rhs_storage._insecureSkipTlsverifyBackend {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodPortForwardOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodPortForwardOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt32Field(value: &self.ports)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.ports, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodPortForwardOptions, rhs: K8s_Io_Api_Core_V1_PodPortForwardOptions) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodProxyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodProxyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodProxyOptions, rhs: K8s_Io_Api_Core_V1_PodProxyOptions) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodReadinessGate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodReadinessGate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conditionType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._conditionType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conditionType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodReadinessGate, rhs: K8s_Io_Api_Core_V1_PodReadinessGate) -> Bool {
    if lhs._conditionType != rhs._conditionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodSecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seLinuxOptions"),
    8: .same(proto: "windowsOptions"),
    2: .same(proto: "runAsUser"),
    6: .same(proto: "runAsGroup"),
    3: .same(proto: "runAsNonRoot"),
    4: .same(proto: "supplementalGroups"),
    5: .same(proto: "fsGroup"),
    7: .same(proto: "sysctls"),
  ]

  fileprivate class _StorageClass {
    var _seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions? = nil
    var _windowsOptions: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions? = nil
    var _runAsUser: Int64? = nil
    var _runAsGroup: Int64? = nil
    var _runAsNonRoot: Bool? = nil
    var _supplementalGroups: [Int64] = []
    var _fsGroup: Int64? = nil
    var _sysctls: [K8s_Io_Api_Core_V1_Sysctl] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seLinuxOptions = source._seLinuxOptions
      _windowsOptions = source._windowsOptions
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _runAsNonRoot = source._runAsNonRoot
      _supplementalGroups = source._supplementalGroups
      _fsGroup = source._fsGroup
      _sysctls = source._sysctls
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._seLinuxOptions)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._runAsUser)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._runAsNonRoot)
        case 4: try decoder.decodeRepeatedInt64Field(value: &_storage._supplementalGroups)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._fsGroup)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._runAsGroup)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._sysctls)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._windowsOptions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._seLinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._runAsUser {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._runAsNonRoot {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if !_storage._supplementalGroups.isEmpty {
        try visitor.visitRepeatedInt64Field(value: _storage._supplementalGroups, fieldNumber: 4)
      }
      if let v = _storage._fsGroup {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._runAsGroup {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
      }
      if !_storage._sysctls.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sysctls, fieldNumber: 7)
      }
      if let v = _storage._windowsOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodSecurityContext, rhs: K8s_Io_Api_Core_V1_PodSecurityContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seLinuxOptions != rhs_storage._seLinuxOptions {return false}
        if _storage._windowsOptions != rhs_storage._windowsOptions {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._runAsNonRoot != rhs_storage._runAsNonRoot {return false}
        if _storage._supplementalGroups != rhs_storage._supplementalGroups {return false}
        if _storage._fsGroup != rhs_storage._fsGroup {return false}
        if _storage._sysctls != rhs_storage._sysctls {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podController"),
  ]

  fileprivate class _StorageClass {
    var _podController: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_OwnerReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podController = source._podController
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podController)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podController {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodSignature, rhs: K8s_Io_Api_Core_V1_PodSignature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podController != rhs_storage._podController {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumes"),
    20: .same(proto: "initContainers"),
    2: .same(proto: "containers"),
    34: .same(proto: "ephemeralContainers"),
    3: .same(proto: "restartPolicy"),
    4: .same(proto: "terminationGracePeriodSeconds"),
    5: .same(proto: "activeDeadlineSeconds"),
    6: .same(proto: "dnsPolicy"),
    7: .same(proto: "nodeSelector"),
    8: .same(proto: "serviceAccountName"),
    9: .same(proto: "serviceAccount"),
    21: .same(proto: "automountServiceAccountToken"),
    10: .same(proto: "nodeName"),
    11: .same(proto: "hostNetwork"),
    12: .same(proto: "hostPID"),
    13: .same(proto: "hostIPC"),
    27: .same(proto: "shareProcessNamespace"),
    14: .same(proto: "securityContext"),
    15: .same(proto: "imagePullSecrets"),
    16: .same(proto: "hostname"),
    17: .same(proto: "subdomain"),
    18: .same(proto: "affinity"),
    19: .same(proto: "schedulerName"),
    22: .same(proto: "tolerations"),
    23: .same(proto: "hostAliases"),
    24: .same(proto: "priorityClassName"),
    25: .same(proto: "priority"),
    26: .same(proto: "dnsConfig"),
    28: .same(proto: "readinessGates"),
    29: .same(proto: "runtimeClassName"),
    30: .same(proto: "enableServiceLinks"),
    31: .same(proto: "preemptionPolicy"),
    32: .same(proto: "overhead"),
    33: .same(proto: "topologySpreadConstraints"),
  ]

  fileprivate class _StorageClass {
    var _volumes: [K8s_Io_Api_Core_V1_Volume] = []
    var _initContainers: [K8s_Io_Api_Core_V1_Container] = []
    var _containers: [K8s_Io_Api_Core_V1_Container] = []
    var _ephemeralContainers: [K8s_Io_Api_Core_V1_EphemeralContainer] = []
    var _restartPolicy: String? = nil
    var _terminationGracePeriodSeconds: Int64? = nil
    var _activeDeadlineSeconds: Int64? = nil
    var _dnsPolicy: String? = nil
    var _nodeSelector: Dictionary<String,String> = [:]
    var _serviceAccountName: String? = nil
    var _serviceAccount: String? = nil
    var _automountServiceAccountToken: Bool? = nil
    var _nodeName: String? = nil
    var _hostNetwork: Bool? = nil
    var _hostPid: Bool? = nil
    var _hostIpc: Bool? = nil
    var _shareProcessNamespace: Bool? = nil
    var _securityContext: K8s_Io_Api_Core_V1_PodSecurityContext? = nil
    var _imagePullSecrets: [K8s_Io_Api_Core_V1_LocalObjectReference] = []
    var _hostname: String? = nil
    var _subdomain: String? = nil
    var _affinity: K8s_Io_Api_Core_V1_Affinity? = nil
    var _schedulerName: String? = nil
    var _tolerations: [K8s_Io_Api_Core_V1_Toleration] = []
    var _hostAliases: [K8s_Io_Api_Core_V1_HostAlias] = []
    var _priorityClassName: String? = nil
    var _priority: Int32? = nil
    var _dnsConfig: K8s_Io_Api_Core_V1_PodDNSConfig? = nil
    var _readinessGates: [K8s_Io_Api_Core_V1_PodReadinessGate] = []
    var _runtimeClassName: String? = nil
    var _enableServiceLinks: Bool? = nil
    var _preemptionPolicy: String? = nil
    var _overhead: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]
    var _topologySpreadConstraints: [K8s_Io_Api_Core_V1_TopologySpreadConstraint] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volumes = source._volumes
      _initContainers = source._initContainers
      _containers = source._containers
      _ephemeralContainers = source._ephemeralContainers
      _restartPolicy = source._restartPolicy
      _terminationGracePeriodSeconds = source._terminationGracePeriodSeconds
      _activeDeadlineSeconds = source._activeDeadlineSeconds
      _dnsPolicy = source._dnsPolicy
      _nodeSelector = source._nodeSelector
      _serviceAccountName = source._serviceAccountName
      _serviceAccount = source._serviceAccount
      _automountServiceAccountToken = source._automountServiceAccountToken
      _nodeName = source._nodeName
      _hostNetwork = source._hostNetwork
      _hostPid = source._hostPid
      _hostIpc = source._hostIpc
      _shareProcessNamespace = source._shareProcessNamespace
      _securityContext = source._securityContext
      _imagePullSecrets = source._imagePullSecrets
      _hostname = source._hostname
      _subdomain = source._subdomain
      _affinity = source._affinity
      _schedulerName = source._schedulerName
      _tolerations = source._tolerations
      _hostAliases = source._hostAliases
      _priorityClassName = source._priorityClassName
      _priority = source._priority
      _dnsConfig = source._dnsConfig
      _readinessGates = source._readinessGates
      _runtimeClassName = source._runtimeClassName
      _enableServiceLinks = source._enableServiceLinks
      _preemptionPolicy = source._preemptionPolicy
      _overhead = source._overhead
      _topologySpreadConstraints = source._topologySpreadConstraints
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._volumes)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._containers)
        case 3: try decoder.decodeSingularStringField(value: &_storage._restartPolicy)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._terminationGracePeriodSeconds)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._activeDeadlineSeconds)
        case 6: try decoder.decodeSingularStringField(value: &_storage._dnsPolicy)
        case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._nodeSelector)
        case 8: try decoder.decodeSingularStringField(value: &_storage._serviceAccountName)
        case 9: try decoder.decodeSingularStringField(value: &_storage._serviceAccount)
        case 10: try decoder.decodeSingularStringField(value: &_storage._nodeName)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._hostNetwork)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._hostPid)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._hostIpc)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._securityContext)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._imagePullSecrets)
        case 16: try decoder.decodeSingularStringField(value: &_storage._hostname)
        case 17: try decoder.decodeSingularStringField(value: &_storage._subdomain)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._affinity)
        case 19: try decoder.decodeSingularStringField(value: &_storage._schedulerName)
        case 20: try decoder.decodeRepeatedMessageField(value: &_storage._initContainers)
        case 21: try decoder.decodeSingularBoolField(value: &_storage._automountServiceAccountToken)
        case 22: try decoder.decodeRepeatedMessageField(value: &_storage._tolerations)
        case 23: try decoder.decodeRepeatedMessageField(value: &_storage._hostAliases)
        case 24: try decoder.decodeSingularStringField(value: &_storage._priorityClassName)
        case 25: try decoder.decodeSingularInt32Field(value: &_storage._priority)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._dnsConfig)
        case 27: try decoder.decodeSingularBoolField(value: &_storage._shareProcessNamespace)
        case 28: try decoder.decodeRepeatedMessageField(value: &_storage._readinessGates)
        case 29: try decoder.decodeSingularStringField(value: &_storage._runtimeClassName)
        case 30: try decoder.decodeSingularBoolField(value: &_storage._enableServiceLinks)
        case 31: try decoder.decodeSingularStringField(value: &_storage._preemptionPolicy)
        case 32: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &_storage._overhead)
        case 33: try decoder.decodeRepeatedMessageField(value: &_storage._topologySpreadConstraints)
        case 34: try decoder.decodeRepeatedMessageField(value: &_storage._ephemeralContainers)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._volumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumes, fieldNumber: 1)
      }
      if !_storage._containers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._containers, fieldNumber: 2)
      }
      if let v = _storage._restartPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._terminationGracePeriodSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._activeDeadlineSeconds {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._dnsPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if !_storage._nodeSelector.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._nodeSelector, fieldNumber: 7)
      }
      if let v = _storage._serviceAccountName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._serviceAccount {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._nodeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._hostNetwork {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if let v = _storage._hostPid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
      if let v = _storage._hostIpc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._securityContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._imagePullSecrets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._imagePullSecrets, fieldNumber: 15)
      }
      if let v = _storage._hostname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if let v = _storage._subdomain {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      }
      if let v = _storage._affinity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._schedulerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      }
      if !_storage._initContainers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._initContainers, fieldNumber: 20)
      }
      if let v = _storage._automountServiceAccountToken {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if !_storage._tolerations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tolerations, fieldNumber: 22)
      }
      if !_storage._hostAliases.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hostAliases, fieldNumber: 23)
      }
      if let v = _storage._priorityClassName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 24)
      }
      if let v = _storage._priority {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 25)
      }
      if let v = _storage._dnsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._shareProcessNamespace {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      }
      if !_storage._readinessGates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._readinessGates, fieldNumber: 28)
      }
      if let v = _storage._runtimeClassName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 29)
      }
      if let v = _storage._enableServiceLinks {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 30)
      }
      if let v = _storage._preemptionPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 31)
      }
      if !_storage._overhead.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: _storage._overhead, fieldNumber: 32)
      }
      if !_storage._topologySpreadConstraints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topologySpreadConstraints, fieldNumber: 33)
      }
      if !_storage._ephemeralContainers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ephemeralContainers, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodSpec, rhs: K8s_Io_Api_Core_V1_PodSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volumes != rhs_storage._volumes {return false}
        if _storage._initContainers != rhs_storage._initContainers {return false}
        if _storage._containers != rhs_storage._containers {return false}
        if _storage._ephemeralContainers != rhs_storage._ephemeralContainers {return false}
        if _storage._restartPolicy != rhs_storage._restartPolicy {return false}
        if _storage._terminationGracePeriodSeconds != rhs_storage._terminationGracePeriodSeconds {return false}
        if _storage._activeDeadlineSeconds != rhs_storage._activeDeadlineSeconds {return false}
        if _storage._dnsPolicy != rhs_storage._dnsPolicy {return false}
        if _storage._nodeSelector != rhs_storage._nodeSelector {return false}
        if _storage._serviceAccountName != rhs_storage._serviceAccountName {return false}
        if _storage._serviceAccount != rhs_storage._serviceAccount {return false}
        if _storage._automountServiceAccountToken != rhs_storage._automountServiceAccountToken {return false}
        if _storage._nodeName != rhs_storage._nodeName {return false}
        if _storage._hostNetwork != rhs_storage._hostNetwork {return false}
        if _storage._hostPid != rhs_storage._hostPid {return false}
        if _storage._hostIpc != rhs_storage._hostIpc {return false}
        if _storage._shareProcessNamespace != rhs_storage._shareProcessNamespace {return false}
        if _storage._securityContext != rhs_storage._securityContext {return false}
        if _storage._imagePullSecrets != rhs_storage._imagePullSecrets {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._subdomain != rhs_storage._subdomain {return false}
        if _storage._affinity != rhs_storage._affinity {return false}
        if _storage._schedulerName != rhs_storage._schedulerName {return false}
        if _storage._tolerations != rhs_storage._tolerations {return false}
        if _storage._hostAliases != rhs_storage._hostAliases {return false}
        if _storage._priorityClassName != rhs_storage._priorityClassName {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._dnsConfig != rhs_storage._dnsConfig {return false}
        if _storage._readinessGates != rhs_storage._readinessGates {return false}
        if _storage._runtimeClassName != rhs_storage._runtimeClassName {return false}
        if _storage._enableServiceLinks != rhs_storage._enableServiceLinks {return false}
        if _storage._preemptionPolicy != rhs_storage._preemptionPolicy {return false}
        if _storage._overhead != rhs_storage._overhead {return false}
        if _storage._topologySpreadConstraints != rhs_storage._topologySpreadConstraints {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phase"),
    2: .same(proto: "conditions"),
    3: .same(proto: "message"),
    4: .same(proto: "reason"),
    11: .same(proto: "nominatedNodeName"),
    5: .same(proto: "hostIP"),
    6: .same(proto: "podIP"),
    12: .same(proto: "podIPs"),
    7: .same(proto: "startTime"),
    10: .same(proto: "initContainerStatuses"),
    8: .same(proto: "containerStatuses"),
    9: .same(proto: "qosClass"),
    13: .same(proto: "ephemeralContainerStatuses"),
  ]

  fileprivate class _StorageClass {
    var _phase: String? = nil
    var _conditions: [K8s_Io_Api_Core_V1_PodCondition] = []
    var _message: String? = nil
    var _reason: String? = nil
    var _nominatedNodeName: String? = nil
    var _hostIp: String? = nil
    var _podIp: String? = nil
    var _podIps: [K8s_Io_Api_Core_V1_PodIP] = []
    var _startTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _initContainerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] = []
    var _containerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] = []
    var _qosClass: String? = nil
    var _ephemeralContainerStatuses: [K8s_Io_Api_Core_V1_ContainerStatus] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _phase = source._phase
      _conditions = source._conditions
      _message = source._message
      _reason = source._reason
      _nominatedNodeName = source._nominatedNodeName
      _hostIp = source._hostIp
      _podIp = source._podIp
      _podIps = source._podIps
      _startTime = source._startTime
      _initContainerStatuses = source._initContainerStatuses
      _containerStatuses = source._containerStatuses
      _qosClass = source._qosClass
      _ephemeralContainerStatuses = source._ephemeralContainerStatuses
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._phase)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._conditions)
        case 3: try decoder.decodeSingularStringField(value: &_storage._message)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._hostIp)
        case 6: try decoder.decodeSingularStringField(value: &_storage._podIp)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._startTime)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._containerStatuses)
        case 9: try decoder.decodeSingularStringField(value: &_storage._qosClass)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._initContainerStatuses)
        case 11: try decoder.decodeSingularStringField(value: &_storage._nominatedNodeName)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._podIps)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._ephemeralContainerStatuses)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._phase {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 2)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._hostIp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._podIp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._containerStatuses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._containerStatuses, fieldNumber: 8)
      }
      if let v = _storage._qosClass {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if !_storage._initContainerStatuses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._initContainerStatuses, fieldNumber: 10)
      }
      if let v = _storage._nominatedNodeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if !_storage._podIps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._podIps, fieldNumber: 12)
      }
      if !_storage._ephemeralContainerStatuses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ephemeralContainerStatuses, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodStatus, rhs: K8s_Io_Api_Core_V1_PodStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._phase != rhs_storage._phase {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._nominatedNodeName != rhs_storage._nominatedNodeName {return false}
        if _storage._hostIp != rhs_storage._hostIp {return false}
        if _storage._podIp != rhs_storage._podIp {return false}
        if _storage._podIps != rhs_storage._podIps {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._initContainerStatuses != rhs_storage._initContainerStatuses {return false}
        if _storage._containerStatuses != rhs_storage._containerStatuses {return false}
        if _storage._qosClass != rhs_storage._qosClass {return false}
        if _storage._ephemeralContainerStatuses != rhs_storage._ephemeralContainerStatuses {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodStatusResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _status: K8s_Io_Api_Core_V1_PodStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodStatusResult, rhs: K8s_Io_Api_Core_V1_PodStatusResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodTemplate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "template"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _template = source._template
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._template)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodTemplate, rhs: K8s_Io_Api_Core_V1_PodTemplate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._template != rhs_storage._template {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodTemplateList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodTemplateList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_PodTemplate] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodTemplateList, rhs: K8s_Io_Api_Core_V1_PodTemplateList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PodTemplateSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodTemplateSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_PodSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PodTemplateSpec, rhs: K8s_Io_Api_Core_V1_PodTemplateSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PortworxVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortworxVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeID"),
    2: .same(proto: "fsType"),
    3: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._volumeID)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._volumeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PortworxVolumeSource, rhs: K8s_Io_Api_Core_V1_PortworxVolumeSource) -> Bool {
    if lhs._volumeID != rhs._volumeID {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Preconditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preconditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._uid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Preconditions, rhs: K8s_Io_Api_Core_V1_Preconditions) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PreferAvoidPodsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreferAvoidPodsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podSignature"),
    2: .same(proto: "evictionTime"),
    3: .same(proto: "reason"),
    4: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _podSignature: K8s_Io_Api_Core_V1_PodSignature? = nil
    var _evictionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podSignature = source._podSignature
      _evictionTime = source._evictionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._podSignature)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._evictionTime)
        case 3: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 4: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._podSignature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._evictionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PreferAvoidPodsEntry, rhs: K8s_Io_Api_Core_V1_PreferAvoidPodsEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podSignature != rhs_storage._podSignature {return false}
        if _storage._evictionTime != rhs_storage._evictionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_PreferredSchedulingTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreferredSchedulingTerm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weight"),
    2: .same(proto: "preference"),
  ]

  fileprivate class _StorageClass {
    var _weight: Int32? = nil
    var _preference: K8s_Io_Api_Core_V1_NodeSelectorTerm? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _weight = source._weight
      _preference = source._preference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._weight)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._preference)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._weight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._preference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_PreferredSchedulingTerm, rhs: K8s_Io_Api_Core_V1_PreferredSchedulingTerm) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._weight != rhs_storage._weight {return false}
        if _storage._preference != rhs_storage._preference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Probe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handler"),
    2: .same(proto: "initialDelaySeconds"),
    3: .same(proto: "timeoutSeconds"),
    4: .same(proto: "periodSeconds"),
    5: .same(proto: "successThreshold"),
    6: .same(proto: "failureThreshold"),
  ]

  fileprivate class _StorageClass {
    var _handler: K8s_Io_Api_Core_V1_Handler? = nil
    var _initialDelaySeconds: Int32? = nil
    var _timeoutSeconds: Int32? = nil
    var _periodSeconds: Int32? = nil
    var _successThreshold: Int32? = nil
    var _failureThreshold: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _handler = source._handler
      _initialDelaySeconds = source._initialDelaySeconds
      _timeoutSeconds = source._timeoutSeconds
      _periodSeconds = source._periodSeconds
      _successThreshold = source._successThreshold
      _failureThreshold = source._failureThreshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._handler)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._initialDelaySeconds)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._periodSeconds)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._successThreshold)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._failureThreshold)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._handler {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._initialDelaySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._timeoutSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._periodSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._successThreshold {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._failureThreshold {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Probe, rhs: K8s_Io_Api_Core_V1_Probe) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._handler != rhs_storage._handler {return false}
        if _storage._initialDelaySeconds != rhs_storage._initialDelaySeconds {return false}
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._periodSeconds != rhs_storage._periodSeconds {return false}
        if _storage._successThreshold != rhs_storage._successThreshold {return false}
        if _storage._failureThreshold != rhs_storage._failureThreshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ProjectedVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProjectedVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sources"),
    2: .same(proto: "defaultMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sources)
      case 2: try decoder.decodeSingularInt32Field(value: &self._defaultMode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sources, fieldNumber: 1)
    }
    if let v = self._defaultMode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ProjectedVolumeSource, rhs: K8s_Io_Api_Core_V1_ProjectedVolumeSource) -> Bool {
    if lhs.sources != rhs.sources {return false}
    if lhs._defaultMode != rhs._defaultMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_QuobyteVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuobyteVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registry"),
    2: .same(proto: "volume"),
    3: .same(proto: "readOnly"),
    4: .same(proto: "user"),
    5: .same(proto: "group"),
    6: .same(proto: "tenant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._registry)
      case 2: try decoder.decodeSingularStringField(value: &self._volume)
      case 3: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 4: try decoder.decodeSingularStringField(value: &self._user)
      case 5: try decoder.decodeSingularStringField(value: &self._group)
      case 6: try decoder.decodeSingularStringField(value: &self._tenant)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._registry {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._volume {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._user {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._tenant {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_QuobyteVolumeSource, rhs: K8s_Io_Api_Core_V1_QuobyteVolumeSource) -> Bool {
    if lhs._registry != rhs._registry {return false}
    if lhs._volume != rhs._volume {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs._user != rhs._user {return false}
    if lhs._group != rhs._group {return false}
    if lhs._tenant != rhs._tenant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_RBDPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RBDPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monitors"),
    2: .same(proto: "image"),
    3: .same(proto: "fsType"),
    4: .same(proto: "pool"),
    5: .same(proto: "user"),
    6: .same(proto: "keyring"),
    7: .same(proto: "secretRef"),
    8: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _monitors: [String] = []
    var _image: String? = nil
    var _fsType: String? = nil
    var _pool: String? = nil
    var _user: String? = nil
    var _keyring: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _monitors = source._monitors
      _image = source._image
      _fsType = source._fsType
      _pool = source._pool
      _user = source._user
      _keyring = source._keyring
      _secretRef = source._secretRef
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._monitors)
        case 2: try decoder.decodeSingularStringField(value: &_storage._image)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 4: try decoder.decodeSingularStringField(value: &_storage._pool)
        case 5: try decoder.decodeSingularStringField(value: &_storage._user)
        case 6: try decoder.decodeSingularStringField(value: &_storage._keyring)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._monitors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._monitors, fieldNumber: 1)
      }
      if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._pool {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._keyring {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_RBDPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_RBDPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._monitors != rhs_storage._monitors {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._pool != rhs_storage._pool {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._keyring != rhs_storage._keyring {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_RBDVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RBDVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monitors"),
    2: .same(proto: "image"),
    3: .same(proto: "fsType"),
    4: .same(proto: "pool"),
    5: .same(proto: "user"),
    6: .same(proto: "keyring"),
    7: .same(proto: "secretRef"),
    8: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _monitors: [String] = []
    var _image: String? = nil
    var _fsType: String? = nil
    var _pool: String? = nil
    var _user: String? = nil
    var _keyring: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _monitors = source._monitors
      _image = source._image
      _fsType = source._fsType
      _pool = source._pool
      _user = source._user
      _keyring = source._keyring
      _secretRef = source._secretRef
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._monitors)
        case 2: try decoder.decodeSingularStringField(value: &_storage._image)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 4: try decoder.decodeSingularStringField(value: &_storage._pool)
        case 5: try decoder.decodeSingularStringField(value: &_storage._user)
        case 6: try decoder.decodeSingularStringField(value: &_storage._keyring)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._monitors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._monitors, fieldNumber: 1)
      }
      if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._pool {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._keyring {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_RBDVolumeSource, rhs: K8s_Io_Api_Core_V1_RBDVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._monitors != rhs_storage._monitors {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._pool != rhs_storage._pool {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._keyring != rhs_storage._keyring {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_RangeAllocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeAllocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "range"),
    3: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _range: String? = nil
    var _data: Data? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _range = source._range
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._range)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._range {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_RangeAllocation, rhs: K8s_Io_Api_Core_V1_RangeAllocation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._range != rhs_storage._range {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ReplicationController: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationController"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_ReplicationControllerSpec? = nil
    var _status: K8s_Io_Api_Core_V1_ReplicationControllerStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ReplicationController, rhs: K8s_Io_Api_Core_V1_ReplicationController) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ReplicationControllerCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationControllerCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ReplicationControllerCondition, rhs: K8s_Io_Api_Core_V1_ReplicationControllerCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ReplicationControllerList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationControllerList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_ReplicationController] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ReplicationControllerList, rhs: K8s_Io_Api_Core_V1_ReplicationControllerList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ReplicationControllerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationControllerSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    4: .same(proto: "minReadySeconds"),
    2: .same(proto: "selector"),
    3: .same(proto: "template"),
  ]

  fileprivate class _StorageClass {
    var _replicas: Int32? = nil
    var _minReadySeconds: Int32? = nil
    var _selector: Dictionary<String,String> = [:]
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicas = source._replicas
      _minReadySeconds = source._minReadySeconds
      _selector = source._selector
      _template = source._template
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._replicas)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._minReadySeconds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if !_storage._selector.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._selector, fieldNumber: 2)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._minReadySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ReplicationControllerSpec, rhs: K8s_Io_Api_Core_V1_ReplicationControllerSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._minReadySeconds != rhs_storage._minReadySeconds {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ReplicationControllerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplicationControllerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "fullyLabeledReplicas"),
    4: .same(proto: "readyReplicas"),
    5: .same(proto: "availableReplicas"),
    3: .same(proto: "observedGeneration"),
    6: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 2: try decoder.decodeSingularInt32Field(value: &self._fullyLabeledReplicas)
      case 3: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 4: try decoder.decodeSingularInt32Field(value: &self._readyReplicas)
      case 5: try decoder.decodeSingularInt32Field(value: &self._availableReplicas)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._fullyLabeledReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._readyReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._availableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ReplicationControllerStatus, rhs: K8s_Io_Api_Core_V1_ReplicationControllerStatus) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs._fullyLabeledReplicas != rhs._fullyLabeledReplicas {return false}
    if lhs._readyReplicas != rhs._readyReplicas {return false}
    if lhs._availableReplicas != rhs._availableReplicas {return false}
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceFieldSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceFieldSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "containerName"),
    2: .same(proto: "resource"),
    3: .same(proto: "divisor"),
  ]

  fileprivate class _StorageClass {
    var _containerName: String? = nil
    var _resource: String? = nil
    var _divisor: K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _containerName = source._containerName
      _resource = source._resource
      _divisor = source._divisor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._containerName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._resource)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._divisor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._containerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._resource {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._divisor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceFieldSelector, rhs: K8s_Io_Api_Core_V1_ResourceFieldSelector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._containerName != rhs_storage._containerName {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._divisor != rhs_storage._divisor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceQuota: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceQuota"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_ResourceQuotaSpec? = nil
    var _status: K8s_Io_Api_Core_V1_ResourceQuotaStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceQuota, rhs: K8s_Io_Api_Core_V1_ResourceQuota) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceQuotaList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceQuotaList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_ResourceQuota] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceQuotaList, rhs: K8s_Io_Api_Core_V1_ResourceQuotaList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceQuotaSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceQuotaSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hard"),
    2: .same(proto: "scopes"),
    3: .same(proto: "scopeSelector"),
  ]

  fileprivate class _StorageClass {
    var _hard: Dictionary<String,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity> = [:]
    var _scopes: [String] = []
    var _scopeSelector: K8s_Io_Api_Core_V1_ScopeSelector? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hard = source._hard
      _scopes = source._scopes
      _scopeSelector = source._scopeSelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &_storage._hard)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._scopes)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._scopeSelector)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hard.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: _storage._hard, fieldNumber: 1)
      }
      if !_storage._scopes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._scopes, fieldNumber: 2)
      }
      if let v = _storage._scopeSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceQuotaSpec, rhs: K8s_Io_Api_Core_V1_ResourceQuotaSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hard != rhs_storage._hard {return false}
        if _storage._scopes != rhs_storage._scopes {return false}
        if _storage._scopeSelector != rhs_storage._scopeSelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceQuotaStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceQuotaStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hard"),
    2: .same(proto: "used"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.hard)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.used)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hard.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.hard, fieldNumber: 1)
    }
    if !self.used.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.used, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceQuotaStatus, rhs: K8s_Io_Api_Core_V1_ResourceQuotaStatus) -> Bool {
    if lhs.hard != rhs.hard {return false}
    if lhs.used != rhs.used {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ResourceRequirements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceRequirements"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
    2: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.limits)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: &self.requests)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.limits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.limits, fieldNumber: 1)
    }
    if !self.requests.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Api_Resource_Quantity>.self, value: self.requests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ResourceRequirements, rhs: K8s_Io_Api_Core_V1_ResourceRequirements) -> Bool {
    if lhs.limits != rhs.limits {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SELinuxOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SELinuxOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "role"),
    3: .same(proto: "type"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._user)
      case 2: try decoder.decodeSingularStringField(value: &self._role)
      case 3: try decoder.decodeSingularStringField(value: &self._type)
      case 4: try decoder.decodeSingularStringField(value: &self._level)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._role {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._level {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SELinuxOptions, rhs: K8s_Io_Api_Core_V1_SELinuxOptions) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._role != rhs._role {return false}
    if lhs._type != rhs._type {return false}
    if lhs._level != rhs._level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleIOPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "system"),
    3: .same(proto: "secretRef"),
    4: .same(proto: "sslEnabled"),
    5: .same(proto: "protectionDomain"),
    6: .same(proto: "storagePool"),
    7: .same(proto: "storageMode"),
    8: .same(proto: "volumeName"),
    9: .same(proto: "fsType"),
    10: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _gateway: String? = nil
    var _system: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_SecretReference? = nil
    var _sslEnabled: Bool? = nil
    var _protectionDomain: String? = nil
    var _storagePool: String? = nil
    var _storageMode: String? = nil
    var _volumeName: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gateway = source._gateway
      _system = source._system
      _secretRef = source._secretRef
      _sslEnabled = source._sslEnabled
      _protectionDomain = source._protectionDomain
      _storagePool = source._storagePool
      _storageMode = source._storageMode
      _volumeName = source._volumeName
      _fsType = source._fsType
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._gateway)
        case 2: try decoder.decodeSingularStringField(value: &_storage._system)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._sslEnabled)
        case 5: try decoder.decodeSingularStringField(value: &_storage._protectionDomain)
        case 6: try decoder.decodeSingularStringField(value: &_storage._storagePool)
        case 7: try decoder.decodeSingularStringField(value: &_storage._storageMode)
        case 8: try decoder.decodeSingularStringField(value: &_storage._volumeName)
        case 9: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gateway {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._system {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._sslEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._protectionDomain {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._storagePool {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._storageMode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._volumeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_ScaleIOPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gateway != rhs_storage._gateway {return false}
        if _storage._system != rhs_storage._system {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._sslEnabled != rhs_storage._sslEnabled {return false}
        if _storage._protectionDomain != rhs_storage._protectionDomain {return false}
        if _storage._storagePool != rhs_storage._storagePool {return false}
        if _storage._storageMode != rhs_storage._storageMode {return false}
        if _storage._volumeName != rhs_storage._volumeName {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ScaleIOVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleIOVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "system"),
    3: .same(proto: "secretRef"),
    4: .same(proto: "sslEnabled"),
    5: .same(proto: "protectionDomain"),
    6: .same(proto: "storagePool"),
    7: .same(proto: "storageMode"),
    8: .same(proto: "volumeName"),
    9: .same(proto: "fsType"),
    10: .same(proto: "readOnly"),
  ]

  fileprivate class _StorageClass {
    var _gateway: String? = nil
    var _system: String? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _sslEnabled: Bool? = nil
    var _protectionDomain: String? = nil
    var _storagePool: String? = nil
    var _storageMode: String? = nil
    var _volumeName: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gateway = source._gateway
      _system = source._system
      _secretRef = source._secretRef
      _sslEnabled = source._sslEnabled
      _protectionDomain = source._protectionDomain
      _storagePool = source._storagePool
      _storageMode = source._storageMode
      _volumeName = source._volumeName
      _fsType = source._fsType
      _readOnly = source._readOnly
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._gateway)
        case 2: try decoder.decodeSingularStringField(value: &_storage._system)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._sslEnabled)
        case 5: try decoder.decodeSingularStringField(value: &_storage._protectionDomain)
        case 6: try decoder.decodeSingularStringField(value: &_storage._storagePool)
        case 7: try decoder.decodeSingularStringField(value: &_storage._storageMode)
        case 8: try decoder.decodeSingularStringField(value: &_storage._volumeName)
        case 9: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gateway {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._system {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._sslEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._protectionDomain {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._storagePool {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._storageMode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._volumeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ScaleIOVolumeSource, rhs: K8s_Io_Api_Core_V1_ScaleIOVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gateway != rhs_storage._gateway {return false}
        if _storage._system != rhs_storage._system {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        if _storage._sslEnabled != rhs_storage._sslEnabled {return false}
        if _storage._protectionDomain != rhs_storage._protectionDomain {return false}
        if _storage._storagePool != rhs_storage._storagePool {return false}
        if _storage._storageMode != rhs_storage._storageMode {return false}
        if _storage._volumeName != rhs_storage._volumeName {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ScopeSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopeSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matchExpressions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matchExpressions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchExpressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchExpressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ScopeSelector, rhs: K8s_Io_Api_Core_V1_ScopeSelector) -> Bool {
    if lhs.matchExpressions != rhs.matchExpressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ScopedResourceSelectorRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScopedResourceSelectorRequirement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scopeName"),
    2: .same(proto: "operator"),
    3: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._scopeName)
      case 2: try decoder.decodeSingularStringField(value: &self._operator)
      case 3: try decoder.decodeRepeatedStringField(value: &self.values)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scopeName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._operator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ScopedResourceSelectorRequirement, rhs: K8s_Io_Api_Core_V1_ScopedResourceSelectorRequirement) -> Bool {
    if lhs._scopeName != rhs._scopeName {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Secret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Secret"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "data"),
    4: .same(proto: "stringData"),
    3: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _data: Dictionary<String,Data> = [:]
    var _stringData: Dictionary<String,String> = [:]
    var _type: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _data = source._data
      _stringData = source._stringData
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &_storage._data)
        case 3: try decoder.decodeSingularStringField(value: &_storage._type)
        case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._stringData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._data.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: _storage._data, fieldNumber: 2)
      }
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._stringData.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._stringData, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Secret, rhs: K8s_Io_Api_Core_V1_Secret) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._stringData != rhs_storage._stringData {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretEnvSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretEnvSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretEnvSource, rhs: K8s_Io_Api_Core_V1_SecretEnvSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretKeySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretKeySelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "key"),
    3: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _key: String? = nil
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _key = source._key
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretKeySelector, rhs: K8s_Io_Api_Core_V1_SecretKeySelector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Secret] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretList, rhs: K8s_Io_Api_Core_V1_SecretList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretProjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localObjectReference"),
    2: .same(proto: "items"),
    4: .same(proto: "optional"),
  ]

  fileprivate class _StorageClass {
    var _localObjectReference: K8s_Io_Api_Core_V1_LocalObjectReference? = nil
    var _items: [K8s_Io_Api_Core_V1_KeyToPath] = []
    var _optional: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localObjectReference = source._localObjectReference
      _items = source._items
      _optional = source._optional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._localObjectReference)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._optional)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._localObjectReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
      if let v = _storage._optional {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretProjection, rhs: K8s_Io_Api_Core_V1_SecretProjection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localObjectReference != rhs_storage._localObjectReference {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._optional != rhs_storage._optional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._namespace)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretReference, rhs: K8s_Io_Api_Core_V1_SecretReference) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._namespace != rhs._namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecretVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secretName"),
    2: .same(proto: "items"),
    3: .same(proto: "defaultMode"),
    4: .same(proto: "optional"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._secretName)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.items)
      case 3: try decoder.decodeSingularInt32Field(value: &self._defaultMode)
      case 4: try decoder.decodeSingularBoolField(value: &self._optional)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._secretName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    if let v = self._defaultMode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._optional {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecretVolumeSource, rhs: K8s_Io_Api_Core_V1_SecretVolumeSource) -> Bool {
    if lhs._secretName != rhs._secretName {return false}
    if lhs.items != rhs.items {return false}
    if lhs._defaultMode != rhs._defaultMode {return false}
    if lhs._optional != rhs._optional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SecurityContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecurityContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capabilities"),
    2: .same(proto: "privileged"),
    3: .same(proto: "seLinuxOptions"),
    10: .same(proto: "windowsOptions"),
    4: .same(proto: "runAsUser"),
    8: .same(proto: "runAsGroup"),
    5: .same(proto: "runAsNonRoot"),
    6: .same(proto: "readOnlyRootFilesystem"),
    7: .same(proto: "allowPrivilegeEscalation"),
    9: .same(proto: "procMount"),
  ]

  fileprivate class _StorageClass {
    var _capabilities: K8s_Io_Api_Core_V1_Capabilities? = nil
    var _privileged: Bool? = nil
    var _seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions? = nil
    var _windowsOptions: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions? = nil
    var _runAsUser: Int64? = nil
    var _runAsGroup: Int64? = nil
    var _runAsNonRoot: Bool? = nil
    var _readOnlyRootFilesystem: Bool? = nil
    var _allowPrivilegeEscalation: Bool? = nil
    var _procMount: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _capabilities = source._capabilities
      _privileged = source._privileged
      _seLinuxOptions = source._seLinuxOptions
      _windowsOptions = source._windowsOptions
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _runAsNonRoot = source._runAsNonRoot
      _readOnlyRootFilesystem = source._readOnlyRootFilesystem
      _allowPrivilegeEscalation = source._allowPrivilegeEscalation
      _procMount = source._procMount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._capabilities)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._privileged)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._seLinuxOptions)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._runAsUser)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._runAsNonRoot)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readOnlyRootFilesystem)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._allowPrivilegeEscalation)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._runAsGroup)
        case 9: try decoder.decodeSingularStringField(value: &_storage._procMount)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._windowsOptions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._privileged {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._seLinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._runAsUser {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._runAsNonRoot {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if let v = _storage._readOnlyRootFilesystem {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._allowPrivilegeEscalation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._runAsGroup {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._procMount {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._windowsOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SecurityContext, rhs: K8s_Io_Api_Core_V1_SecurityContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._privileged != rhs_storage._privileged {return false}
        if _storage._seLinuxOptions != rhs_storage._seLinuxOptions {return false}
        if _storage._windowsOptions != rhs_storage._windowsOptions {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._runAsNonRoot != rhs_storage._runAsNonRoot {return false}
        if _storage._readOnlyRootFilesystem != rhs_storage._readOnlyRootFilesystem {return false}
        if _storage._allowPrivilegeEscalation != rhs_storage._allowPrivilegeEscalation {return false}
        if _storage._procMount != rhs_storage._procMount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SerializedReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SerializedReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reference"),
  ]

  fileprivate class _StorageClass {
    var _reference: K8s_Io_Api_Core_V1_ObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reference = source._reference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._reference)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SerializedReference, rhs: K8s_Io_Api_Core_V1_SerializedReference) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reference != rhs_storage._reference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Service"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Core_V1_ServiceSpec? = nil
    var _status: K8s_Io_Api_Core_V1_ServiceStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Service, rhs: K8s_Io_Api_Core_V1_Service) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "secrets"),
    3: .same(proto: "imagePullSecrets"),
    4: .same(proto: "automountServiceAccountToken"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _secrets: [K8s_Io_Api_Core_V1_ObjectReference] = []
    var _imagePullSecrets: [K8s_Io_Api_Core_V1_LocalObjectReference] = []
    var _automountServiceAccountToken: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _secrets = source._secrets
      _imagePullSecrets = source._imagePullSecrets
      _automountServiceAccountToken = source._automountServiceAccountToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._secrets)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._imagePullSecrets)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._automountServiceAccountToken)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._secrets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._secrets, fieldNumber: 2)
      }
      if !_storage._imagePullSecrets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._imagePullSecrets, fieldNumber: 3)
      }
      if let v = _storage._automountServiceAccountToken {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceAccount, rhs: K8s_Io_Api_Core_V1_ServiceAccount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._secrets != rhs_storage._secrets {return false}
        if _storage._imagePullSecrets != rhs_storage._imagePullSecrets {return false}
        if _storage._automountServiceAccountToken != rhs_storage._automountServiceAccountToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceAccountList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceAccountList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_ServiceAccount] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceAccountList, rhs: K8s_Io_Api_Core_V1_ServiceAccountList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceAccountTokenProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceAccountTokenProjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audience"),
    2: .same(proto: "expirationSeconds"),
    3: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._audience)
      case 2: try decoder.decodeSingularInt64Field(value: &self._expirationSeconds)
      case 3: try decoder.decodeSingularStringField(value: &self._path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._audience {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._expirationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceAccountTokenProjection, rhs: K8s_Io_Api_Core_V1_ServiceAccountTokenProjection) -> Bool {
    if lhs._audience != rhs._audience {return false}
    if lhs._expirationSeconds != rhs._expirationSeconds {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Core_V1_Service] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceList, rhs: K8s_Io_Api_Core_V1_ServiceList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServicePort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServicePort"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "protocol"),
    3: .same(proto: "port"),
    4: .same(proto: "targetPort"),
    5: .same(proto: "nodePort"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _protocol: String? = nil
    var _port: Int32? = nil
    var _targetPort: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _nodePort: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _protocol = source._protocol
      _port = source._port
      _targetPort = source._targetPort
      _nodePort = source._nodePort
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._protocol)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._port)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._targetPort)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._nodePort)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._protocol {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._port {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._targetPort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._nodePort {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServicePort, rhs: K8s_Io_Api_Core_V1_ServicePort) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._targetPort != rhs_storage._targetPort {return false}
        if _storage._nodePort != rhs_storage._nodePort {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceProxyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceProxyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceProxyOptions, rhs: K8s_Io_Api_Core_V1_ServiceProxyOptions) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
    2: .same(proto: "selector"),
    3: .same(proto: "clusterIP"),
    4: .same(proto: "type"),
    5: .same(proto: "externalIPs"),
    7: .same(proto: "sessionAffinity"),
    8: .same(proto: "loadBalancerIP"),
    9: .same(proto: "loadBalancerSourceRanges"),
    10: .same(proto: "externalName"),
    11: .same(proto: "externalTrafficPolicy"),
    12: .same(proto: "healthCheckNodePort"),
    13: .same(proto: "publishNotReadyAddresses"),
    14: .same(proto: "sessionAffinityConfig"),
    15: .same(proto: "ipFamily"),
  ]

  fileprivate class _StorageClass {
    var _ports: [K8s_Io_Api_Core_V1_ServicePort] = []
    var _selector: Dictionary<String,String> = [:]
    var _clusterIp: String? = nil
    var _type: String? = nil
    var _externalIps: [String] = []
    var _sessionAffinity: String? = nil
    var _loadBalancerIp: String? = nil
    var _loadBalancerSourceRanges: [String] = []
    var _externalName: String? = nil
    var _externalTrafficPolicy: String? = nil
    var _healthCheckNodePort: Int32? = nil
    var _publishNotReadyAddresses: Bool? = nil
    var _sessionAffinityConfig: K8s_Io_Api_Core_V1_SessionAffinityConfig? = nil
    var _ipFamily: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ports = source._ports
      _selector = source._selector
      _clusterIp = source._clusterIp
      _type = source._type
      _externalIps = source._externalIps
      _sessionAffinity = source._sessionAffinity
      _loadBalancerIp = source._loadBalancerIp
      _loadBalancerSourceRanges = source._loadBalancerSourceRanges
      _externalName = source._externalName
      _externalTrafficPolicy = source._externalTrafficPolicy
      _healthCheckNodePort = source._healthCheckNodePort
      _publishNotReadyAddresses = source._publishNotReadyAddresses
      _sessionAffinityConfig = source._sessionAffinityConfig
      _ipFamily = source._ipFamily
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._ports)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._selector)
        case 3: try decoder.decodeSingularStringField(value: &_storage._clusterIp)
        case 4: try decoder.decodeSingularStringField(value: &_storage._type)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._externalIps)
        case 7: try decoder.decodeSingularStringField(value: &_storage._sessionAffinity)
        case 8: try decoder.decodeSingularStringField(value: &_storage._loadBalancerIp)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._loadBalancerSourceRanges)
        case 10: try decoder.decodeSingularStringField(value: &_storage._externalName)
        case 11: try decoder.decodeSingularStringField(value: &_storage._externalTrafficPolicy)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._healthCheckNodePort)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._publishNotReadyAddresses)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._sessionAffinityConfig)
        case 15: try decoder.decodeSingularStringField(value: &_storage._ipFamily)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 1)
      }
      if !_storage._selector.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._selector, fieldNumber: 2)
      }
      if let v = _storage._clusterIp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._externalIps.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._externalIps, fieldNumber: 5)
      }
      if let v = _storage._sessionAffinity {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._loadBalancerIp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if !_storage._loadBalancerSourceRanges.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._loadBalancerSourceRanges, fieldNumber: 9)
      }
      if let v = _storage._externalName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._externalTrafficPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._healthCheckNodePort {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._publishNotReadyAddresses {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._sessionAffinityConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._ipFamily {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceSpec, rhs: K8s_Io_Api_Core_V1_ServiceSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._clusterIp != rhs_storage._clusterIp {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._externalIps != rhs_storage._externalIps {return false}
        if _storage._sessionAffinity != rhs_storage._sessionAffinity {return false}
        if _storage._loadBalancerIp != rhs_storage._loadBalancerIp {return false}
        if _storage._loadBalancerSourceRanges != rhs_storage._loadBalancerSourceRanges {return false}
        if _storage._externalName != rhs_storage._externalName {return false}
        if _storage._externalTrafficPolicy != rhs_storage._externalTrafficPolicy {return false}
        if _storage._healthCheckNodePort != rhs_storage._healthCheckNodePort {return false}
        if _storage._publishNotReadyAddresses != rhs_storage._publishNotReadyAddresses {return false}
        if _storage._sessionAffinityConfig != rhs_storage._sessionAffinityConfig {return false}
        if _storage._ipFamily != rhs_storage._ipFamily {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_ServiceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loadBalancer"),
  ]

  fileprivate class _StorageClass {
    var _loadBalancer: K8s_Io_Api_Core_V1_LoadBalancerStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _loadBalancer = source._loadBalancer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._loadBalancer)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._loadBalancer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_ServiceStatus, rhs: K8s_Io_Api_Core_V1_ServiceStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._loadBalancer != rhs_storage._loadBalancer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_SessionAffinityConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionAffinityConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientIP"),
  ]

  fileprivate class _StorageClass {
    var _clientIp: K8s_Io_Api_Core_V1_ClientIPConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clientIp = source._clientIp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._clientIp)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._clientIp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_SessionAffinityConfig, rhs: K8s_Io_Api_Core_V1_SessionAffinityConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientIp != rhs_storage._clientIp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageOSPersistentVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeName"),
    2: .same(proto: "volumeNamespace"),
    3: .same(proto: "fsType"),
    4: .same(proto: "readOnly"),
    5: .same(proto: "secretRef"),
  ]

  fileprivate class _StorageClass {
    var _volumeName: String? = nil
    var _volumeNamespace: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_ObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volumeName = source._volumeName
      _volumeNamespace = source._volumeNamespace
      _fsType = source._fsType
      _readOnly = source._readOnly
      _secretRef = source._secretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._volumeName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._volumeNamespace)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._volumeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._volumeNamespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource, rhs: K8s_Io_Api_Core_V1_StorageOSPersistentVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volumeName != rhs_storage._volumeName {return false}
        if _storage._volumeNamespace != rhs_storage._volumeNamespace {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_StorageOSVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageOSVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumeName"),
    2: .same(proto: "volumeNamespace"),
    3: .same(proto: "fsType"),
    4: .same(proto: "readOnly"),
    5: .same(proto: "secretRef"),
  ]

  fileprivate class _StorageClass {
    var _volumeName: String? = nil
    var _volumeNamespace: String? = nil
    var _fsType: String? = nil
    var _readOnly: Bool? = nil
    var _secretRef: K8s_Io_Api_Core_V1_LocalObjectReference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volumeName = source._volumeName
      _volumeNamespace = source._volumeNamespace
      _fsType = source._fsType
      _readOnly = source._readOnly
      _secretRef = source._secretRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._volumeName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._volumeNamespace)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fsType)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._secretRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._volumeName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._volumeNamespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fsType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._readOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._secretRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_StorageOSVolumeSource, rhs: K8s_Io_Api_Core_V1_StorageOSVolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volumeName != rhs_storage._volumeName {return false}
        if _storage._volumeNamespace != rhs_storage._volumeNamespace {return false}
        if _storage._fsType != rhs_storage._fsType {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._secretRef != rhs_storage._secretRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Sysctl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sysctl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Sysctl, rhs: K8s_Io_Api_Core_V1_Sysctl) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_TCPSocketAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TCPSocketAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "host"),
  ]

  fileprivate class _StorageClass {
    var _port: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _host: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _port = source._port
      _host = source._host
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._port)
        case 2: try decoder.decodeSingularStringField(value: &_storage._host)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._port {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._host {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_TCPSocketAction, rhs: K8s_Io_Api_Core_V1_TCPSocketAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._port != rhs_storage._port {return false}
        if _storage._host != rhs_storage._host {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Taint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Taint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "effect"),
    4: .same(proto: "timeAdded"),
  ]

  fileprivate class _StorageClass {
    var _key: String? = nil
    var _value: String? = nil
    var _effect: String? = nil
    var _timeAdded: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
      _effect = source._effect
      _timeAdded = source._timeAdded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._value)
        case 3: try decoder.decodeSingularStringField(value: &_storage._effect)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._timeAdded)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._effect {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timeAdded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Taint, rhs: K8s_Io_Api_Core_V1_Taint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._effect != rhs_storage._effect {return false}
        if _storage._timeAdded != rhs_storage._timeAdded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Toleration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Toleration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "operator"),
    3: .same(proto: "value"),
    4: .same(proto: "effect"),
    5: .same(proto: "tolerationSeconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeSingularStringField(value: &self._operator)
      case 3: try decoder.decodeSingularStringField(value: &self._value)
      case 4: try decoder.decodeSingularStringField(value: &self._effect)
      case 5: try decoder.decodeSingularInt64Field(value: &self._tolerationSeconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._operator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._effect {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._tolerationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Toleration, rhs: K8s_Io_Api_Core_V1_Toleration) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs._value != rhs._value {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs._tolerationSeconds != rhs._tolerationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_TopologySelectorLabelRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopologySelectorLabelRequirement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._key)
      case 2: try decoder.decodeRepeatedStringField(value: &self.values)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_TopologySelectorLabelRequirement, rhs: K8s_Io_Api_Core_V1_TopologySelectorLabelRequirement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_TopologySelectorTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopologySelectorTerm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matchLabelExpressions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matchLabelExpressions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchLabelExpressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchLabelExpressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_TopologySelectorTerm, rhs: K8s_Io_Api_Core_V1_TopologySelectorTerm) -> Bool {
    if lhs.matchLabelExpressions != rhs.matchLabelExpressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_TopologySpreadConstraint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopologySpreadConstraint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxSkew"),
    2: .same(proto: "topologyKey"),
    3: .same(proto: "whenUnsatisfiable"),
    4: .same(proto: "labelSelector"),
  ]

  fileprivate class _StorageClass {
    var _maxSkew: Int32? = nil
    var _topologyKey: String? = nil
    var _whenUnsatisfiable: String? = nil
    var _labelSelector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxSkew = source._maxSkew
      _topologyKey = source._topologyKey
      _whenUnsatisfiable = source._whenUnsatisfiable
      _labelSelector = source._labelSelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._maxSkew)
        case 2: try decoder.decodeSingularStringField(value: &_storage._topologyKey)
        case 3: try decoder.decodeSingularStringField(value: &_storage._whenUnsatisfiable)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._labelSelector)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxSkew {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._topologyKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._whenUnsatisfiable {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._labelSelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_TopologySpreadConstraint, rhs: K8s_Io_Api_Core_V1_TopologySpreadConstraint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxSkew != rhs_storage._maxSkew {return false}
        if _storage._topologyKey != rhs_storage._topologyKey {return false}
        if _storage._whenUnsatisfiable != rhs_storage._whenUnsatisfiable {return false}
        if _storage._labelSelector != rhs_storage._labelSelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_TypedLocalObjectReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypedLocalObjectReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apiGroup"),
    2: .same(proto: "kind"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._apiGroup)
      case 2: try decoder.decodeSingularStringField(value: &self._kind)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._apiGroup {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_TypedLocalObjectReference, rhs: K8s_Io_Api_Core_V1_TypedLocalObjectReference) -> Bool {
    if lhs._apiGroup != rhs._apiGroup {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_Volume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Volume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "volumeSource"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _volumeSource: K8s_Io_Api_Core_V1_VolumeSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _volumeSource = source._volumeSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._volumeSource)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._volumeSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_Volume, rhs: K8s_Io_Api_Core_V1_Volume) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._volumeSource != rhs_storage._volumeSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VolumeDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "devicePath"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._devicePath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._devicePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VolumeDevice, rhs: K8s_Io_Api_Core_V1_VolumeDevice) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._devicePath != rhs._devicePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VolumeMount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeMount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "readOnly"),
    3: .same(proto: "mountPath"),
    4: .same(proto: "subPath"),
    5: .same(proto: "mountPropagation"),
    6: .same(proto: "subPathExpr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularBoolField(value: &self._readOnly)
      case 3: try decoder.decodeSingularStringField(value: &self._mountPath)
      case 4: try decoder.decodeSingularStringField(value: &self._subPath)
      case 5: try decoder.decodeSingularStringField(value: &self._mountPropagation)
      case 6: try decoder.decodeSingularStringField(value: &self._subPathExpr)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._mountPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._subPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._mountPropagation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._subPathExpr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VolumeMount, rhs: K8s_Io_Api_Core_V1_VolumeMount) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs._mountPath != rhs._mountPath {return false}
    if lhs._subPath != rhs._subPath {return false}
    if lhs._mountPropagation != rhs._mountPropagation {return false}
    if lhs._subPathExpr != rhs._subPathExpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VolumeNodeAffinity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeNodeAffinity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
  ]

  fileprivate class _StorageClass {
    var _required: K8s_Io_Api_Core_V1_NodeSelector? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _required = source._required
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._required)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._required {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VolumeNodeAffinity, rhs: K8s_Io_Api_Core_V1_VolumeNodeAffinity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._required != rhs_storage._required {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VolumeProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeProjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secret"),
    2: .same(proto: "downwardAPI"),
    3: .same(proto: "configMap"),
    4: .same(proto: "serviceAccountToken"),
  ]

  fileprivate class _StorageClass {
    var _secret: K8s_Io_Api_Core_V1_SecretProjection? = nil
    var _downwardApi: K8s_Io_Api_Core_V1_DownwardAPIProjection? = nil
    var _configMap: K8s_Io_Api_Core_V1_ConfigMapProjection? = nil
    var _serviceAccountToken: K8s_Io_Api_Core_V1_ServiceAccountTokenProjection? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _secret = source._secret
      _downwardApi = source._downwardApi
      _configMap = source._configMap
      _serviceAccountToken = source._serviceAccountToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._secret)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._downwardApi)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configMap)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._serviceAccountToken)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._secret {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._downwardApi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._configMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._serviceAccountToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VolumeProjection, rhs: K8s_Io_Api_Core_V1_VolumeProjection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._secret != rhs_storage._secret {return false}
        if _storage._downwardApi != rhs_storage._downwardApi {return false}
        if _storage._configMap != rhs_storage._configMap {return false}
        if _storage._serviceAccountToken != rhs_storage._serviceAccountToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostPath"),
    2: .same(proto: "emptyDir"),
    3: .same(proto: "gcePersistentDisk"),
    4: .same(proto: "awsElasticBlockStore"),
    5: .same(proto: "gitRepo"),
    6: .same(proto: "secret"),
    7: .same(proto: "nfs"),
    8: .same(proto: "iscsi"),
    9: .same(proto: "glusterfs"),
    10: .same(proto: "persistentVolumeClaim"),
    11: .same(proto: "rbd"),
    12: .same(proto: "flexVolume"),
    13: .same(proto: "cinder"),
    14: .same(proto: "cephfs"),
    15: .same(proto: "flocker"),
    16: .same(proto: "downwardAPI"),
    17: .same(proto: "fc"),
    18: .same(proto: "azureFile"),
    19: .same(proto: "configMap"),
    20: .same(proto: "vsphereVolume"),
    21: .same(proto: "quobyte"),
    22: .same(proto: "azureDisk"),
    23: .same(proto: "photonPersistentDisk"),
    26: .same(proto: "projected"),
    24: .same(proto: "portworxVolume"),
    25: .same(proto: "scaleIO"),
    27: .same(proto: "storageos"),
    28: .same(proto: "csi"),
  ]

  fileprivate class _StorageClass {
    var _hostPath: K8s_Io_Api_Core_V1_HostPathVolumeSource? = nil
    var _emptyDir: K8s_Io_Api_Core_V1_EmptyDirVolumeSource? = nil
    var _gcePersistentDisk: K8s_Io_Api_Core_V1_GCEPersistentDiskVolumeSource? = nil
    var _awsElasticBlockStore: K8s_Io_Api_Core_V1_AWSElasticBlockStoreVolumeSource? = nil
    var _gitRepo: K8s_Io_Api_Core_V1_GitRepoVolumeSource? = nil
    var _secret: K8s_Io_Api_Core_V1_SecretVolumeSource? = nil
    var _nfs: K8s_Io_Api_Core_V1_NFSVolumeSource? = nil
    var _iscsi: K8s_Io_Api_Core_V1_ISCSIVolumeSource? = nil
    var _glusterfs: K8s_Io_Api_Core_V1_GlusterfsVolumeSource? = nil
    var _persistentVolumeClaim: K8s_Io_Api_Core_V1_PersistentVolumeClaimVolumeSource? = nil
    var _rbd: K8s_Io_Api_Core_V1_RBDVolumeSource? = nil
    var _flexVolume: K8s_Io_Api_Core_V1_FlexVolumeSource? = nil
    var _cinder: K8s_Io_Api_Core_V1_CinderVolumeSource? = nil
    var _cephfs: K8s_Io_Api_Core_V1_CephFSVolumeSource? = nil
    var _flocker: K8s_Io_Api_Core_V1_FlockerVolumeSource? = nil
    var _downwardApi: K8s_Io_Api_Core_V1_DownwardAPIVolumeSource? = nil
    var _fc: K8s_Io_Api_Core_V1_FCVolumeSource? = nil
    var _azureFile: K8s_Io_Api_Core_V1_AzureFileVolumeSource? = nil
    var _configMap: K8s_Io_Api_Core_V1_ConfigMapVolumeSource? = nil
    var _vsphereVolume: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource? = nil
    var _quobyte: K8s_Io_Api_Core_V1_QuobyteVolumeSource? = nil
    var _azureDisk: K8s_Io_Api_Core_V1_AzureDiskVolumeSource? = nil
    var _photonPersistentDisk: K8s_Io_Api_Core_V1_PhotonPersistentDiskVolumeSource? = nil
    var _projected: K8s_Io_Api_Core_V1_ProjectedVolumeSource? = nil
    var _portworxVolume: K8s_Io_Api_Core_V1_PortworxVolumeSource? = nil
    var _scaleIo: K8s_Io_Api_Core_V1_ScaleIOVolumeSource? = nil
    var _storageos: K8s_Io_Api_Core_V1_StorageOSVolumeSource? = nil
    var _csi: K8s_Io_Api_Core_V1_CSIVolumeSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hostPath = source._hostPath
      _emptyDir = source._emptyDir
      _gcePersistentDisk = source._gcePersistentDisk
      _awsElasticBlockStore = source._awsElasticBlockStore
      _gitRepo = source._gitRepo
      _secret = source._secret
      _nfs = source._nfs
      _iscsi = source._iscsi
      _glusterfs = source._glusterfs
      _persistentVolumeClaim = source._persistentVolumeClaim
      _rbd = source._rbd
      _flexVolume = source._flexVolume
      _cinder = source._cinder
      _cephfs = source._cephfs
      _flocker = source._flocker
      _downwardApi = source._downwardApi
      _fc = source._fc
      _azureFile = source._azureFile
      _configMap = source._configMap
      _vsphereVolume = source._vsphereVolume
      _quobyte = source._quobyte
      _azureDisk = source._azureDisk
      _photonPersistentDisk = source._photonPersistentDisk
      _projected = source._projected
      _portworxVolume = source._portworxVolume
      _scaleIo = source._scaleIo
      _storageos = source._storageos
      _csi = source._csi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hostPath)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._emptyDir)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._gcePersistentDisk)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._awsElasticBlockStore)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._gitRepo)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._secret)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._nfs)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._iscsi)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._glusterfs)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._persistentVolumeClaim)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._rbd)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._flexVolume)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._cinder)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._cephfs)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._flocker)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._downwardApi)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._fc)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._azureFile)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._configMap)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._vsphereVolume)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._quobyte)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._azureDisk)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._photonPersistentDisk)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._portworxVolume)
        case 25: try decoder.decodeSingularMessageField(value: &_storage._scaleIo)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._projected)
        case 27: try decoder.decodeSingularMessageField(value: &_storage._storageos)
        case 28: try decoder.decodeSingularMessageField(value: &_storage._csi)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hostPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._emptyDir {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._gcePersistentDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._awsElasticBlockStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._gitRepo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._secret {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._nfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._iscsi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._glusterfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._persistentVolumeClaim {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._rbd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._flexVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._cinder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._cephfs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._flocker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._downwardApi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._fc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._azureFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._configMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._vsphereVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._quobyte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._azureDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._photonPersistentDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._portworxVolume {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._scaleIo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if let v = _storage._projected {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._storageos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._csi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VolumeSource, rhs: K8s_Io_Api_Core_V1_VolumeSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hostPath != rhs_storage._hostPath {return false}
        if _storage._emptyDir != rhs_storage._emptyDir {return false}
        if _storage._gcePersistentDisk != rhs_storage._gcePersistentDisk {return false}
        if _storage._awsElasticBlockStore != rhs_storage._awsElasticBlockStore {return false}
        if _storage._gitRepo != rhs_storage._gitRepo {return false}
        if _storage._secret != rhs_storage._secret {return false}
        if _storage._nfs != rhs_storage._nfs {return false}
        if _storage._iscsi != rhs_storage._iscsi {return false}
        if _storage._glusterfs != rhs_storage._glusterfs {return false}
        if _storage._persistentVolumeClaim != rhs_storage._persistentVolumeClaim {return false}
        if _storage._rbd != rhs_storage._rbd {return false}
        if _storage._flexVolume != rhs_storage._flexVolume {return false}
        if _storage._cinder != rhs_storage._cinder {return false}
        if _storage._cephfs != rhs_storage._cephfs {return false}
        if _storage._flocker != rhs_storage._flocker {return false}
        if _storage._downwardApi != rhs_storage._downwardApi {return false}
        if _storage._fc != rhs_storage._fc {return false}
        if _storage._azureFile != rhs_storage._azureFile {return false}
        if _storage._configMap != rhs_storage._configMap {return false}
        if _storage._vsphereVolume != rhs_storage._vsphereVolume {return false}
        if _storage._quobyte != rhs_storage._quobyte {return false}
        if _storage._azureDisk != rhs_storage._azureDisk {return false}
        if _storage._photonPersistentDisk != rhs_storage._photonPersistentDisk {return false}
        if _storage._projected != rhs_storage._projected {return false}
        if _storage._portworxVolume != rhs_storage._portworxVolume {return false}
        if _storage._scaleIo != rhs_storage._scaleIo {return false}
        if _storage._storageos != rhs_storage._storageos {return false}
        if _storage._csi != rhs_storage._csi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VsphereVirtualDiskVolumeSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volumePath"),
    2: .same(proto: "fsType"),
    3: .same(proto: "storagePolicyName"),
    4: .same(proto: "storagePolicyID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._volumePath)
      case 2: try decoder.decodeSingularStringField(value: &self._fsType)
      case 3: try decoder.decodeSingularStringField(value: &self._storagePolicyName)
      case 4: try decoder.decodeSingularStringField(value: &self._storagePolicyID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._volumePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fsType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._storagePolicyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._storagePolicyID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource, rhs: K8s_Io_Api_Core_V1_VsphereVirtualDiskVolumeSource) -> Bool {
    if lhs._volumePath != rhs._volumePath {return false}
    if lhs._fsType != rhs._fsType {return false}
    if lhs._storagePolicyName != rhs._storagePolicyName {return false}
    if lhs._storagePolicyID != rhs._storagePolicyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_WeightedPodAffinityTerm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeightedPodAffinityTerm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weight"),
    2: .same(proto: "podAffinityTerm"),
  ]

  fileprivate class _StorageClass {
    var _weight: Int32? = nil
    var _podAffinityTerm: K8s_Io_Api_Core_V1_PodAffinityTerm? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _weight = source._weight
      _podAffinityTerm = source._podAffinityTerm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._weight)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._podAffinityTerm)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._weight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._podAffinityTerm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_WeightedPodAffinityTerm, rhs: K8s_Io_Api_Core_V1_WeightedPodAffinityTerm) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._weight != rhs_storage._weight {return false}
        if _storage._podAffinityTerm != rhs_storage._podAffinityTerm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Core_V1_WindowsSecurityContextOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsSecurityContextOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gmsaCredentialSpecName"),
    2: .same(proto: "gmsaCredentialSpec"),
    3: .same(proto: "runAsUserName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._gmsaCredentialSpecName)
      case 2: try decoder.decodeSingularStringField(value: &self._gmsaCredentialSpec)
      case 3: try decoder.decodeSingularStringField(value: &self._runAsUserName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gmsaCredentialSpecName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._gmsaCredentialSpec {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._runAsUserName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions, rhs: K8s_Io_Api_Core_V1_WindowsSecurityContextOptions) -> Bool {
    if lhs._gmsaCredentialSpecName != rhs._gmsaCredentialSpecName {return false}
    if lhs._gmsaCredentialSpec != rhs._gmsaCredentialSpec {return false}
    if lhs._runAsUserName != rhs._runAsUserName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
