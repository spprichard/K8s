// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/rbac/v1alpha1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
struct K8s_Io_Api_Rbac_V1alpha1_AggregationRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules.
  /// If any of the selectors match, then the ClusterRole's permissions will be added
  /// +optional
  var clusterRoleSelectors: [K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRole, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_ClusterRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Rules holds all the PolicyRules for this ClusterRole
  /// +optional
  var rules: [K8s_Io_Api_Rbac_V1alpha1_PolicyRule] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  /// AggregationRule is an optional field that describes how to build the Rules for this ClusterRole.
  /// If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be
  /// stomped by the controller.
  /// +optional
  var aggregationRule: K8s_Io_Api_Rbac_V1alpha1_AggregationRule {
    get {return _storage._aggregationRule ?? K8s_Io_Api_Rbac_V1alpha1_AggregationRule()}
    set {_uniqueStorage()._aggregationRule = newValue}
  }
  /// Returns true if `aggregationRule` has been explicitly set.
  var hasAggregationRule: Bool {return _storage._aggregationRule != nil}
  /// Clears the value of `aggregationRule`. Subsequent reads from it will return its default value.
  mutating func clearAggregationRule() {_uniqueStorage()._aggregationRule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,
/// and adds who information via Subject.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBinding, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Subjects holds references to the objects the role applies to.
  /// +optional
  var subjects: [K8s_Io_Api_Rbac_V1alpha1_Subject] {
    get {return _storage._subjects}
    set {_uniqueStorage()._subjects = newValue}
  }

  /// RoleRef can only reference a ClusterRole in the global namespace.
  /// If the RoleRef cannot be resolved, the Authorizer must return an error.
  var roleRef: K8s_Io_Api_Rbac_V1alpha1_RoleRef {
    get {return _storage._roleRef ?? K8s_Io_Api_Rbac_V1alpha1_RoleRef()}
    set {_uniqueStorage()._roleRef = newValue}
  }
  /// Returns true if `roleRef` has been explicitly set.
  var hasRoleRef: Bool {return _storage._roleRef != nil}
  /// Clears the value of `roleRef`. Subsequent reads from it will return its default value.
  mutating func clearRoleRef() {_uniqueStorage()._roleRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClusterRoleBindingList is a collection of ClusterRoleBindings.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoleBindings, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBindingList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of ClusterRoleBindings
  var items: [K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClusterRoleList is a collection of ClusterRoles.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 ClusterRoles, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_ClusterRoleList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of ClusterRoles
  var items: [K8s_Io_Api_Rbac_V1alpha1_ClusterRole] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PolicyRule holds information that describes a policy rule, but does not contain information
/// about who the rule applies to or which namespace the rule applies to.
struct K8s_Io_Api_Rbac_V1alpha1_PolicyRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule.  VerbAll represents all kinds.
  var verbs: [String] = []

  /// APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
  /// the enumerated resources in any API group will be allowed.
  /// +optional
  var apiGroups: [String] = []

  /// Resources is a list of resources this rule applies to.  ResourceAll represents all resources.
  /// +optional
  var resources: [String] = []

  /// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
  /// +optional
  var resourceNames: [String] = []

  /// NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
  /// This name is intentionally different than the internal type so that the DefaultConvert works nicely and because the ordering may be different.
  /// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
  /// Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
  /// +optional
  var nonResourceUrls: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 Role, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_Role {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Rules holds all the PolicyRules for this Role
  /// +optional
  var rules: [K8s_Io_Api_Rbac_V1alpha1_PolicyRule] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
/// It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given
/// namespace only have effect in that namespace.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleBinding, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_RoleBinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Subjects holds references to the objects the role applies to.
  /// +optional
  var subjects: [K8s_Io_Api_Rbac_V1alpha1_Subject] {
    get {return _storage._subjects}
    set {_uniqueStorage()._subjects = newValue}
  }

  /// RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
  /// If the RoleRef cannot be resolved, the Authorizer must return an error.
  var roleRef: K8s_Io_Api_Rbac_V1alpha1_RoleRef {
    get {return _storage._roleRef ?? K8s_Io_Api_Rbac_V1alpha1_RoleRef()}
    set {_uniqueStorage()._roleRef = newValue}
  }
  /// Returns true if `roleRef` has been explicitly set.
  var hasRoleRef: Bool {return _storage._roleRef != nil}
  /// Clears the value of `roleRef`. Subsequent reads from it will return its default value.
  mutating func clearRoleRef() {_uniqueStorage()._roleRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleBindingList is a collection of RoleBindings
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleBindingList, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_RoleBindingList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of RoleBindings
  var items: [K8s_Io_Api_Rbac_V1alpha1_RoleBinding] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleList is a collection of Roles.
/// Deprecated in v1.17 in favor of rbac.authorization.k8s.io/v1 RoleList, and will no longer be served in v1.20.
struct K8s_Io_Api_Rbac_V1alpha1_RoleList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is a list of Roles
  var items: [K8s_Io_Api_Rbac_V1alpha1_Role] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleRef contains information that points to the role being used
struct K8s_Io_Api_Rbac_V1alpha1_RoleRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// APIGroup is the group for the resource being referenced
  var apiGroup: String {
    get {return _apiGroup ?? String()}
    set {_apiGroup = newValue}
  }
  /// Returns true if `apiGroup` has been explicitly set.
  var hasApiGroup: Bool {return self._apiGroup != nil}
  /// Clears the value of `apiGroup`. Subsequent reads from it will return its default value.
  mutating func clearApiGroup() {self._apiGroup = nil}

  /// Kind is the type of resource being referenced
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// Name is the name of resource being referenced
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _apiGroup: String? = nil
  fileprivate var _kind: String? = nil
  fileprivate var _name: String? = nil
}

/// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
/// or a value for non-objects such as user and group names.
struct K8s_Io_Api_Rbac_V1alpha1_Subject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
  /// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  var kind: String {
    get {return _kind ?? String()}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  /// APIVersion holds the API group and version of the referenced subject.
  /// Defaults to "v1" for ServiceAccount subjects.
  /// Defaults to "rbac.authorization.k8s.io/v1alpha1" for User and Group subjects.
  /// +k8s:conversion-gen=false
  /// +optional
  var apiVersion: String {
    get {return _apiVersion ?? String()}
    set {_apiVersion = newValue}
  }
  /// Returns true if `apiVersion` has been explicitly set.
  var hasApiVersion: Bool {return self._apiVersion != nil}
  /// Clears the value of `apiVersion`. Subsequent reads from it will return its default value.
  mutating func clearApiVersion() {self._apiVersion = nil}

  /// Name of the object being referenced.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
  /// the Authorizer should report an error.
  /// +optional
  var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  mutating func clearNamespace() {self._namespace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _kind: String? = nil
  fileprivate var _apiVersion: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _namespace: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.rbac.v1alpha1"

extension K8s_Io_Api_Rbac_V1alpha1_AggregationRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AggregationRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusterRoleSelectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.clusterRoleSelectors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterRoleSelectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusterRoleSelectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_AggregationRule, rhs: K8s_Io_Api_Rbac_V1alpha1_AggregationRule) -> Bool {
    if lhs.clusterRoleSelectors != rhs.clusterRoleSelectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_ClusterRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "rules"),
    3: .same(proto: "aggregationRule"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _rules: [K8s_Io_Api_Rbac_V1alpha1_PolicyRule] = []
    var _aggregationRule: K8s_Io_Api_Rbac_V1alpha1_AggregationRule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _rules = source._rules
      _aggregationRule = source._aggregationRule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._rules)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._aggregationRule)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 2)
      }
      if let v = _storage._aggregationRule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRole, rhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRole) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._rules != rhs_storage._rules {return false}
        if _storage._aggregationRule != rhs_storage._aggregationRule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterRoleBinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "subjects"),
    3: .same(proto: "roleRef"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _subjects: [K8s_Io_Api_Rbac_V1alpha1_Subject] = []
    var _roleRef: K8s_Io_Api_Rbac_V1alpha1_RoleRef? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _subjects = source._subjects
      _roleRef = source._roleRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._subjects)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roleRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._subjects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subjects, fieldNumber: 2)
      }
      if let v = _storage._roleRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding, rhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._subjects != rhs_storage._subjects {return false}
        if _storage._roleRef != rhs_storage._roleRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBindingList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterRoleBindingList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBinding] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBindingList, rhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleBindingList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_ClusterRoleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterRoleList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Rbac_V1alpha1_ClusterRole] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleList, rhs: K8s_Io_Api_Rbac_V1alpha1_ClusterRoleList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_PolicyRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbs"),
    3: .same(proto: "apiGroups"),
    4: .same(proto: "resources"),
    5: .same(proto: "resourceNames"),
    6: .same(proto: "nonResourceURLs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.verbs)
      case 3: try decoder.decodeRepeatedStringField(value: &self.apiGroups)
      case 4: try decoder.decodeRepeatedStringField(value: &self.resources)
      case 5: try decoder.decodeRepeatedStringField(value: &self.resourceNames)
      case 6: try decoder.decodeRepeatedStringField(value: &self.nonResourceUrls)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.verbs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.verbs, fieldNumber: 1)
    }
    if !self.apiGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.apiGroups, fieldNumber: 3)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resources, fieldNumber: 4)
    }
    if !self.resourceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceNames, fieldNumber: 5)
    }
    if !self.nonResourceUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nonResourceUrls, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_PolicyRule, rhs: K8s_Io_Api_Rbac_V1alpha1_PolicyRule) -> Bool {
    if lhs.verbs != rhs.verbs {return false}
    if lhs.apiGroups != rhs.apiGroups {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.resourceNames != rhs.resourceNames {return false}
    if lhs.nonResourceUrls != rhs.nonResourceUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_Role: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Role"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "rules"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _rules: [K8s_Io_Api_Rbac_V1alpha1_PolicyRule] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _rules = source._rules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._rules)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_Role, rhs: K8s_Io_Api_Rbac_V1alpha1_Role) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._rules != rhs_storage._rules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_RoleBinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleBinding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "subjects"),
    3: .same(proto: "roleRef"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _subjects: [K8s_Io_Api_Rbac_V1alpha1_Subject] = []
    var _roleRef: K8s_Io_Api_Rbac_V1alpha1_RoleRef? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _subjects = source._subjects
      _roleRef = source._roleRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._subjects)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._roleRef)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._subjects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subjects, fieldNumber: 2)
      }
      if let v = _storage._roleRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_RoleBinding, rhs: K8s_Io_Api_Rbac_V1alpha1_RoleBinding) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._subjects != rhs_storage._subjects {return false}
        if _storage._roleRef != rhs_storage._roleRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_RoleBindingList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleBindingList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Rbac_V1alpha1_RoleBinding] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_RoleBindingList, rhs: K8s_Io_Api_Rbac_V1alpha1_RoleBindingList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_RoleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Rbac_V1alpha1_Role] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_RoleList, rhs: K8s_Io_Api_Rbac_V1alpha1_RoleList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_RoleRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apiGroup"),
    2: .same(proto: "kind"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._apiGroup)
      case 2: try decoder.decodeSingularStringField(value: &self._kind)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._apiGroup {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_RoleRef, rhs: K8s_Io_Api_Rbac_V1alpha1_RoleRef) -> Bool {
    if lhs._apiGroup != rhs._apiGroup {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Rbac_V1alpha1_Subject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "apiVersion"),
    3: .same(proto: "name"),
    4: .same(proto: "namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._kind)
      case 2: try decoder.decodeSingularStringField(value: &self._apiVersion)
      case 3: try decoder.decodeSingularStringField(value: &self._name)
      case 4: try decoder.decodeSingularStringField(value: &self._namespace)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._apiVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Rbac_V1alpha1_Subject, rhs: K8s_Io_Api_Rbac_V1alpha1_Subject) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._apiVersion != rhs._apiVersion {return false}
    if lhs._name != rhs._name {return false}
    if lhs._namespace != rhs._namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
