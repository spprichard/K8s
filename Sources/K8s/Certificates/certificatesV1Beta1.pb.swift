// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/certificates/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a certificate signing request
struct K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// The certificate request itself and any additional information.
  /// +optional
  var spec: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec {
    get {return _storage._spec ?? K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Derived information about the request.
  /// +optional
  var status: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus {
    get {return _storage._status ?? K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// request approval state, currently Approved or Denied.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// brief reason for the request state
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// human readable message with details about the request state
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// timestamp for the last update to this condition
  /// +optional
  var lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastUpdateTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }
  /// Returns true if `lastUpdateTime` has been explicitly set.
  var hasLastUpdateTime: Bool {return _storage._lastUpdateTime != nil}
  /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdateTime() {_uniqueStorage()._lastUpdateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var items: [K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This information is immutable after the request is created. Only the Request
/// and Usages fields can be set on creation, other fields are derived by
/// Kubernetes and cannot be modified by users.
struct K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Base64-encoded PKCS#10 CSR data
  var request: Data {
    get {return _request ?? SwiftProtobuf.Internal.emptyData}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  /// allowedUsages specifies a set of usage contexts the key will be
  /// valid for.
  /// See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
  ///      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
  var usages: [String] = []

  /// Information about the requesting user.
  /// See user.Info interface for details.
  /// +optional
  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// UID information about the requesting user.
  /// See user.Info interface for details.
  /// +optional
  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// Group information about the requesting user.
  /// See user.Info interface for details.
  /// +optional
  var groups: [String] = []

  /// Extra information about the requesting user.
  /// See user.Info interface for details.
  /// +optional
  var extra: Dictionary<String,K8s_Io_Api_Certificates_V1beta1_ExtraValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Data? = nil
  fileprivate var _username: String? = nil
  fileprivate var _uid: String? = nil
}

struct K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Conditions applied to the request, such as approval or denial.
  /// +optional
  var conditions: [K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestCondition] = []

  /// If request was approved, the controller will place the issued certificate here.
  /// +optional
  var certificate: Data {
    get {return _certificate ?? SwiftProtobuf.Internal.emptyData}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  mutating func clearCertificate() {self._certificate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _certificate: Data? = nil
}

/// ExtraValue masks the value so protobuf can generate
/// +protobuf.nullable=true
/// +protobuf.options.(gogoproto.goproto_stringer)=false
struct K8s_Io_Api_Certificates_V1beta1_ExtraValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.certificates.v1beta1"

extension K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSigningRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec? = nil
    var _status: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest, rhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSigningRequestCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "reason"),
    3: .same(proto: "message"),
    4: .same(proto: "lastUpdateTime"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _reason: String? = nil
    var _message: String? = nil
    var _lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _reason = source._reason
      _message = source._message
      _lastUpdateTime = source._lastUpdateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 3: try decoder.decodeSingularStringField(value: &_storage._message)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastUpdateTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._lastUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestCondition, rhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSigningRequestList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequest] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestList, rhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSigningRequestSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    5: .same(proto: "usages"),
    2: .same(proto: "username"),
    3: .same(proto: "uid"),
    4: .same(proto: "groups"),
    6: .same(proto: "extra"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._request)
      case 2: try decoder.decodeSingularStringField(value: &self._username)
      case 3: try decoder.decodeSingularStringField(value: &self._uid)
      case 4: try decoder.decodeRepeatedStringField(value: &self.groups)
      case 5: try decoder.decodeRepeatedStringField(value: &self.usages)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Certificates_V1beta1_ExtraValue>.self, value: &self.extra)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._request {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groups, fieldNumber: 4)
    }
    if !self.usages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usages, fieldNumber: 5)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Api_Certificates_V1beta1_ExtraValue>.self, value: self.extra, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec, rhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestSpec) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.usages != rhs.usages {return false}
    if lhs._username != rhs._username {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSigningRequestStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conditions"),
    2: .same(proto: "certificate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      case 2: try decoder.decodeSingularBytesField(value: &self._certificate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    if let v = self._certificate {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus, rhs: K8s_Io_Api_Certificates_V1beta1_CertificateSigningRequestStatus) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs._certificate != rhs._certificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Certificates_V1beta1_ExtraValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtraValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedStringField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Certificates_V1beta1_ExtraValue, rhs: K8s_Io_Api_Certificates_V1beta1_ExtraValue) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
