// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/policy/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.
struct K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the registered name of the CSI driver
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
}

/// AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
struct K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// driver is the name of the Flexvolume driver.
  var driver: String {
    get {return _driver ?? String()}
    set {_driver = newValue}
  }
  /// Returns true if `driver` has been explicitly set.
  var hasDriver: Bool {return self._driver != nil}
  /// Clears the value of `driver`. Subsequent reads from it will return its default value.
  mutating func clearDriver() {self._driver = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _driver: String? = nil
}

/// AllowedHostPath defines the host volume conditions that will be enabled by a policy
/// for pods to use. It requires the path prefix to be defined.
struct K8s_Io_Api_Policy_V1beta1_AllowedHostPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pathPrefix is the path prefix that the host volume must match.
  /// It does not support `*`.
  /// Trailing slashes are trimmed when validating the path prefix with a host path.
  ///
  /// Examples:
  /// `/foo` would allow `/foo`, `/foo/` and `/foo/bar`
  /// `/foo` would not allow `/food` or `/etc/foo`
  var pathPrefix: String {
    get {return _pathPrefix ?? String()}
    set {_pathPrefix = newValue}
  }
  /// Returns true if `pathPrefix` has been explicitly set.
  var hasPathPrefix: Bool {return self._pathPrefix != nil}
  /// Clears the value of `pathPrefix`. Subsequent reads from it will return its default value.
  mutating func clearPathPrefix() {self._pathPrefix = nil}

  /// when set to true, will allow host volumes matching the pathPrefix only if all volume mounts are readOnly.
  /// +optional
  var readOnly: Bool {
    get {return _readOnly ?? false}
    set {_readOnly = newValue}
  }
  /// Returns true if `readOnly` has been explicitly set.
  var hasReadOnly: Bool {return self._readOnly != nil}
  /// Clears the value of `readOnly`. Subsequent reads from it will return its default value.
  mutating func clearReadOnly() {self._readOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pathPrefix: String? = nil
  fileprivate var _readOnly: Bool? = nil
}

/// Eviction evicts a pod from its node subject to certain policies and safety constraints.
/// This is a subresource of Pod.  A request to cause such an eviction is
/// created by POSTing to .../pods/<pod name>/evictions.
struct K8s_Io_Api_Policy_V1beta1_Eviction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ObjectMeta describes the pod that is being evicted.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// DeleteOptions may be provided
  /// +optional
  var deleteOptions: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions {
    get {return _storage._deleteOptions ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions()}
    set {_uniqueStorage()._deleteOptions = newValue}
  }
  /// Returns true if `deleteOptions` has been explicitly set.
  var hasDeleteOptions: Bool {return _storage._deleteOptions != nil}
  /// Clears the value of `deleteOptions`. Subsequent reads from it will return its default value.
  mutating func clearDeleteOptions() {_uniqueStorage()._deleteOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
struct K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
  /// +optional
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of fs groups.  If you would like to force a single
  /// fs group then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Policy_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// HostPortRange defines a range of host ports that will be enabled by a policy
/// for pods to use.  It requires both the start and end to be defined.
struct K8s_Io_Api_Policy_V1beta1_HostPortRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// min is the start of the range, inclusive.
  var min: Int32 {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {self._min = nil}

  /// max is the end of the range, inclusive.
  var max: Int32 {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  mutating func clearMax() {self._max = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _min: Int32? = nil
  fileprivate var _max: Int32? = nil
}

/// IDRange provides a min/max of an allowed range of IDs.
struct K8s_Io_Api_Policy_V1beta1_IDRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// min is the start of the range, inclusive.
  var min: Int64 {
    get {return _min ?? 0}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {self._min = nil}

  /// max is the end of the range, inclusive.
  var max: Int64 {
    get {return _max ?? 0}
    set {_max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  var hasMax: Bool {return self._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  mutating func clearMax() {self._max = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _min: Int64? = nil
  fileprivate var _max: Int64? = nil
}

/// PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
struct K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior of the PodDisruptionBudget.
  /// +optional
  var spec: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec {
    get {return _storage._spec ?? K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the PodDisruptionBudget.
  /// +optional
  var status: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus {
    get {return _storage._status ?? K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
struct K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var items: [K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
struct K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An eviction is allowed if at least "minAvailable" pods selected by
  /// "selector" will still be available after the eviction, i.e. even in the
  /// absence of the evicted pod.  So for example you can prevent all voluntary
  /// evictions by specifying "100%".
  /// +optional
  var minAvailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._minAvailable ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._minAvailable = newValue}
  }
  /// Returns true if `minAvailable` has been explicitly set.
  var hasMinAvailable: Bool {return _storage._minAvailable != nil}
  /// Clears the value of `minAvailable`. Subsequent reads from it will return its default value.
  mutating func clearMinAvailable() {_uniqueStorage()._minAvailable = nil}

  /// Label query over pods whose evictions are managed by the disruption
  /// budget.
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// An eviction is allowed if at most "maxUnavailable" pods selected by
  /// "selector" are unavailable after the eviction, i.e. even in absence of
  /// the evicted pod. For example, one can prevent all voluntary evictions
  /// by specifying 0. This is a mutually exclusive setting with "minAvailable".
  /// +optional
  var maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxUnavailable ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxUnavailable = newValue}
  }
  /// Returns true if `maxUnavailable` has been explicitly set.
  var hasMaxUnavailable: Bool {return _storage._maxUnavailable != nil}
  /// Clears the value of `maxUnavailable`. Subsequent reads from it will return its default value.
  mutating func clearMaxUnavailable() {_uniqueStorage()._maxUnavailable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodDisruptionBudgetStatus represents information about the status of a
/// PodDisruptionBudget. Status may trail the actual state of a system.
struct K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Most recent generation observed when updating this PDB status. PodDisruptionsAllowed and other
  /// status information is valid only if observedGeneration equals to PDB's object generation.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// DisruptedPods contains information about pods whose eviction was
  /// processed by the API server eviction subresource handler but has not
  /// yet been observed by the PodDisruptionBudget controller.
  /// A pod will be in this map from the time when the API server processed the
  /// eviction request to the time when the pod is seen by PDB controller
  /// as having been marked for deletion (or after a timeout). The key in the map is the name of the pod
  /// and the value is the time when the API server processed the eviction request. If
  /// the deletion didn't occur and a pod is still there it will be removed from
  /// the list automatically by PodDisruptionBudget controller after some time.
  /// If everything goes smooth this map should be empty for the most of the time.
  /// Large number of entries in the map may indicate problems with pod deletions.
  /// +optional
  var disruptedPods: Dictionary<String,K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time> = [:]

  /// Number of pod disruptions that are currently allowed.
  var disruptionsAllowed: Int32 {
    get {return _disruptionsAllowed ?? 0}
    set {_disruptionsAllowed = newValue}
  }
  /// Returns true if `disruptionsAllowed` has been explicitly set.
  var hasDisruptionsAllowed: Bool {return self._disruptionsAllowed != nil}
  /// Clears the value of `disruptionsAllowed`. Subsequent reads from it will return its default value.
  mutating func clearDisruptionsAllowed() {self._disruptionsAllowed = nil}

  /// current number of healthy pods
  var currentHealthy: Int32 {
    get {return _currentHealthy ?? 0}
    set {_currentHealthy = newValue}
  }
  /// Returns true if `currentHealthy` has been explicitly set.
  var hasCurrentHealthy: Bool {return self._currentHealthy != nil}
  /// Clears the value of `currentHealthy`. Subsequent reads from it will return its default value.
  mutating func clearCurrentHealthy() {self._currentHealthy = nil}

  /// minimum desired number of healthy pods
  var desiredHealthy: Int32 {
    get {return _desiredHealthy ?? 0}
    set {_desiredHealthy = newValue}
  }
  /// Returns true if `desiredHealthy` has been explicitly set.
  var hasDesiredHealthy: Bool {return self._desiredHealthy != nil}
  /// Clears the value of `desiredHealthy`. Subsequent reads from it will return its default value.
  mutating func clearDesiredHealthy() {self._desiredHealthy = nil}

  /// total number of pods counted by this disruption budget
  var expectedPods: Int32 {
    get {return _expectedPods ?? 0}
    set {_expectedPods = newValue}
  }
  /// Returns true if `expectedPods` has been explicitly set.
  var hasExpectedPods: Bool {return self._expectedPods != nil}
  /// Clears the value of `expectedPods`. Subsequent reads from it will return its default value.
  mutating func clearExpectedPods() {self._expectedPods = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _observedGeneration: Int64? = nil
  fileprivate var _disruptionsAllowed: Int32? = nil
  fileprivate var _currentHealthy: Int32? = nil
  fileprivate var _desiredHealthy: Int32? = nil
  fileprivate var _expectedPods: Int32? = nil
}

/// PodSecurityPolicy governs the ability to make requests that affect the Security Context
/// that will be applied to a pod and container.
struct K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// spec defines the policy enforced.
  /// +optional
  var spec: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec {
    get {return _storage._spec ?? K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
struct K8s_Io_Api_Policy_V1beta1_PodSecurityPolicyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// items is a list of schema objects.
  var items: [K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PodSecurityPolicySpec defines the policy enforced.
struct K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// privileged determines if a pod can request to be run as privileged.
  /// +optional
  var privileged: Bool {
    get {return _storage._privileged ?? false}
    set {_uniqueStorage()._privileged = newValue}
  }
  /// Returns true if `privileged` has been explicitly set.
  var hasPrivileged: Bool {return _storage._privileged != nil}
  /// Clears the value of `privileged`. Subsequent reads from it will return its default value.
  mutating func clearPrivileged() {_uniqueStorage()._privileged = nil}

  /// defaultAddCapabilities is the default set of capabilities that will be added to the container
  /// unless the pod spec specifically drops the capability.  You may not list a capability in both
  /// defaultAddCapabilities and requiredDropCapabilities. Capabilities added here are implicitly
  /// allowed, and need not be included in the allowedCapabilities list.
  /// +optional
  var defaultAddCapabilities: [String] {
    get {return _storage._defaultAddCapabilities}
    set {_uniqueStorage()._defaultAddCapabilities = newValue}
  }

  /// requiredDropCapabilities are the capabilities that will be dropped from the container.  These
  /// are required to be dropped and cannot be added.
  /// +optional
  var requiredDropCapabilities: [String] {
    get {return _storage._requiredDropCapabilities}
    set {_uniqueStorage()._requiredDropCapabilities = newValue}
  }

  /// allowedCapabilities is a list of capabilities that can be requested to add to the container.
  /// Capabilities in this field may be added at the pod author's discretion.
  /// You must not list a capability in both allowedCapabilities and requiredDropCapabilities.
  /// +optional
  var allowedCapabilities: [String] {
    get {return _storage._allowedCapabilities}
    set {_uniqueStorage()._allowedCapabilities = newValue}
  }

  /// volumes is a white list of allowed volume plugins. Empty indicates that
  /// no volumes may be used. To allow all volumes you may use '*'.
  /// +optional
  var volumes: [String] {
    get {return _storage._volumes}
    set {_uniqueStorage()._volumes = newValue}
  }

  /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
  /// +optional
  var hostNetwork: Bool {
    get {return _storage._hostNetwork ?? false}
    set {_uniqueStorage()._hostNetwork = newValue}
  }
  /// Returns true if `hostNetwork` has been explicitly set.
  var hasHostNetwork: Bool {return _storage._hostNetwork != nil}
  /// Clears the value of `hostNetwork`. Subsequent reads from it will return its default value.
  mutating func clearHostNetwork() {_uniqueStorage()._hostNetwork = nil}

  /// hostPorts determines which host port ranges are allowed to be exposed.
  /// +optional
  var hostPorts: [K8s_Io_Api_Policy_V1beta1_HostPortRange] {
    get {return _storage._hostPorts}
    set {_uniqueStorage()._hostPorts = newValue}
  }

  /// hostPID determines if the policy allows the use of HostPID in the pod spec.
  /// +optional
  var hostPid: Bool {
    get {return _storage._hostPid ?? false}
    set {_uniqueStorage()._hostPid = newValue}
  }
  /// Returns true if `hostPid` has been explicitly set.
  var hasHostPid: Bool {return _storage._hostPid != nil}
  /// Clears the value of `hostPid`. Subsequent reads from it will return its default value.
  mutating func clearHostPid() {_uniqueStorage()._hostPid = nil}

  /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
  /// +optional
  var hostIpc: Bool {
    get {return _storage._hostIpc ?? false}
    set {_uniqueStorage()._hostIpc = newValue}
  }
  /// Returns true if `hostIpc` has been explicitly set.
  var hasHostIpc: Bool {return _storage._hostIpc != nil}
  /// Clears the value of `hostIpc`. Subsequent reads from it will return its default value.
  mutating func clearHostIpc() {_uniqueStorage()._hostIpc = nil}

  /// seLinux is the strategy that will dictate the allowable labels that may be set.
  var seLinux: K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions {
    get {return _storage._seLinux ?? K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions()}
    set {_uniqueStorage()._seLinux = newValue}
  }
  /// Returns true if `seLinux` has been explicitly set.
  var hasSeLinux: Bool {return _storage._seLinux != nil}
  /// Clears the value of `seLinux`. Subsequent reads from it will return its default value.
  mutating func clearSeLinux() {_uniqueStorage()._seLinux = nil}

  /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
  var runAsUser: K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions {
    get {return _storage._runAsUser ?? K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions()}
    set {_uniqueStorage()._runAsUser = newValue}
  }
  /// Returns true if `runAsUser` has been explicitly set.
  var hasRunAsUser: Bool {return _storage._runAsUser != nil}
  /// Clears the value of `runAsUser`. Subsequent reads from it will return its default value.
  mutating func clearRunAsUser() {_uniqueStorage()._runAsUser = nil}

  /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set.
  /// If this field is omitted, the pod's RunAsGroup can take any value. This field requires the
  /// RunAsGroup feature gate to be enabled.
  /// +optional
  var runAsGroup: K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions {
    get {return _storage._runAsGroup ?? K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions()}
    set {_uniqueStorage()._runAsGroup = newValue}
  }
  /// Returns true if `runAsGroup` has been explicitly set.
  var hasRunAsGroup: Bool {return _storage._runAsGroup != nil}
  /// Clears the value of `runAsGroup`. Subsequent reads from it will return its default value.
  mutating func clearRunAsGroup() {_uniqueStorage()._runAsGroup = nil}

  /// supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
  var supplementalGroups: K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions {
    get {return _storage._supplementalGroups ?? K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions()}
    set {_uniqueStorage()._supplementalGroups = newValue}
  }
  /// Returns true if `supplementalGroups` has been explicitly set.
  var hasSupplementalGroups: Bool {return _storage._supplementalGroups != nil}
  /// Clears the value of `supplementalGroups`. Subsequent reads from it will return its default value.
  mutating func clearSupplementalGroups() {_uniqueStorage()._supplementalGroups = nil}

  /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
  var fsGroup: K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions {
    get {return _storage._fsGroup ?? K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions()}
    set {_uniqueStorage()._fsGroup = newValue}
  }
  /// Returns true if `fsGroup` has been explicitly set.
  var hasFsGroup: Bool {return _storage._fsGroup != nil}
  /// Clears the value of `fsGroup`. Subsequent reads from it will return its default value.
  mutating func clearFsGroup() {_uniqueStorage()._fsGroup = nil}

  /// readOnlyRootFilesystem when set to true will force containers to run with a read only root file
  /// system.  If the container specifically requests to run with a non-read only root file system
  /// the PSP should deny the pod.
  /// If set to false the container may run with a read only root file system if it wishes but it
  /// will not be forced to.
  /// +optional
  var readOnlyRootFilesystem: Bool {
    get {return _storage._readOnlyRootFilesystem ?? false}
    set {_uniqueStorage()._readOnlyRootFilesystem = newValue}
  }
  /// Returns true if `readOnlyRootFilesystem` has been explicitly set.
  var hasReadOnlyRootFilesystem: Bool {return _storage._readOnlyRootFilesystem != nil}
  /// Clears the value of `readOnlyRootFilesystem`. Subsequent reads from it will return its default value.
  mutating func clearReadOnlyRootFilesystem() {_uniqueStorage()._readOnlyRootFilesystem = nil}

  /// defaultAllowPrivilegeEscalation controls the default setting for whether a
  /// process can gain more privileges than its parent process.
  /// +optional
  var defaultAllowPrivilegeEscalation: Bool {
    get {return _storage._defaultAllowPrivilegeEscalation ?? false}
    set {_uniqueStorage()._defaultAllowPrivilegeEscalation = newValue}
  }
  /// Returns true if `defaultAllowPrivilegeEscalation` has been explicitly set.
  var hasDefaultAllowPrivilegeEscalation: Bool {return _storage._defaultAllowPrivilegeEscalation != nil}
  /// Clears the value of `defaultAllowPrivilegeEscalation`. Subsequent reads from it will return its default value.
  mutating func clearDefaultAllowPrivilegeEscalation() {_uniqueStorage()._defaultAllowPrivilegeEscalation = nil}

  /// allowPrivilegeEscalation determines if a pod can request to allow
  /// privilege escalation. If unspecified, defaults to true.
  /// +optional
  var allowPrivilegeEscalation: Bool {
    get {return _storage._allowPrivilegeEscalation ?? false}
    set {_uniqueStorage()._allowPrivilegeEscalation = newValue}
  }
  /// Returns true if `allowPrivilegeEscalation` has been explicitly set.
  var hasAllowPrivilegeEscalation: Bool {return _storage._allowPrivilegeEscalation != nil}
  /// Clears the value of `allowPrivilegeEscalation`. Subsequent reads from it will return its default value.
  mutating func clearAllowPrivilegeEscalation() {_uniqueStorage()._allowPrivilegeEscalation = nil}

  /// allowedHostPaths is a white list of allowed host paths. Empty indicates
  /// that all host paths may be used.
  /// +optional
  var allowedHostPaths: [K8s_Io_Api_Policy_V1beta1_AllowedHostPath] {
    get {return _storage._allowedHostPaths}
    set {_uniqueStorage()._allowedHostPaths = newValue}
  }

  /// allowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all
  /// Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes
  /// is allowed in the "volumes" field.
  /// +optional
  var allowedFlexVolumes: [K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume] {
    get {return _storage._allowedFlexVolumes}
    set {_uniqueStorage()._allowedFlexVolumes = newValue}
  }

  /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec.
  /// An empty value indicates that any CSI driver can be used for inline ephemeral volumes.
  /// This is an alpha field, and is only honored if the API server enables the CSIInlineVolume feature gate.
  /// +optional
  var allowedCsidrivers: [K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver] {
    get {return _storage._allowedCsidrivers}
    set {_uniqueStorage()._allowedCsidrivers = newValue}
  }

  /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none.
  /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
  /// as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed.
  /// Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
  ///
  /// Examples:
  /// e.g. "foo/*" allows "foo/bar", "foo/baz", etc.
  /// e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
  /// +optional
  var allowedUnsafeSysctls: [String] {
    get {return _storage._allowedUnsafeSysctls}
    set {_uniqueStorage()._allowedUnsafeSysctls = newValue}
  }

  /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none.
  /// Each entry is either a plain sysctl name or ends in "*" in which case it is considered
  /// as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.
  ///
  /// Examples:
  /// e.g. "foo/*" forbids "foo/bar", "foo/baz", etc.
  /// e.g. "foo.*" forbids "foo.bar", "foo.baz", etc.
  /// +optional
  var forbiddenSysctls: [String] {
    get {return _storage._forbiddenSysctls}
    set {_uniqueStorage()._forbiddenSysctls = newValue}
  }

  /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes.
  /// Empty or nil indicates that only the DefaultProcMountType may be used.
  /// This requires the ProcMountType feature flag to be enabled.
  /// +optional
  var allowedProcMountTypes: [String] {
    get {return _storage._allowedProcMountTypes}
    set {_uniqueStorage()._allowedProcMountTypes = newValue}
  }

  /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod.
  /// If this field is omitted, the pod's runtimeClassName field is unrestricted.
  /// Enforcement of this field depends on the RuntimeClass feature gate being enabled.
  /// +optional
  var runtimeClass: K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions {
    get {return _storage._runtimeClass ?? K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions()}
    set {_uniqueStorage()._runtimeClass = newValue}
  }
  /// Returns true if `runtimeClass` has been explicitly set.
  var hasRuntimeClass: Bool {return _storage._runtimeClass != nil}
  /// Clears the value of `runtimeClass`. Subsequent reads from it will return its default value.
  mutating func clearRuntimeClass() {_uniqueStorage()._runtimeClass = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RunAsGroupStrategyOptions defines the strategy type and any options used to create the strategy.
struct K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable RunAsGroup values that may be set.
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of gids that may be used. If you would like to force a single gid
  /// then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Policy_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
struct K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable RunAsUser values that may be set.
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of uids that may be used. If you would like to force a single uid
  /// then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Policy_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

/// RuntimeClassStrategyOptions define the strategy that will dictate the allowable RuntimeClasses
/// for a pod.
struct K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// allowedRuntimeClassNames is a whitelist of RuntimeClass names that may be specified on a pod.
  /// A value of "*" means that any RuntimeClass name is allowed, and must be the only item in the
  /// list. An empty list requires the RuntimeClassName field to be unset.
  var allowedRuntimeClassNames: [String] = []

  /// defaultRuntimeClassName is the default RuntimeClassName to set on the pod.
  /// The default MUST be allowed by the allowedRuntimeClassNames list.
  /// A value of nil does not mutate the Pod.
  /// +optional
  var defaultRuntimeClassName: String {
    get {return _defaultRuntimeClassName ?? String()}
    set {_defaultRuntimeClassName = newValue}
  }
  /// Returns true if `defaultRuntimeClassName` has been explicitly set.
  var hasDefaultRuntimeClassName: Bool {return self._defaultRuntimeClassName != nil}
  /// Clears the value of `defaultRuntimeClassName`. Subsequent reads from it will return its default value.
  mutating func clearDefaultRuntimeClassName() {self._defaultRuntimeClassName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _defaultRuntimeClassName: String? = nil
}

/// SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
struct K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate the allowable labels that may be set.
  var rule: String {
    get {return _storage._rule ?? String()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {_uniqueStorage()._rule = nil}

  /// seLinuxOptions required to run as; required for MustRunAs
  /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  /// +optional
  var seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions {
    get {return _storage._seLinuxOptions ?? K8s_Io_Api_Core_V1_SELinuxOptions()}
    set {_uniqueStorage()._seLinuxOptions = newValue}
  }
  /// Returns true if `seLinuxOptions` has been explicitly set.
  var hasSeLinuxOptions: Bool {return _storage._seLinuxOptions != nil}
  /// Clears the value of `seLinuxOptions`. Subsequent reads from it will return its default value.
  mutating func clearSeLinuxOptions() {_uniqueStorage()._seLinuxOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
struct K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
  /// +optional
  var rule: String {
    get {return _rule ?? String()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  mutating func clearRule() {self._rule = nil}

  /// ranges are the allowed ranges of supplemental groups.  If you would like to force a single
  /// supplemental group then supply a single range with the same start and end. Required for MustRunAs.
  /// +optional
  var ranges: [K8s_Io_Api_Policy_V1beta1_IDRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rule: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.policy.v1beta1"

extension K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedCSIDriver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver, rhs: K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedFlexVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "driver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._driver)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._driver {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume, rhs: K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume) -> Bool {
    if lhs._driver != rhs._driver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_AllowedHostPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedHostPath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pathPrefix"),
    2: .same(proto: "readOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pathPrefix)
      case 2: try decoder.decodeSingularBoolField(value: &self._readOnly)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pathPrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._readOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_AllowedHostPath, rhs: K8s_Io_Api_Policy_V1beta1_AllowedHostPath) -> Bool {
    if lhs._pathPrefix != rhs._pathPrefix {return false}
    if lhs._readOnly != rhs._readOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_Eviction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Eviction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "deleteOptions"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _deleteOptions: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_DeleteOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _deleteOptions = source._deleteOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._deleteOptions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._deleteOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_Eviction, rhs: K8s_Io_Api_Policy_V1beta1_Eviction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._deleteOptions != rhs_storage._deleteOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FSGroupStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_HostPortRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostPortRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._min)
      case 2: try decoder.decodeSingularInt32Field(value: &self._max)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._min {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._max {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_HostPortRange, rhs: K8s_Io_Api_Policy_V1beta1_HostPortRange) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_IDRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IDRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._min)
      case 2: try decoder.decodeSingularInt64Field(value: &self._max)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._min {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._max {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_IDRange, rhs: K8s_Io_Api_Policy_V1beta1_IDRange) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDisruptionBudget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec? = nil
    var _status: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget, rhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDisruptionBudgetList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Policy_V1beta1_PodDisruptionBudget] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetList, rhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDisruptionBudgetSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minAvailable"),
    2: .same(proto: "selector"),
    3: .same(proto: "maxUnavailable"),
  ]

  fileprivate class _StorageClass {
    var _minAvailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minAvailable = source._minAvailable
      _selector = source._selector
      _maxUnavailable = source._maxUnavailable
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._minAvailable)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maxUnavailable)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._minAvailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maxUnavailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec, rhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minAvailable != rhs_storage._minAvailable {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._maxUnavailable != rhs_storage._maxUnavailable {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodDisruptionBudgetStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observedGeneration"),
    2: .same(proto: "disruptedPods"),
    3: .same(proto: "disruptionsAllowed"),
    4: .same(proto: "currentHealthy"),
    5: .same(proto: "desiredHealthy"),
    6: .same(proto: "expectedPods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time>.self, value: &self.disruptedPods)
      case 3: try decoder.decodeSingularInt32Field(value: &self._disruptionsAllowed)
      case 4: try decoder.decodeSingularInt32Field(value: &self._currentHealthy)
      case 5: try decoder.decodeSingularInt32Field(value: &self._desiredHealthy)
      case 6: try decoder.decodeSingularInt32Field(value: &self._expectedPods)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if !self.disruptedPods.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time>.self, value: self.disruptedPods, fieldNumber: 2)
    }
    if let v = self._disruptionsAllowed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._currentHealthy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._desiredHealthy {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._expectedPods {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus, rhs: K8s_Io_Api_Policy_V1beta1_PodDisruptionBudgetStatus) -> Bool {
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs.disruptedPods != rhs.disruptedPods {return false}
    if lhs._disruptionsAllowed != rhs._disruptionsAllowed {return false}
    if lhs._currentHealthy != rhs._currentHealthy {return false}
    if lhs._desiredHealthy != rhs._desiredHealthy {return false}
    if lhs._expectedPods != rhs._expectedPods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy, rhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodSecurityPolicyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Policy_V1beta1_PodSecurityPolicy] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicyList, rhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicyList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodSecurityPolicySpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privileged"),
    2: .same(proto: "defaultAddCapabilities"),
    3: .same(proto: "requiredDropCapabilities"),
    4: .same(proto: "allowedCapabilities"),
    5: .same(proto: "volumes"),
    6: .same(proto: "hostNetwork"),
    7: .same(proto: "hostPorts"),
    8: .same(proto: "hostPID"),
    9: .same(proto: "hostIPC"),
    10: .same(proto: "seLinux"),
    11: .same(proto: "runAsUser"),
    22: .same(proto: "runAsGroup"),
    12: .same(proto: "supplementalGroups"),
    13: .same(proto: "fsGroup"),
    14: .same(proto: "readOnlyRootFilesystem"),
    15: .same(proto: "defaultAllowPrivilegeEscalation"),
    16: .same(proto: "allowPrivilegeEscalation"),
    17: .same(proto: "allowedHostPaths"),
    18: .same(proto: "allowedFlexVolumes"),
    23: .same(proto: "allowedCSIDrivers"),
    19: .same(proto: "allowedUnsafeSysctls"),
    20: .same(proto: "forbiddenSysctls"),
    21: .same(proto: "allowedProcMountTypes"),
    24: .same(proto: "runtimeClass"),
  ]

  fileprivate class _StorageClass {
    var _privileged: Bool? = nil
    var _defaultAddCapabilities: [String] = []
    var _requiredDropCapabilities: [String] = []
    var _allowedCapabilities: [String] = []
    var _volumes: [String] = []
    var _hostNetwork: Bool? = nil
    var _hostPorts: [K8s_Io_Api_Policy_V1beta1_HostPortRange] = []
    var _hostPid: Bool? = nil
    var _hostIpc: Bool? = nil
    var _seLinux: K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions? = nil
    var _runAsUser: K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions? = nil
    var _runAsGroup: K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions? = nil
    var _supplementalGroups: K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions? = nil
    var _fsGroup: K8s_Io_Api_Policy_V1beta1_FSGroupStrategyOptions? = nil
    var _readOnlyRootFilesystem: Bool? = nil
    var _defaultAllowPrivilegeEscalation: Bool? = nil
    var _allowPrivilegeEscalation: Bool? = nil
    var _allowedHostPaths: [K8s_Io_Api_Policy_V1beta1_AllowedHostPath] = []
    var _allowedFlexVolumes: [K8s_Io_Api_Policy_V1beta1_AllowedFlexVolume] = []
    var _allowedCsidrivers: [K8s_Io_Api_Policy_V1beta1_AllowedCSIDriver] = []
    var _allowedUnsafeSysctls: [String] = []
    var _forbiddenSysctls: [String] = []
    var _allowedProcMountTypes: [String] = []
    var _runtimeClass: K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _privileged = source._privileged
      _defaultAddCapabilities = source._defaultAddCapabilities
      _requiredDropCapabilities = source._requiredDropCapabilities
      _allowedCapabilities = source._allowedCapabilities
      _volumes = source._volumes
      _hostNetwork = source._hostNetwork
      _hostPorts = source._hostPorts
      _hostPid = source._hostPid
      _hostIpc = source._hostIpc
      _seLinux = source._seLinux
      _runAsUser = source._runAsUser
      _runAsGroup = source._runAsGroup
      _supplementalGroups = source._supplementalGroups
      _fsGroup = source._fsGroup
      _readOnlyRootFilesystem = source._readOnlyRootFilesystem
      _defaultAllowPrivilegeEscalation = source._defaultAllowPrivilegeEscalation
      _allowPrivilegeEscalation = source._allowPrivilegeEscalation
      _allowedHostPaths = source._allowedHostPaths
      _allowedFlexVolumes = source._allowedFlexVolumes
      _allowedCsidrivers = source._allowedCsidrivers
      _allowedUnsafeSysctls = source._allowedUnsafeSysctls
      _forbiddenSysctls = source._forbiddenSysctls
      _allowedProcMountTypes = source._allowedProcMountTypes
      _runtimeClass = source._runtimeClass
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._privileged)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._defaultAddCapabilities)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._requiredDropCapabilities)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._allowedCapabilities)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._volumes)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._hostNetwork)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._hostPorts)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._hostPid)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._hostIpc)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._seLinux)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._runAsUser)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._supplementalGroups)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._fsGroup)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._readOnlyRootFilesystem)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._defaultAllowPrivilegeEscalation)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._allowPrivilegeEscalation)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._allowedHostPaths)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._allowedFlexVolumes)
        case 19: try decoder.decodeRepeatedStringField(value: &_storage._allowedUnsafeSysctls)
        case 20: try decoder.decodeRepeatedStringField(value: &_storage._forbiddenSysctls)
        case 21: try decoder.decodeRepeatedStringField(value: &_storage._allowedProcMountTypes)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._runAsGroup)
        case 23: try decoder.decodeRepeatedMessageField(value: &_storage._allowedCsidrivers)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._runtimeClass)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._privileged {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if !_storage._defaultAddCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._defaultAddCapabilities, fieldNumber: 2)
      }
      if !_storage._requiredDropCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requiredDropCapabilities, fieldNumber: 3)
      }
      if !_storage._allowedCapabilities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedCapabilities, fieldNumber: 4)
      }
      if !_storage._volumes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._volumes, fieldNumber: 5)
      }
      if let v = _storage._hostNetwork {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if !_storage._hostPorts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hostPorts, fieldNumber: 7)
      }
      if let v = _storage._hostPid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._hostIpc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
      if let v = _storage._seLinux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._runAsUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._supplementalGroups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._fsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._readOnlyRootFilesystem {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }
      if let v = _storage._defaultAllowPrivilegeEscalation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      }
      if let v = _storage._allowPrivilegeEscalation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if !_storage._allowedHostPaths.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedHostPaths, fieldNumber: 17)
      }
      if !_storage._allowedFlexVolumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedFlexVolumes, fieldNumber: 18)
      }
      if !_storage._allowedUnsafeSysctls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedUnsafeSysctls, fieldNumber: 19)
      }
      if !_storage._forbiddenSysctls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._forbiddenSysctls, fieldNumber: 20)
      }
      if !_storage._allowedProcMountTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedProcMountTypes, fieldNumber: 21)
      }
      if let v = _storage._runAsGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if !_storage._allowedCsidrivers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedCsidrivers, fieldNumber: 23)
      }
      if let v = _storage._runtimeClass {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec, rhs: K8s_Io_Api_Policy_V1beta1_PodSecurityPolicySpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._privileged != rhs_storage._privileged {return false}
        if _storage._defaultAddCapabilities != rhs_storage._defaultAddCapabilities {return false}
        if _storage._requiredDropCapabilities != rhs_storage._requiredDropCapabilities {return false}
        if _storage._allowedCapabilities != rhs_storage._allowedCapabilities {return false}
        if _storage._volumes != rhs_storage._volumes {return false}
        if _storage._hostNetwork != rhs_storage._hostNetwork {return false}
        if _storage._hostPorts != rhs_storage._hostPorts {return false}
        if _storage._hostPid != rhs_storage._hostPid {return false}
        if _storage._hostIpc != rhs_storage._hostIpc {return false}
        if _storage._seLinux != rhs_storage._seLinux {return false}
        if _storage._runAsUser != rhs_storage._runAsUser {return false}
        if _storage._runAsGroup != rhs_storage._runAsGroup {return false}
        if _storage._supplementalGroups != rhs_storage._supplementalGroups {return false}
        if _storage._fsGroup != rhs_storage._fsGroup {return false}
        if _storage._readOnlyRootFilesystem != rhs_storage._readOnlyRootFilesystem {return false}
        if _storage._defaultAllowPrivilegeEscalation != rhs_storage._defaultAllowPrivilegeEscalation {return false}
        if _storage._allowPrivilegeEscalation != rhs_storage._allowPrivilegeEscalation {return false}
        if _storage._allowedHostPaths != rhs_storage._allowedHostPaths {return false}
        if _storage._allowedFlexVolumes != rhs_storage._allowedFlexVolumes {return false}
        if _storage._allowedCsidrivers != rhs_storage._allowedCsidrivers {return false}
        if _storage._allowedUnsafeSysctls != rhs_storage._allowedUnsafeSysctls {return false}
        if _storage._forbiddenSysctls != rhs_storage._forbiddenSysctls {return false}
        if _storage._allowedProcMountTypes != rhs_storage._allowedProcMountTypes {return false}
        if _storage._runtimeClass != rhs_storage._runtimeClass {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAsGroupStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_RunAsGroupStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAsUserStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_RunAsUserStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuntimeClassStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowedRuntimeClassNames"),
    2: .same(proto: "defaultRuntimeClassName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.allowedRuntimeClassNames)
      case 2: try decoder.decodeSingularStringField(value: &self._defaultRuntimeClassName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedRuntimeClassNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedRuntimeClassNames, fieldNumber: 1)
    }
    if let v = self._defaultRuntimeClassName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_RuntimeClassStrategyOptions) -> Bool {
    if lhs.allowedRuntimeClassNames != rhs.allowedRuntimeClassNames {return false}
    if lhs._defaultRuntimeClassName != rhs._defaultRuntimeClassName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SELinuxStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "seLinuxOptions"),
  ]

  fileprivate class _StorageClass {
    var _rule: String? = nil
    var _seLinuxOptions: K8s_Io_Api_Core_V1_SELinuxOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
      _seLinuxOptions = source._seLinuxOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._rule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._seLinuxOptions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rule {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._seLinuxOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_SELinuxStrategyOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._seLinuxOptions != rhs_storage._seLinuxOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupplementalGroupsStrategyOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "ranges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._rule)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions, rhs: K8s_Io_Api_Policy_V1beta1_SupplementalGroupsStrategyOptions) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
