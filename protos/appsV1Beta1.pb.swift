// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: k8s.io/api/apps/v1beta1/generated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the
/// release notes for more information.
/// ControllerRevision implements an immutable snapshot of state data. Clients
/// are responsible for serializing and deserializing the objects that contain
/// their internal state.
/// Once a ControllerRevision has been successfully created, it can not be updated.
/// The API Server will fail validation of all requests that attempt to mutate
/// the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both
/// the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,
/// it may be subject to name and representation changes in future releases, and clients should not
/// depend on its stability. It is primarily for internal use by controllers.
struct K8s_Io_Api_Apps_V1beta1_ControllerRevision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object's metadata.
  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Data is the serialized representation of the state.
  var data: K8s_Io_Apimachinery_Pkg_Runtime_RawExtension {
    get {return _storage._data ?? K8s_Io_Apimachinery_Pkg_Runtime_RawExtension()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  /// Revision indicates the revision of the state represented by Data.
  var revision: Int64 {
    get {return _storage._revision ?? 0}
    set {_uniqueStorage()._revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return _storage._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {_uniqueStorage()._revision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
struct K8s_Io_Api_Apps_V1beta1_ControllerRevisionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of ControllerRevisions
  var items: [K8s_Io_Api_Apps_V1beta1_ControllerRevision] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for
/// more information.
/// Deployment enables declarative updates for Pods and ReplicaSets.
struct K8s_Io_Api_Apps_V1beta1_Deployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specification of the desired behavior of the Deployment.
  /// +optional
  var spec: K8s_Io_Api_Apps_V1beta1_DeploymentSpec {
    get {return _storage._spec ?? K8s_Io_Api_Apps_V1beta1_DeploymentSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Most recently observed status of the Deployment.
  /// +optional
  var status: K8s_Io_Api_Apps_V1beta1_DeploymentStatus {
    get {return _storage._status ?? K8s_Io_Api_Apps_V1beta1_DeploymentStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentCondition describes the state of a deployment at a certain point.
struct K8s_Io_Api_Apps_V1beta1_DeploymentCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of deployment condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The last time this condition was updated.
  var lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastUpdateTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastUpdateTime = newValue}
  }
  /// Returns true if `lastUpdateTime` has been explicitly set.
  var hasLastUpdateTime: Bool {return _storage._lastUpdateTime != nil}
  /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdateTime() {_uniqueStorage()._lastUpdateTime = nil}

  /// Last time the condition transitioned from one status to another.
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentList is a list of Deployments.
struct K8s_Io_Api_Apps_V1beta1_DeploymentList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard list metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Items is the list of Deployments.
  var items: [K8s_Io_Api_Apps_V1beta1_Deployment] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED.
/// DeploymentRollback stores the information required to rollback a deployment.
struct K8s_Io_Api_Apps_V1beta1_DeploymentRollback {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required: This must match the Name of a deployment.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// The annotations to be updated to a deployment
  /// +optional
  var updatedAnnotations: Dictionary<String,String> {
    get {return _storage._updatedAnnotations}
    set {_uniqueStorage()._updatedAnnotations = newValue}
  }

  /// The config of this deployment rollback.
  var rollbackTo: K8s_Io_Api_Apps_V1beta1_RollbackConfig {
    get {return _storage._rollbackTo ?? K8s_Io_Api_Apps_V1beta1_RollbackConfig()}
    set {_uniqueStorage()._rollbackTo = newValue}
  }
  /// Returns true if `rollbackTo` has been explicitly set.
  var hasRollbackTo: Bool {return _storage._rollbackTo != nil}
  /// Clears the value of `rollbackTo`. Subsequent reads from it will return its default value.
  mutating func clearRollbackTo() {_uniqueStorage()._rollbackTo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentSpec is the specification of the desired behavior of the Deployment.
struct K8s_Io_Api_Apps_V1beta1_DeploymentSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of desired pods. This is a pointer to distinguish between explicit
  /// zero and not specified. Defaults to 1.
  /// +optional
  var replicas: Int32 {
    get {return _storage._replicas ?? 0}
    set {_uniqueStorage()._replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return _storage._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {_uniqueStorage()._replicas = nil}

  /// Label selector for pods. Existing ReplicaSets whose pods are
  /// selected by this will be the ones affected by this deployment.
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// Template describes the pods that will be created.
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  /// The deployment strategy to use to replace existing pods with new ones.
  /// +optional
  /// +patchStrategy=retainKeys
  var strategy: K8s_Io_Api_Apps_V1beta1_DeploymentStrategy {
    get {return _storage._strategy ?? K8s_Io_Api_Apps_V1beta1_DeploymentStrategy()}
    set {_uniqueStorage()._strategy = newValue}
  }
  /// Returns true if `strategy` has been explicitly set.
  var hasStrategy: Bool {return _storage._strategy != nil}
  /// Clears the value of `strategy`. Subsequent reads from it will return its default value.
  mutating func clearStrategy() {_uniqueStorage()._strategy = nil}

  /// Minimum number of seconds for which a newly created pod should be ready
  /// without any of its container crashing, for it to be considered available.
  /// Defaults to 0 (pod will be considered available as soon as it is ready)
  /// +optional
  var minReadySeconds: Int32 {
    get {return _storage._minReadySeconds ?? 0}
    set {_uniqueStorage()._minReadySeconds = newValue}
  }
  /// Returns true if `minReadySeconds` has been explicitly set.
  var hasMinReadySeconds: Bool {return _storage._minReadySeconds != nil}
  /// Clears the value of `minReadySeconds`. Subsequent reads from it will return its default value.
  mutating func clearMinReadySeconds() {_uniqueStorage()._minReadySeconds = nil}

  /// The number of old ReplicaSets to retain to allow rollback.
  /// This is a pointer to distinguish between explicit zero and not specified.
  /// Defaults to 2.
  /// +optional
  var revisionHistoryLimit: Int32 {
    get {return _storage._revisionHistoryLimit ?? 0}
    set {_uniqueStorage()._revisionHistoryLimit = newValue}
  }
  /// Returns true if `revisionHistoryLimit` has been explicitly set.
  var hasRevisionHistoryLimit: Bool {return _storage._revisionHistoryLimit != nil}
  /// Clears the value of `revisionHistoryLimit`. Subsequent reads from it will return its default value.
  mutating func clearRevisionHistoryLimit() {_uniqueStorage()._revisionHistoryLimit = nil}

  /// Indicates that the deployment is paused.
  /// +optional
  var paused: Bool {
    get {return _storage._paused ?? false}
    set {_uniqueStorage()._paused = newValue}
  }
  /// Returns true if `paused` has been explicitly set.
  var hasPaused: Bool {return _storage._paused != nil}
  /// Clears the value of `paused`. Subsequent reads from it will return its default value.
  mutating func clearPaused() {_uniqueStorage()._paused = nil}

  /// DEPRECATED.
  /// The config this deployment is rolling back to. Will be cleared after rollback is done.
  /// +optional
  var rollbackTo: K8s_Io_Api_Apps_V1beta1_RollbackConfig {
    get {return _storage._rollbackTo ?? K8s_Io_Api_Apps_V1beta1_RollbackConfig()}
    set {_uniqueStorage()._rollbackTo = newValue}
  }
  /// Returns true if `rollbackTo` has been explicitly set.
  var hasRollbackTo: Bool {return _storage._rollbackTo != nil}
  /// Clears the value of `rollbackTo`. Subsequent reads from it will return its default value.
  mutating func clearRollbackTo() {_uniqueStorage()._rollbackTo = nil}

  /// The maximum time in seconds for a deployment to make progress before it
  /// is considered to be failed. The deployment controller will continue to
  /// process failed deployments and a condition with a ProgressDeadlineExceeded
  /// reason will be surfaced in the deployment status. Note that progress will
  /// not be estimated during the time a deployment is paused. Defaults to 600s.
  /// +optional
  var progressDeadlineSeconds: Int32 {
    get {return _storage._progressDeadlineSeconds ?? 0}
    set {_uniqueStorage()._progressDeadlineSeconds = newValue}
  }
  /// Returns true if `progressDeadlineSeconds` has been explicitly set.
  var hasProgressDeadlineSeconds: Bool {return _storage._progressDeadlineSeconds != nil}
  /// Clears the value of `progressDeadlineSeconds`. Subsequent reads from it will return its default value.
  mutating func clearProgressDeadlineSeconds() {_uniqueStorage()._progressDeadlineSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeploymentStatus is the most recently observed status of the Deployment.
struct K8s_Io_Api_Apps_V1beta1_DeploymentStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The generation observed by the deployment controller.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
  /// +optional
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
  /// +optional
  var updatedReplicas: Int32 {
    get {return _updatedReplicas ?? 0}
    set {_updatedReplicas = newValue}
  }
  /// Returns true if `updatedReplicas` has been explicitly set.
  var hasUpdatedReplicas: Bool {return self._updatedReplicas != nil}
  /// Clears the value of `updatedReplicas`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedReplicas() {self._updatedReplicas = nil}

  /// Total number of ready pods targeted by this deployment.
  /// +optional
  var readyReplicas: Int32 {
    get {return _readyReplicas ?? 0}
    set {_readyReplicas = newValue}
  }
  /// Returns true if `readyReplicas` has been explicitly set.
  var hasReadyReplicas: Bool {return self._readyReplicas != nil}
  /// Clears the value of `readyReplicas`. Subsequent reads from it will return its default value.
  mutating func clearReadyReplicas() {self._readyReplicas = nil}

  /// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
  /// +optional
  var availableReplicas: Int32 {
    get {return _availableReplicas ?? 0}
    set {_availableReplicas = newValue}
  }
  /// Returns true if `availableReplicas` has been explicitly set.
  var hasAvailableReplicas: Bool {return self._availableReplicas != nil}
  /// Clears the value of `availableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearAvailableReplicas() {self._availableReplicas = nil}

  /// Total number of unavailable pods targeted by this deployment. This is the total number of
  /// pods that are still required for the deployment to have 100% available capacity. They may
  /// either be pods that are running but not yet available or pods that still have not been created.
  /// +optional
  var unavailableReplicas: Int32 {
    get {return _unavailableReplicas ?? 0}
    set {_unavailableReplicas = newValue}
  }
  /// Returns true if `unavailableReplicas` has been explicitly set.
  var hasUnavailableReplicas: Bool {return self._unavailableReplicas != nil}
  /// Clears the value of `unavailableReplicas`. Subsequent reads from it will return its default value.
  mutating func clearUnavailableReplicas() {self._unavailableReplicas = nil}

  /// Represents the latest available observations of a deployment's current state.
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Apps_V1beta1_DeploymentCondition] = []

  /// Count of hash collisions for the Deployment. The Deployment controller uses this
  /// field as a collision avoidance mechanism when it needs to create the name for the
  /// newest ReplicaSet.
  /// +optional
  var collisionCount: Int32 {
    get {return _collisionCount ?? 0}
    set {_collisionCount = newValue}
  }
  /// Returns true if `collisionCount` has been explicitly set.
  var hasCollisionCount: Bool {return self._collisionCount != nil}
  /// Clears the value of `collisionCount`. Subsequent reads from it will return its default value.
  mutating func clearCollisionCount() {self._collisionCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _observedGeneration: Int64? = nil
  fileprivate var _replicas: Int32? = nil
  fileprivate var _updatedReplicas: Int32? = nil
  fileprivate var _readyReplicas: Int32? = nil
  fileprivate var _availableReplicas: Int32? = nil
  fileprivate var _unavailableReplicas: Int32? = nil
  fileprivate var _collisionCount: Int32? = nil
}

/// DeploymentStrategy describes how to replace existing pods with new ones.
struct K8s_Io_Api_Apps_V1beta1_DeploymentStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
  /// +optional
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Rolling update config params. Present only if DeploymentStrategyType =
  /// RollingUpdate.
  /// ---
  /// TODO: Update this to follow our convention for oneOf, whatever we decide it
  /// to be.
  /// +optional
  var rollingUpdate: K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment {
    get {return _storage._rollingUpdate ?? K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment()}
    set {_uniqueStorage()._rollingUpdate = newValue}
  }
  /// Returns true if `rollingUpdate` has been explicitly set.
  var hasRollingUpdate: Bool {return _storage._rollingUpdate != nil}
  /// Clears the value of `rollingUpdate`. Subsequent reads from it will return its default value.
  mutating func clearRollingUpdate() {_uniqueStorage()._rollingUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DEPRECATED.
struct K8s_Io_Api_Apps_V1beta1_RollbackConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The revision to rollback to. If set to 0, rollback to the last revision.
  /// +optional
  var revision: Int64 {
    get {return _revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _revision: Int64? = nil
}

/// Spec to control the desired behavior of rolling update.
struct K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of pods that can be unavailable during the update.
  /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  /// Absolute number is calculated from percentage by rounding down.
  /// This can not be 0 if MaxSurge is 0.
  /// Defaults to 25%.
  /// Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
  /// immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
  /// can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
  /// that the total number of pods available at all times during the update is at
  /// least 70% of desired pods.
  /// +optional
  var maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxUnavailable ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxUnavailable = newValue}
  }
  /// Returns true if `maxUnavailable` has been explicitly set.
  var hasMaxUnavailable: Bool {return _storage._maxUnavailable != nil}
  /// Clears the value of `maxUnavailable`. Subsequent reads from it will return its default value.
  mutating func clearMaxUnavailable() {_uniqueStorage()._maxUnavailable = nil}

  /// The maximum number of pods that can be scheduled above the desired number of
  /// pods.
  /// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  /// This can not be 0 if MaxUnavailable is 0.
  /// Absolute number is calculated from percentage by rounding up.
  /// Defaults to 25%.
  /// Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
  /// the rolling update starts, such that the total number of old and new pods do not exceed
  /// 130% of desired pods. Once old pods have been killed,
  /// new ReplicaSet can be scaled up further, ensuring that total number of pods running
  /// at any time during the update is at most 130% of desired pods.
  /// +optional
  var maxSurge: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString {
    get {return _storage._maxSurge ?? K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString()}
    set {_uniqueStorage()._maxSurge = newValue}
  }
  /// Returns true if `maxSurge` has been explicitly set.
  var hasMaxSurge: Bool {return _storage._maxSurge != nil}
  /// Clears the value of `maxSurge`. Subsequent reads from it will return its default value.
  mutating func clearMaxSurge() {_uniqueStorage()._maxSurge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
struct K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partition indicates the ordinal at which the StatefulSet should be
  /// partitioned.
  var partition: Int32 {
    get {return _partition ?? 0}
    set {_partition = newValue}
  }
  /// Returns true if `partition` has been explicitly set.
  var hasPartition: Bool {return self._partition != nil}
  /// Clears the value of `partition`. Subsequent reads from it will return its default value.
  mutating func clearPartition() {self._partition = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _partition: Int32? = nil
}

/// Scale represents a scaling request for a resource.
struct K8s_Io_Api_Apps_V1beta1_Scale {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.
  /// +optional
  var spec: K8s_Io_Api_Apps_V1beta1_ScaleSpec {
    get {return _storage._spec ?? K8s_Io_Api_Apps_V1beta1_ScaleSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.
  /// +optional
  var status: K8s_Io_Api_Apps_V1beta1_ScaleStatus {
    get {return _storage._status ?? K8s_Io_Api_Apps_V1beta1_ScaleStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ScaleSpec describes the attributes of a scale subresource
struct K8s_Io_Api_Apps_V1beta1_ScaleSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// desired number of instances for the scaled object.
  /// +optional
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
}

/// ScaleStatus represents the current status of a scale subresource.
struct K8s_Io_Api_Apps_V1beta1_ScaleStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// actual number of observed instances of the scaled object.
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// label query over pods that should match the replicas count. More info: http://kubernetes.io/docs/user-guide/labels#label-selectors
  /// +optional
  var selector: Dictionary<String,String> = [:]

  /// label selector for pods that should match the replicas count. This is a serializated
  /// version of both map-based and more expressive set-based selectors. This is done to
  /// avoid introspection in the clients. The string will be in the same format as the
  /// query-param syntax. If the target type only supports map-based selectors, both this
  /// field and map-based selector field are populated.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var targetSelector: String {
    get {return _targetSelector ?? String()}
    set {_targetSelector = newValue}
  }
  /// Returns true if `targetSelector` has been explicitly set.
  var hasTargetSelector: Bool {return self._targetSelector != nil}
  /// Clears the value of `targetSelector`. Subsequent reads from it will return its default value.
  mutating func clearTargetSelector() {self._targetSelector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _replicas: Int32? = nil
  fileprivate var _targetSelector: String? = nil
}

/// DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for
/// more information.
/// StatefulSet represents a set of pods with consistent identities.
/// Identities are defined as:
///  - Network: A single stable DNS and hostname.
///  - Storage: As many VolumeClaims as requested.
/// The StatefulSet guarantees that a given network identity will always
/// map to the same storage identity.
struct K8s_Io_Api_Apps_V1beta1_StatefulSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec defines the desired identities of pods in this set.
  /// +optional
  var spec: K8s_Io_Api_Apps_V1beta1_StatefulSetSpec {
    get {return _storage._spec ?? K8s_Io_Api_Apps_V1beta1_StatefulSetSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is the current status of Pods in this StatefulSet. This data
  /// may be out of date by some window of time.
  /// +optional
  var status: K8s_Io_Api_Apps_V1beta1_StatefulSetStatus {
    get {return _storage._status ?? K8s_Io_Api_Apps_V1beta1_StatefulSetStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StatefulSetCondition describes the state of a statefulset at a certain point.
struct K8s_Io_Api_Apps_V1beta1_StatefulSetCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of statefulset condition.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Status of the condition, one of True, False, Unknown.
  var status: String {
    get {return _storage._status ?? String()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Last time the condition transitioned from one status to another.
  /// +optional
  var lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time {
    get {return _storage._lastTransitionTime ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time()}
    set {_uniqueStorage()._lastTransitionTime = newValue}
  }
  /// Returns true if `lastTransitionTime` has been explicitly set.
  var hasLastTransitionTime: Bool {return _storage._lastTransitionTime != nil}
  /// Clears the value of `lastTransitionTime`. Subsequent reads from it will return its default value.
  mutating func clearLastTransitionTime() {_uniqueStorage()._lastTransitionTime = nil}

  /// The reason for the condition's last transition.
  /// +optional
  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  /// A human readable message indicating details about the transition.
  /// +optional
  var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StatefulSetList is a collection of StatefulSets.
struct K8s_Io_Api_Apps_V1beta1_StatefulSetList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// +optional
  var metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta {
    get {return _storage._metadata ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var items: [K8s_Io_Api_Apps_V1beta1_StatefulSet] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A StatefulSetSpec is the specification of a StatefulSet.
struct K8s_Io_Api_Apps_V1beta1_StatefulSetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// replicas is the desired number of replicas of the given Template.
  /// These are replicas in the sense that they are instantiations of the
  /// same Template, but individual replicas also have a consistent identity.
  /// If unspecified, defaults to 1.
  /// TODO: Consider a rename of this field.
  /// +optional
  var replicas: Int32 {
    get {return _storage._replicas ?? 0}
    set {_uniqueStorage()._replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return _storage._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {_uniqueStorage()._replicas = nil}

  /// selector is a label query over pods that should match the replica count.
  /// If empty, defaulted to labels on the pod template.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  /// +optional
  var selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector {
    get {return _storage._selector ?? K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector()}
    set {_uniqueStorage()._selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return _storage._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {_uniqueStorage()._selector = nil}

  /// template is the object that describes the pod that will be created if
  /// insufficient replicas are detected. Each pod stamped out by the StatefulSet
  /// will fulfill this Template, but have a unique identity from the rest
  /// of the StatefulSet.
  var template: K8s_Io_Api_Core_V1_PodTemplateSpec {
    get {return _storage._template ?? K8s_Io_Api_Core_V1_PodTemplateSpec()}
    set {_uniqueStorage()._template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return _storage._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {_uniqueStorage()._template = nil}

  /// volumeClaimTemplates is a list of claims that pods are allowed to reference.
  /// The StatefulSet controller is responsible for mapping network identities to
  /// claims in a way that maintains the identity of a pod. Every claim in
  /// this list must have at least one matching (by name) volumeMount in one
  /// container in the template. A claim in this list takes precedence over
  /// any volumes in the template, with the same name.
  /// TODO: Define the behavior if a claim already exists with the same name.
  /// +optional
  var volumeClaimTemplates: [K8s_Io_Api_Core_V1_PersistentVolumeClaim] {
    get {return _storage._volumeClaimTemplates}
    set {_uniqueStorage()._volumeClaimTemplates = newValue}
  }

  /// serviceName is the name of the service that governs this StatefulSet.
  /// This service must exist before the StatefulSet, and is responsible for
  /// the network identity of the set. Pods get DNS/hostnames that follow the
  /// pattern: pod-specific-string.serviceName.default.svc.cluster.local
  /// where "pod-specific-string" is managed by the StatefulSet controller.
  var serviceName: String {
    get {return _storage._serviceName ?? String()}
    set {_uniqueStorage()._serviceName = newValue}
  }
  /// Returns true if `serviceName` has been explicitly set.
  var hasServiceName: Bool {return _storage._serviceName != nil}
  /// Clears the value of `serviceName`. Subsequent reads from it will return its default value.
  mutating func clearServiceName() {_uniqueStorage()._serviceName = nil}

  /// podManagementPolicy controls how pods are created during initial scale up,
  /// when replacing pods on nodes, or when scaling down. The default policy is
  /// `OrderedReady`, where pods are created in increasing order (pod-0, then
  /// pod-1, etc) and the controller will wait until each pod is ready before
  /// continuing. When scaling down, the pods are removed in the opposite order.
  /// The alternative policy is `Parallel` which will create pods in parallel
  /// to match the desired scale without waiting, and on scale down will delete
  /// all pods at once.
  /// +optional
  var podManagementPolicy: String {
    get {return _storage._podManagementPolicy ?? String()}
    set {_uniqueStorage()._podManagementPolicy = newValue}
  }
  /// Returns true if `podManagementPolicy` has been explicitly set.
  var hasPodManagementPolicy: Bool {return _storage._podManagementPolicy != nil}
  /// Clears the value of `podManagementPolicy`. Subsequent reads from it will return its default value.
  mutating func clearPodManagementPolicy() {_uniqueStorage()._podManagementPolicy = nil}

  /// updateStrategy indicates the StatefulSetUpdateStrategy that will be
  /// employed to update Pods in the StatefulSet when a revision is made to
  /// Template.
  var updateStrategy: K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy {
    get {return _storage._updateStrategy ?? K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy()}
    set {_uniqueStorage()._updateStrategy = newValue}
  }
  /// Returns true if `updateStrategy` has been explicitly set.
  var hasUpdateStrategy: Bool {return _storage._updateStrategy != nil}
  /// Clears the value of `updateStrategy`. Subsequent reads from it will return its default value.
  mutating func clearUpdateStrategy() {_uniqueStorage()._updateStrategy = nil}

  /// revisionHistoryLimit is the maximum number of revisions that will
  /// be maintained in the StatefulSet's revision history. The revision history
  /// consists of all revisions not represented by a currently applied
  /// StatefulSetSpec version. The default value is 10.
  var revisionHistoryLimit: Int32 {
    get {return _storage._revisionHistoryLimit ?? 0}
    set {_uniqueStorage()._revisionHistoryLimit = newValue}
  }
  /// Returns true if `revisionHistoryLimit` has been explicitly set.
  var hasRevisionHistoryLimit: Bool {return _storage._revisionHistoryLimit != nil}
  /// Clears the value of `revisionHistoryLimit`. Subsequent reads from it will return its default value.
  mutating func clearRevisionHistoryLimit() {_uniqueStorage()._revisionHistoryLimit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StatefulSetStatus represents the current state of a StatefulSet.
struct K8s_Io_Api_Apps_V1beta1_StatefulSetStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
  /// StatefulSet's generation, which is updated on mutation by the API Server.
  /// +optional
  var observedGeneration: Int64 {
    get {return _observedGeneration ?? 0}
    set {_observedGeneration = newValue}
  }
  /// Returns true if `observedGeneration` has been explicitly set.
  var hasObservedGeneration: Bool {return self._observedGeneration != nil}
  /// Clears the value of `observedGeneration`. Subsequent reads from it will return its default value.
  mutating func clearObservedGeneration() {self._observedGeneration = nil}

  /// replicas is the number of Pods created by the StatefulSet controller.
  var replicas: Int32 {
    get {return _replicas ?? 0}
    set {_replicas = newValue}
  }
  /// Returns true if `replicas` has been explicitly set.
  var hasReplicas: Bool {return self._replicas != nil}
  /// Clears the value of `replicas`. Subsequent reads from it will return its default value.
  mutating func clearReplicas() {self._replicas = nil}

  /// readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.
  var readyReplicas: Int32 {
    get {return _readyReplicas ?? 0}
    set {_readyReplicas = newValue}
  }
  /// Returns true if `readyReplicas` has been explicitly set.
  var hasReadyReplicas: Bool {return self._readyReplicas != nil}
  /// Clears the value of `readyReplicas`. Subsequent reads from it will return its default value.
  mutating func clearReadyReplicas() {self._readyReplicas = nil}

  /// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  /// indicated by currentRevision.
  var currentReplicas: Int32 {
    get {return _currentReplicas ?? 0}
    set {_currentReplicas = newValue}
  }
  /// Returns true if `currentReplicas` has been explicitly set.
  var hasCurrentReplicas: Bool {return self._currentReplicas != nil}
  /// Clears the value of `currentReplicas`. Subsequent reads from it will return its default value.
  mutating func clearCurrentReplicas() {self._currentReplicas = nil}

  /// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  /// indicated by updateRevision.
  var updatedReplicas: Int32 {
    get {return _updatedReplicas ?? 0}
    set {_updatedReplicas = newValue}
  }
  /// Returns true if `updatedReplicas` has been explicitly set.
  var hasUpdatedReplicas: Bool {return self._updatedReplicas != nil}
  /// Clears the value of `updatedReplicas`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedReplicas() {self._updatedReplicas = nil}

  /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
  /// sequence [0,currentReplicas).
  var currentRevision: String {
    get {return _currentRevision ?? String()}
    set {_currentRevision = newValue}
  }
  /// Returns true if `currentRevision` has been explicitly set.
  var hasCurrentRevision: Bool {return self._currentRevision != nil}
  /// Clears the value of `currentRevision`. Subsequent reads from it will return its default value.
  mutating func clearCurrentRevision() {self._currentRevision = nil}

  /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
  /// [replicas-updatedReplicas,replicas)
  var updateRevision: String {
    get {return _updateRevision ?? String()}
    set {_updateRevision = newValue}
  }
  /// Returns true if `updateRevision` has been explicitly set.
  var hasUpdateRevision: Bool {return self._updateRevision != nil}
  /// Clears the value of `updateRevision`. Subsequent reads from it will return its default value.
  mutating func clearUpdateRevision() {self._updateRevision = nil}

  /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
  /// uses this field as a collision avoidance mechanism when it needs to create the name for the
  /// newest ControllerRevision.
  /// +optional
  var collisionCount: Int32 {
    get {return _collisionCount ?? 0}
    set {_collisionCount = newValue}
  }
  /// Returns true if `collisionCount` has been explicitly set.
  var hasCollisionCount: Bool {return self._collisionCount != nil}
  /// Clears the value of `collisionCount`. Subsequent reads from it will return its default value.
  mutating func clearCollisionCount() {self._collisionCount = nil}

  /// Represents the latest available observations of a statefulset's current state.
  /// +optional
  /// +patchMergeKey=type
  /// +patchStrategy=merge
  var conditions: [K8s_Io_Api_Apps_V1beta1_StatefulSetCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _observedGeneration: Int64? = nil
  fileprivate var _replicas: Int32? = nil
  fileprivate var _readyReplicas: Int32? = nil
  fileprivate var _currentReplicas: Int32? = nil
  fileprivate var _updatedReplicas: Int32? = nil
  fileprivate var _currentRevision: String? = nil
  fileprivate var _updateRevision: String? = nil
  fileprivate var _collisionCount: Int32? = nil
}

/// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet
/// controller will use to perform updates. It includes any additional parameters
/// necessary to perform the update for the indicated strategy.
struct K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type indicates the type of the StatefulSetUpdateStrategy.
  var type: String {
    get {return _storage._type ?? String()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
  var rollingUpdate: K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy {
    get {return _storage._rollingUpdate ?? K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy()}
    set {_uniqueStorage()._rollingUpdate = newValue}
  }
  /// Returns true if `rollingUpdate` has been explicitly set.
  var hasRollingUpdate: Bool {return _storage._rollingUpdate != nil}
  /// Clears the value of `rollingUpdate`. Subsequent reads from it will return its default value.
  mutating func clearRollingUpdate() {_uniqueStorage()._rollingUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "k8s.io.api.apps.v1beta1"

extension K8s_Io_Api_Apps_V1beta1_ControllerRevision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControllerRevision"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "data"),
    3: .same(proto: "revision"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _data: K8s_Io_Apimachinery_Pkg_Runtime_RawExtension? = nil
    var _revision: Int64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _data = source._data
      _revision = source._revision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._revision)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._revision {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_ControllerRevision, rhs: K8s_Io_Api_Apps_V1beta1_ControllerRevision) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._revision != rhs_storage._revision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_ControllerRevisionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControllerRevisionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Apps_V1beta1_ControllerRevision] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_ControllerRevisionList, rhs: K8s_Io_Api_Apps_V1beta1_ControllerRevisionList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_Deployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deployment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Apps_V1beta1_DeploymentSpec? = nil
    var _status: K8s_Io_Api_Apps_V1beta1_DeploymentStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_Deployment, rhs: K8s_Io_Api_Apps_V1beta1_Deployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    6: .same(proto: "lastUpdateTime"),
    7: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastUpdateTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastUpdateTime = source._lastUpdateTime
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._lastUpdateTime)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._lastUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentCondition, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastUpdateTime != rhs_storage._lastUpdateTime {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Apps_V1beta1_Deployment] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentList, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentRollback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentRollback"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "updatedAnnotations"),
    3: .same(proto: "rollbackTo"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _updatedAnnotations: Dictionary<String,String> = [:]
    var _rollbackTo: K8s_Io_Api_Apps_V1beta1_RollbackConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _updatedAnnotations = source._updatedAnnotations
      _rollbackTo = source._rollbackTo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._updatedAnnotations)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._rollbackTo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._updatedAnnotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._updatedAnnotations, fieldNumber: 2)
      }
      if let v = _storage._rollbackTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentRollback, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentRollback) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._updatedAnnotations != rhs_storage._updatedAnnotations {return false}
        if _storage._rollbackTo != rhs_storage._rollbackTo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "selector"),
    3: .same(proto: "template"),
    4: .same(proto: "strategy"),
    5: .same(proto: "minReadySeconds"),
    6: .same(proto: "revisionHistoryLimit"),
    7: .same(proto: "paused"),
    8: .same(proto: "rollbackTo"),
    9: .same(proto: "progressDeadlineSeconds"),
  ]

  fileprivate class _StorageClass {
    var _replicas: Int32? = nil
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil
    var _strategy: K8s_Io_Api_Apps_V1beta1_DeploymentStrategy? = nil
    var _minReadySeconds: Int32? = nil
    var _revisionHistoryLimit: Int32? = nil
    var _paused: Bool? = nil
    var _rollbackTo: K8s_Io_Api_Apps_V1beta1_RollbackConfig? = nil
    var _progressDeadlineSeconds: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicas = source._replicas
      _selector = source._selector
      _template = source._template
      _strategy = source._strategy
      _minReadySeconds = source._minReadySeconds
      _revisionHistoryLimit = source._revisionHistoryLimit
      _paused = source._paused
      _rollbackTo = source._rollbackTo
      _progressDeadlineSeconds = source._progressDeadlineSeconds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._replicas)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._strategy)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._minReadySeconds)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._revisionHistoryLimit)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._paused)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._rollbackTo)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._progressDeadlineSeconds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._strategy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._minReadySeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._revisionHistoryLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._paused {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._rollbackTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._progressDeadlineSeconds {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentSpec, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._minReadySeconds != rhs_storage._minReadySeconds {return false}
        if _storage._revisionHistoryLimit != rhs_storage._revisionHistoryLimit {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._rollbackTo != rhs_storage._rollbackTo {return false}
        if _storage._progressDeadlineSeconds != rhs_storage._progressDeadlineSeconds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observedGeneration"),
    2: .same(proto: "replicas"),
    3: .same(proto: "updatedReplicas"),
    7: .same(proto: "readyReplicas"),
    4: .same(proto: "availableReplicas"),
    5: .same(proto: "unavailableReplicas"),
    6: .same(proto: "conditions"),
    8: .same(proto: "collisionCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 2: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 3: try decoder.decodeSingularInt32Field(value: &self._updatedReplicas)
      case 4: try decoder.decodeSingularInt32Field(value: &self._availableReplicas)
      case 5: try decoder.decodeSingularInt32Field(value: &self._unavailableReplicas)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      case 7: try decoder.decodeSingularInt32Field(value: &self._readyReplicas)
      case 8: try decoder.decodeSingularInt32Field(value: &self._collisionCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._updatedReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._availableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._unavailableReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 6)
    }
    if let v = self._readyReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._collisionCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentStatus, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentStatus) -> Bool {
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs._replicas != rhs._replicas {return false}
    if lhs._updatedReplicas != rhs._updatedReplicas {return false}
    if lhs._readyReplicas != rhs._readyReplicas {return false}
    if lhs._availableReplicas != rhs._availableReplicas {return false}
    if lhs._unavailableReplicas != rhs._unavailableReplicas {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs._collisionCount != rhs._collisionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_DeploymentStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeploymentStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rollingUpdate"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _rollingUpdate: K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rollingUpdate = source._rollingUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rollingUpdate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rollingUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_DeploymentStrategy, rhs: K8s_Io_Api_Apps_V1beta1_DeploymentStrategy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rollingUpdate != rhs_storage._rollingUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_RollbackConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollbackConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._revision)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._revision {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_RollbackConfig, rhs: K8s_Io_Api_Apps_V1beta1_RollbackConfig) -> Bool {
    if lhs._revision != rhs._revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollingUpdateDeployment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxUnavailable"),
    2: .same(proto: "maxSurge"),
  ]

  fileprivate class _StorageClass {
    var _maxUnavailable: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil
    var _maxSurge: K8s_Io_Apimachinery_Pkg_Util_Intstr_IntOrString? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxUnavailable = source._maxUnavailable
      _maxSurge = source._maxSurge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._maxUnavailable)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._maxSurge)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._maxUnavailable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._maxSurge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment, rhs: K8s_Io_Api_Apps_V1beta1_RollingUpdateDeployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxUnavailable != rhs_storage._maxUnavailable {return false}
        if _storage._maxSurge != rhs_storage._maxSurge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RollingUpdateStatefulSetStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._partition)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._partition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy, rhs: K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy) -> Bool {
    if lhs._partition != rhs._partition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_Scale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scale"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Apps_V1beta1_ScaleSpec? = nil
    var _status: K8s_Io_Api_Apps_V1beta1_ScaleStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_Scale, rhs: K8s_Io_Api_Apps_V1beta1_Scale) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_ScaleSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_ScaleSpec, rhs: K8s_Io_Api_Apps_V1beta1_ScaleSpec) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_ScaleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScaleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "selector"),
    3: .same(proto: "targetSelector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.selector)
      case 3: try decoder.decodeSingularStringField(value: &self._targetSelector)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.selector.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.selector, fieldNumber: 2)
    }
    if let v = self._targetSelector {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_ScaleStatus, rhs: K8s_Io_Api_Apps_V1beta1_ScaleStatus) -> Bool {
    if lhs._replicas != rhs._replicas {return false}
    if lhs.selector != rhs.selector {return false}
    if lhs._targetSelector != rhs._targetSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "spec"),
    3: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ObjectMeta? = nil
    var _spec: K8s_Io_Api_Apps_V1beta1_StatefulSetSpec? = nil
    var _status: K8s_Io_Api_Apps_V1beta1_StatefulSetStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._spec)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSet, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSetCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSetCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
    3: .same(proto: "lastTransitionTime"),
    4: .same(proto: "reason"),
    5: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _status: String? = nil
    var _lastTransitionTime: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_Time? = nil
    var _reason: String? = nil
    var _message: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _status = source._status
      _lastTransitionTime = source._lastTransitionTime
      _reason = source._reason
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lastTransitionTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._status {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lastTransitionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSetCondition, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSetCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._lastTransitionTime != rhs_storage._lastTransitionTime {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSetList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSetList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "items"),
  ]

  fileprivate class _StorageClass {
    var _metadata: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_ListMeta? = nil
    var _items: [K8s_Io_Api_Apps_V1beta1_StatefulSet] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _items = source._items
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._items)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSetList, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSetList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._items != rhs_storage._items {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSetSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicas"),
    2: .same(proto: "selector"),
    3: .same(proto: "template"),
    4: .same(proto: "volumeClaimTemplates"),
    5: .same(proto: "serviceName"),
    6: .same(proto: "podManagementPolicy"),
    7: .same(proto: "updateStrategy"),
    8: .same(proto: "revisionHistoryLimit"),
  ]

  fileprivate class _StorageClass {
    var _replicas: Int32? = nil
    var _selector: K8s_Io_Apimachinery_Pkg_Apis_Meta_V1_LabelSelector? = nil
    var _template: K8s_Io_Api_Core_V1_PodTemplateSpec? = nil
    var _volumeClaimTemplates: [K8s_Io_Api_Core_V1_PersistentVolumeClaim] = []
    var _serviceName: String? = nil
    var _podManagementPolicy: String? = nil
    var _updateStrategy: K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy? = nil
    var _revisionHistoryLimit: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicas = source._replicas
      _selector = source._selector
      _template = source._template
      _volumeClaimTemplates = source._volumeClaimTemplates
      _serviceName = source._serviceName
      _podManagementPolicy = source._podManagementPolicy
      _updateStrategy = source._updateStrategy
      _revisionHistoryLimit = source._revisionHistoryLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._replicas)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._selector)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._template)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._volumeClaimTemplates)
        case 5: try decoder.decodeSingularStringField(value: &_storage._serviceName)
        case 6: try decoder.decodeSingularStringField(value: &_storage._podManagementPolicy)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._updateStrategy)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._revisionHistoryLimit)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicas {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._selector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._template {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._volumeClaimTemplates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumeClaimTemplates, fieldNumber: 4)
      }
      if let v = _storage._serviceName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._podManagementPolicy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._updateStrategy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._revisionHistoryLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSetSpec, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSetSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicas != rhs_storage._replicas {return false}
        if _storage._selector != rhs_storage._selector {return false}
        if _storage._template != rhs_storage._template {return false}
        if _storage._volumeClaimTemplates != rhs_storage._volumeClaimTemplates {return false}
        if _storage._serviceName != rhs_storage._serviceName {return false}
        if _storage._podManagementPolicy != rhs_storage._podManagementPolicy {return false}
        if _storage._updateStrategy != rhs_storage._updateStrategy {return false}
        if _storage._revisionHistoryLimit != rhs_storage._revisionHistoryLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSetStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "observedGeneration"),
    2: .same(proto: "replicas"),
    3: .same(proto: "readyReplicas"),
    4: .same(proto: "currentReplicas"),
    5: .same(proto: "updatedReplicas"),
    6: .same(proto: "currentRevision"),
    7: .same(proto: "updateRevision"),
    9: .same(proto: "collisionCount"),
    10: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self._observedGeneration)
      case 2: try decoder.decodeSingularInt32Field(value: &self._replicas)
      case 3: try decoder.decodeSingularInt32Field(value: &self._readyReplicas)
      case 4: try decoder.decodeSingularInt32Field(value: &self._currentReplicas)
      case 5: try decoder.decodeSingularInt32Field(value: &self._updatedReplicas)
      case 6: try decoder.decodeSingularStringField(value: &self._currentRevision)
      case 7: try decoder.decodeSingularStringField(value: &self._updateRevision)
      case 9: try decoder.decodeSingularInt32Field(value: &self._collisionCount)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.conditions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._observedGeneration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._replicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._readyReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._currentReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._updatedReplicas {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._currentRevision {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._updateRevision {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._collisionCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSetStatus, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSetStatus) -> Bool {
    if lhs._observedGeneration != rhs._observedGeneration {return false}
    if lhs._replicas != rhs._replicas {return false}
    if lhs._readyReplicas != rhs._readyReplicas {return false}
    if lhs._currentReplicas != rhs._currentReplicas {return false}
    if lhs._updatedReplicas != rhs._updatedReplicas {return false}
    if lhs._currentRevision != rhs._currentRevision {return false}
    if lhs._updateRevision != rhs._updateRevision {return false}
    if lhs._collisionCount != rhs._collisionCount {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatefulSetUpdateStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rollingUpdate"),
  ]

  fileprivate class _StorageClass {
    var _type: String? = nil
    var _rollingUpdate: K8s_Io_Api_Apps_V1beta1_RollingUpdateStatefulSetStrategy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rollingUpdate = source._rollingUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rollingUpdate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rollingUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy, rhs: K8s_Io_Api_Apps_V1beta1_StatefulSetUpdateStrategy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rollingUpdate != rhs_storage._rollingUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
